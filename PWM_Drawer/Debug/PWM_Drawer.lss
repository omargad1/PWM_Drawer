
PWM_Drawer.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000032e  00800200  000080b4  00008148  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000080b4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001097  0080052e  0080052e  00008476  2**0
                  ALLOC
  3 .stab         000084fc  00000000  00000000  00008478  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004589  00000000  00000000  00010974  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001e0  00000000  00000000  00014efd  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000234  00000000  00000000  000150dd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002791  00000000  00000000  00015311  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000015bc  00000000  00000000  00017aa2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000013e2  00000000  00000000  0001905e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000200  00000000  00000000  0001a440  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000342  00000000  00000000  0001a640  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000b12  00000000  00000000  0001a982  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001b494  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
       8:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
       c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      10:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      14:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      18:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      1c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      20:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      24:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      28:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      2c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      30:	0c 94 16 0a 	jmp	0x142c	; 0x142c <__vector_12>
      34:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      38:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      3c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      40:	0c 94 9d 32 	jmp	0x653a	; 0x653a <__vector_16>
      44:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      48:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      4c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      50:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      54:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      58:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      5c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      60:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      64:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      68:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      6c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      70:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      74:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      78:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      7c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      80:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      84:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      88:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      8c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      90:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      94:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      98:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      9c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      a0:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      a4:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      a8:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      ac:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      b0:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      b4:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      b8:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      bc:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      c0:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      c4:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      c8:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      cc:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      d0:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      d4:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      d8:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      dc:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      e0:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61

000000f0 <__do_copy_data>:
      f0:	15 e0       	ldi	r17, 0x05	; 5
      f2:	a0 e0       	ldi	r26, 0x00	; 0
      f4:	b2 e0       	ldi	r27, 0x02	; 2
      f6:	e4 eb       	ldi	r30, 0xB4	; 180
      f8:	f0 e8       	ldi	r31, 0x80	; 128
      fa:	02 c0       	rjmp	.+4      	; 0x100 <.do_copy_data_start>

000000fc <.do_copy_data_loop>:
      fc:	05 90       	lpm	r0, Z+
      fe:	0d 92       	st	X+, r0

00000100 <.do_copy_data_start>:
     100:	ae 32       	cpi	r26, 0x2E	; 46
     102:	b1 07       	cpc	r27, r17
     104:	d9 f7       	brne	.-10     	; 0xfc <.do_copy_data_loop>

00000106 <__do_clear_bss>:
     106:	15 e1       	ldi	r17, 0x15	; 21
     108:	ae e2       	ldi	r26, 0x2E	; 46
     10a:	b5 e0       	ldi	r27, 0x05	; 5
     10c:	01 c0       	rjmp	.+2      	; 0x110 <.do_clear_bss_start>

0000010e <.do_clear_bss_loop>:
     10e:	1d 92       	st	X+, r1

00000110 <.do_clear_bss_start>:
     110:	a5 3c       	cpi	r26, 0xC5	; 197
     112:	b1 07       	cpc	r27, r17
     114:	e1 f7       	brne	.-8      	; 0x10e <.do_clear_bss_loop>
     116:	0e 94 be 3e 	call	0x7d7c	; 0x7d7c <main>
     11a:	0c 94 58 40 	jmp	0x80b0	; 0x80b0 <_exit>

0000011e <__bad_interrupt>:
     11e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000122 <__lshrdi3>:
     122:	ef 92       	push	r14
     124:	ff 92       	push	r15
     126:	0f 93       	push	r16
     128:	df 93       	push	r29
     12a:	cf 93       	push	r28
     12c:	cd b7       	in	r28, 0x3d	; 61
     12e:	de b7       	in	r29, 0x3e	; 62
     130:	60 97       	sbiw	r28, 0x10	; 16
     132:	0f b6       	in	r0, 0x3f	; 63
     134:	f8 94       	cli
     136:	de bf       	out	0x3e, r29	; 62
     138:	0f be       	out	0x3f, r0	; 63
     13a:	cd bf       	out	0x3d, r28	; 61
     13c:	a8 2f       	mov	r26, r24
     13e:	00 23       	and	r16, r16
     140:	09 f4       	brne	.+2      	; 0x144 <__lshrdi3+0x22>
     142:	61 c0       	rjmp	.+194    	; 0x206 <__lshrdi3+0xe4>
     144:	7e 01       	movw	r14, r28
     146:	08 94       	sec
     148:	e1 1c       	adc	r14, r1
     14a:	f1 1c       	adc	r15, r1
     14c:	88 e0       	ldi	r24, 0x08	; 8
     14e:	f7 01       	movw	r30, r14
     150:	11 92       	st	Z+, r1
     152:	8a 95       	dec	r24
     154:	e9 f7       	brne	.-6      	; 0x150 <__lshrdi3+0x2e>
     156:	29 83       	std	Y+1, r18	; 0x01
     158:	3a 83       	std	Y+2, r19	; 0x02
     15a:	4b 83       	std	Y+3, r20	; 0x03
     15c:	5c 83       	std	Y+4, r21	; 0x04
     15e:	6d 83       	std	Y+5, r22	; 0x05
     160:	7e 83       	std	Y+6, r23	; 0x06
     162:	af 83       	std	Y+7, r26	; 0x07
     164:	98 87       	std	Y+8, r25	; 0x08
     166:	80 e2       	ldi	r24, 0x20	; 32
     168:	80 1b       	sub	r24, r16
     16a:	e8 2f       	mov	r30, r24
     16c:	ff 27       	eor	r31, r31
     16e:	e7 fd       	sbrc	r30, 7
     170:	f0 95       	com	r31
     172:	4d 81       	ldd	r20, Y+5	; 0x05
     174:	5e 81       	ldd	r21, Y+6	; 0x06
     176:	6f 81       	ldd	r22, Y+7	; 0x07
     178:	78 85       	ldd	r23, Y+8	; 0x08
     17a:	18 16       	cp	r1, r24
     17c:	84 f0       	brlt	.+32     	; 0x19e <__lshrdi3+0x7c>
     17e:	1d 86       	std	Y+13, r1	; 0x0d
     180:	1e 86       	std	Y+14, r1	; 0x0e
     182:	1f 86       	std	Y+15, r1	; 0x0f
     184:	18 8a       	std	Y+16, r1	; 0x10
     186:	88 27       	eor	r24, r24
     188:	99 27       	eor	r25, r25
     18a:	8e 1b       	sub	r24, r30
     18c:	9f 0b       	sbc	r25, r31
     18e:	04 c0       	rjmp	.+8      	; 0x198 <__lshrdi3+0x76>
     190:	76 95       	lsr	r23
     192:	67 95       	ror	r22
     194:	57 95       	ror	r21
     196:	47 95       	ror	r20
     198:	8a 95       	dec	r24
     19a:	d2 f7       	brpl	.-12     	; 0x190 <__lshrdi3+0x6e>
     19c:	28 c0       	rjmp	.+80     	; 0x1ee <__lshrdi3+0xcc>
     19e:	20 2f       	mov	r18, r16
     1a0:	33 27       	eor	r19, r19
     1a2:	27 fd       	sbrc	r18, 7
     1a4:	30 95       	com	r19
     1a6:	db 01       	movw	r26, r22
     1a8:	ca 01       	movw	r24, r20
     1aa:	02 2e       	mov	r0, r18
     1ac:	04 c0       	rjmp	.+8      	; 0x1b6 <__lshrdi3+0x94>
     1ae:	b6 95       	lsr	r27
     1b0:	a7 95       	ror	r26
     1b2:	97 95       	ror	r25
     1b4:	87 95       	ror	r24
     1b6:	0a 94       	dec	r0
     1b8:	d2 f7       	brpl	.-12     	; 0x1ae <__lshrdi3+0x8c>
     1ba:	8d 87       	std	Y+13, r24	; 0x0d
     1bc:	9e 87       	std	Y+14, r25	; 0x0e
     1be:	af 87       	std	Y+15, r26	; 0x0f
     1c0:	b8 8b       	std	Y+16, r27	; 0x10
     1c2:	04 c0       	rjmp	.+8      	; 0x1cc <__lshrdi3+0xaa>
     1c4:	44 0f       	add	r20, r20
     1c6:	55 1f       	adc	r21, r21
     1c8:	66 1f       	adc	r22, r22
     1ca:	77 1f       	adc	r23, r23
     1cc:	ea 95       	dec	r30
     1ce:	d2 f7       	brpl	.-12     	; 0x1c4 <__lshrdi3+0xa2>
     1d0:	89 81       	ldd	r24, Y+1	; 0x01
     1d2:	9a 81       	ldd	r25, Y+2	; 0x02
     1d4:	ab 81       	ldd	r26, Y+3	; 0x03
     1d6:	bc 81       	ldd	r27, Y+4	; 0x04
     1d8:	04 c0       	rjmp	.+8      	; 0x1e2 <__lshrdi3+0xc0>
     1da:	b6 95       	lsr	r27
     1dc:	a7 95       	ror	r26
     1de:	97 95       	ror	r25
     1e0:	87 95       	ror	r24
     1e2:	2a 95       	dec	r18
     1e4:	d2 f7       	brpl	.-12     	; 0x1da <__lshrdi3+0xb8>
     1e6:	48 2b       	or	r20, r24
     1e8:	59 2b       	or	r21, r25
     1ea:	6a 2b       	or	r22, r26
     1ec:	7b 2b       	or	r23, r27
     1ee:	49 87       	std	Y+9, r20	; 0x09
     1f0:	5a 87       	std	Y+10, r21	; 0x0a
     1f2:	6b 87       	std	Y+11, r22	; 0x0b
     1f4:	7c 87       	std	Y+12, r23	; 0x0c
     1f6:	29 85       	ldd	r18, Y+9	; 0x09
     1f8:	3a 85       	ldd	r19, Y+10	; 0x0a
     1fa:	4b 85       	ldd	r20, Y+11	; 0x0b
     1fc:	5c 85       	ldd	r21, Y+12	; 0x0c
     1fe:	6d 85       	ldd	r22, Y+13	; 0x0d
     200:	7e 85       	ldd	r23, Y+14	; 0x0e
     202:	af 85       	ldd	r26, Y+15	; 0x0f
     204:	98 89       	ldd	r25, Y+16	; 0x10
     206:	8a 2f       	mov	r24, r26
     208:	60 96       	adiw	r28, 0x10	; 16
     20a:	0f b6       	in	r0, 0x3f	; 63
     20c:	f8 94       	cli
     20e:	de bf       	out	0x3e, r29	; 62
     210:	0f be       	out	0x3f, r0	; 63
     212:	cd bf       	out	0x3d, r28	; 61
     214:	cf 91       	pop	r28
     216:	df 91       	pop	r29
     218:	0f 91       	pop	r16
     21a:	ff 90       	pop	r15
     21c:	ef 90       	pop	r14
     21e:	08 95       	ret

00000220 <__fixunssfsi>:
     220:	ef 92       	push	r14
     222:	ff 92       	push	r15
     224:	0f 93       	push	r16
     226:	1f 93       	push	r17
     228:	7b 01       	movw	r14, r22
     22a:	8c 01       	movw	r16, r24
     22c:	20 e0       	ldi	r18, 0x00	; 0
     22e:	30 e0       	ldi	r19, 0x00	; 0
     230:	40 e0       	ldi	r20, 0x00	; 0
     232:	5f e4       	ldi	r21, 0x4F	; 79
     234:	0e 94 bc 04 	call	0x978	; 0x978 <__gesf2>
     238:	88 23       	and	r24, r24
     23a:	8c f0       	brlt	.+34     	; 0x25e <__fixunssfsi+0x3e>
     23c:	c8 01       	movw	r24, r16
     23e:	b7 01       	movw	r22, r14
     240:	20 e0       	ldi	r18, 0x00	; 0
     242:	30 e0       	ldi	r19, 0x00	; 0
     244:	40 e0       	ldi	r20, 0x00	; 0
     246:	5f e4       	ldi	r21, 0x4F	; 79
     248:	0e 94 88 02 	call	0x510	; 0x510 <__subsf3>
     24c:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <__fixsfsi>
     250:	9b 01       	movw	r18, r22
     252:	ac 01       	movw	r20, r24
     254:	20 50       	subi	r18, 0x00	; 0
     256:	30 40       	sbci	r19, 0x00	; 0
     258:	40 40       	sbci	r20, 0x00	; 0
     25a:	50 48       	sbci	r21, 0x80	; 128
     25c:	06 c0       	rjmp	.+12     	; 0x26a <__fixunssfsi+0x4a>
     25e:	c8 01       	movw	r24, r16
     260:	b7 01       	movw	r22, r14
     262:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <__fixsfsi>
     266:	9b 01       	movw	r18, r22
     268:	ac 01       	movw	r20, r24
     26a:	b9 01       	movw	r22, r18
     26c:	ca 01       	movw	r24, r20
     26e:	1f 91       	pop	r17
     270:	0f 91       	pop	r16
     272:	ff 90       	pop	r15
     274:	ef 90       	pop	r14
     276:	08 95       	ret

00000278 <_fpadd_parts>:
     278:	a0 e0       	ldi	r26, 0x00	; 0
     27a:	b0 e0       	ldi	r27, 0x00	; 0
     27c:	e2 e4       	ldi	r30, 0x42	; 66
     27e:	f1 e0       	ldi	r31, 0x01	; 1
     280:	0c 94 e0 3f 	jmp	0x7fc0	; 0x7fc0 <__prologue_saves__>
     284:	dc 01       	movw	r26, r24
     286:	2b 01       	movw	r4, r22
     288:	fa 01       	movw	r30, r20
     28a:	9c 91       	ld	r25, X
     28c:	92 30       	cpi	r25, 0x02	; 2
     28e:	08 f4       	brcc	.+2      	; 0x292 <_fpadd_parts+0x1a>
     290:	39 c1       	rjmp	.+626    	; 0x504 <_fpadd_parts+0x28c>
     292:	eb 01       	movw	r28, r22
     294:	88 81       	ld	r24, Y
     296:	82 30       	cpi	r24, 0x02	; 2
     298:	08 f4       	brcc	.+2      	; 0x29c <_fpadd_parts+0x24>
     29a:	33 c1       	rjmp	.+614    	; 0x502 <_fpadd_parts+0x28a>
     29c:	94 30       	cpi	r25, 0x04	; 4
     29e:	69 f4       	brne	.+26     	; 0x2ba <_fpadd_parts+0x42>
     2a0:	84 30       	cpi	r24, 0x04	; 4
     2a2:	09 f0       	breq	.+2      	; 0x2a6 <_fpadd_parts+0x2e>
     2a4:	2f c1       	rjmp	.+606    	; 0x504 <_fpadd_parts+0x28c>
     2a6:	11 96       	adiw	r26, 0x01	; 1
     2a8:	9c 91       	ld	r25, X
     2aa:	11 97       	sbiw	r26, 0x01	; 1
     2ac:	89 81       	ldd	r24, Y+1	; 0x01
     2ae:	98 17       	cp	r25, r24
     2b0:	09 f4       	brne	.+2      	; 0x2b4 <_fpadd_parts+0x3c>
     2b2:	28 c1       	rjmp	.+592    	; 0x504 <_fpadd_parts+0x28c>
     2b4:	a2 e4       	ldi	r26, 0x42	; 66
     2b6:	b2 e0       	ldi	r27, 0x02	; 2
     2b8:	25 c1       	rjmp	.+586    	; 0x504 <_fpadd_parts+0x28c>
     2ba:	84 30       	cpi	r24, 0x04	; 4
     2bc:	09 f4       	brne	.+2      	; 0x2c0 <_fpadd_parts+0x48>
     2be:	21 c1       	rjmp	.+578    	; 0x502 <_fpadd_parts+0x28a>
     2c0:	82 30       	cpi	r24, 0x02	; 2
     2c2:	a9 f4       	brne	.+42     	; 0x2ee <_fpadd_parts+0x76>
     2c4:	92 30       	cpi	r25, 0x02	; 2
     2c6:	09 f0       	breq	.+2      	; 0x2ca <_fpadd_parts+0x52>
     2c8:	1d c1       	rjmp	.+570    	; 0x504 <_fpadd_parts+0x28c>
     2ca:	9a 01       	movw	r18, r20
     2cc:	ad 01       	movw	r20, r26
     2ce:	88 e0       	ldi	r24, 0x08	; 8
     2d0:	ea 01       	movw	r28, r20
     2d2:	09 90       	ld	r0, Y+
     2d4:	ae 01       	movw	r20, r28
     2d6:	e9 01       	movw	r28, r18
     2d8:	09 92       	st	Y+, r0
     2da:	9e 01       	movw	r18, r28
     2dc:	81 50       	subi	r24, 0x01	; 1
     2de:	c1 f7       	brne	.-16     	; 0x2d0 <_fpadd_parts+0x58>
     2e0:	e2 01       	movw	r28, r4
     2e2:	89 81       	ldd	r24, Y+1	; 0x01
     2e4:	11 96       	adiw	r26, 0x01	; 1
     2e6:	9c 91       	ld	r25, X
     2e8:	89 23       	and	r24, r25
     2ea:	81 83       	std	Z+1, r24	; 0x01
     2ec:	08 c1       	rjmp	.+528    	; 0x4fe <_fpadd_parts+0x286>
     2ee:	92 30       	cpi	r25, 0x02	; 2
     2f0:	09 f4       	brne	.+2      	; 0x2f4 <_fpadd_parts+0x7c>
     2f2:	07 c1       	rjmp	.+526    	; 0x502 <_fpadd_parts+0x28a>
     2f4:	12 96       	adiw	r26, 0x02	; 2
     2f6:	2d 90       	ld	r2, X+
     2f8:	3c 90       	ld	r3, X
     2fa:	13 97       	sbiw	r26, 0x03	; 3
     2fc:	eb 01       	movw	r28, r22
     2fe:	8a 81       	ldd	r24, Y+2	; 0x02
     300:	9b 81       	ldd	r25, Y+3	; 0x03
     302:	14 96       	adiw	r26, 0x04	; 4
     304:	ad 90       	ld	r10, X+
     306:	bd 90       	ld	r11, X+
     308:	cd 90       	ld	r12, X+
     30a:	dc 90       	ld	r13, X
     30c:	17 97       	sbiw	r26, 0x07	; 7
     30e:	ec 80       	ldd	r14, Y+4	; 0x04
     310:	fd 80       	ldd	r15, Y+5	; 0x05
     312:	0e 81       	ldd	r16, Y+6	; 0x06
     314:	1f 81       	ldd	r17, Y+7	; 0x07
     316:	91 01       	movw	r18, r2
     318:	28 1b       	sub	r18, r24
     31a:	39 0b       	sbc	r19, r25
     31c:	b9 01       	movw	r22, r18
     31e:	37 ff       	sbrs	r19, 7
     320:	04 c0       	rjmp	.+8      	; 0x32a <_fpadd_parts+0xb2>
     322:	66 27       	eor	r22, r22
     324:	77 27       	eor	r23, r23
     326:	62 1b       	sub	r22, r18
     328:	73 0b       	sbc	r23, r19
     32a:	60 32       	cpi	r22, 0x20	; 32
     32c:	71 05       	cpc	r23, r1
     32e:	0c f0       	brlt	.+2      	; 0x332 <_fpadd_parts+0xba>
     330:	61 c0       	rjmp	.+194    	; 0x3f4 <_fpadd_parts+0x17c>
     332:	12 16       	cp	r1, r18
     334:	13 06       	cpc	r1, r19
     336:	6c f5       	brge	.+90     	; 0x392 <_fpadd_parts+0x11a>
     338:	37 01       	movw	r6, r14
     33a:	48 01       	movw	r8, r16
     33c:	06 2e       	mov	r0, r22
     33e:	04 c0       	rjmp	.+8      	; 0x348 <_fpadd_parts+0xd0>
     340:	96 94       	lsr	r9
     342:	87 94       	ror	r8
     344:	77 94       	ror	r7
     346:	67 94       	ror	r6
     348:	0a 94       	dec	r0
     34a:	d2 f7       	brpl	.-12     	; 0x340 <_fpadd_parts+0xc8>
     34c:	21 e0       	ldi	r18, 0x01	; 1
     34e:	30 e0       	ldi	r19, 0x00	; 0
     350:	40 e0       	ldi	r20, 0x00	; 0
     352:	50 e0       	ldi	r21, 0x00	; 0
     354:	04 c0       	rjmp	.+8      	; 0x35e <_fpadd_parts+0xe6>
     356:	22 0f       	add	r18, r18
     358:	33 1f       	adc	r19, r19
     35a:	44 1f       	adc	r20, r20
     35c:	55 1f       	adc	r21, r21
     35e:	6a 95       	dec	r22
     360:	d2 f7       	brpl	.-12     	; 0x356 <_fpadd_parts+0xde>
     362:	21 50       	subi	r18, 0x01	; 1
     364:	30 40       	sbci	r19, 0x00	; 0
     366:	40 40       	sbci	r20, 0x00	; 0
     368:	50 40       	sbci	r21, 0x00	; 0
     36a:	2e 21       	and	r18, r14
     36c:	3f 21       	and	r19, r15
     36e:	40 23       	and	r20, r16
     370:	51 23       	and	r21, r17
     372:	21 15       	cp	r18, r1
     374:	31 05       	cpc	r19, r1
     376:	41 05       	cpc	r20, r1
     378:	51 05       	cpc	r21, r1
     37a:	21 f0       	breq	.+8      	; 0x384 <_fpadd_parts+0x10c>
     37c:	21 e0       	ldi	r18, 0x01	; 1
     37e:	30 e0       	ldi	r19, 0x00	; 0
     380:	40 e0       	ldi	r20, 0x00	; 0
     382:	50 e0       	ldi	r21, 0x00	; 0
     384:	79 01       	movw	r14, r18
     386:	8a 01       	movw	r16, r20
     388:	e6 28       	or	r14, r6
     38a:	f7 28       	or	r15, r7
     38c:	08 29       	or	r16, r8
     38e:	19 29       	or	r17, r9
     390:	3c c0       	rjmp	.+120    	; 0x40a <_fpadd_parts+0x192>
     392:	23 2b       	or	r18, r19
     394:	d1 f1       	breq	.+116    	; 0x40a <_fpadd_parts+0x192>
     396:	26 0e       	add	r2, r22
     398:	37 1e       	adc	r3, r23
     39a:	35 01       	movw	r6, r10
     39c:	46 01       	movw	r8, r12
     39e:	06 2e       	mov	r0, r22
     3a0:	04 c0       	rjmp	.+8      	; 0x3aa <_fpadd_parts+0x132>
     3a2:	96 94       	lsr	r9
     3a4:	87 94       	ror	r8
     3a6:	77 94       	ror	r7
     3a8:	67 94       	ror	r6
     3aa:	0a 94       	dec	r0
     3ac:	d2 f7       	brpl	.-12     	; 0x3a2 <_fpadd_parts+0x12a>
     3ae:	21 e0       	ldi	r18, 0x01	; 1
     3b0:	30 e0       	ldi	r19, 0x00	; 0
     3b2:	40 e0       	ldi	r20, 0x00	; 0
     3b4:	50 e0       	ldi	r21, 0x00	; 0
     3b6:	04 c0       	rjmp	.+8      	; 0x3c0 <_fpadd_parts+0x148>
     3b8:	22 0f       	add	r18, r18
     3ba:	33 1f       	adc	r19, r19
     3bc:	44 1f       	adc	r20, r20
     3be:	55 1f       	adc	r21, r21
     3c0:	6a 95       	dec	r22
     3c2:	d2 f7       	brpl	.-12     	; 0x3b8 <_fpadd_parts+0x140>
     3c4:	21 50       	subi	r18, 0x01	; 1
     3c6:	30 40       	sbci	r19, 0x00	; 0
     3c8:	40 40       	sbci	r20, 0x00	; 0
     3ca:	50 40       	sbci	r21, 0x00	; 0
     3cc:	2a 21       	and	r18, r10
     3ce:	3b 21       	and	r19, r11
     3d0:	4c 21       	and	r20, r12
     3d2:	5d 21       	and	r21, r13
     3d4:	21 15       	cp	r18, r1
     3d6:	31 05       	cpc	r19, r1
     3d8:	41 05       	cpc	r20, r1
     3da:	51 05       	cpc	r21, r1
     3dc:	21 f0       	breq	.+8      	; 0x3e6 <_fpadd_parts+0x16e>
     3de:	21 e0       	ldi	r18, 0x01	; 1
     3e0:	30 e0       	ldi	r19, 0x00	; 0
     3e2:	40 e0       	ldi	r20, 0x00	; 0
     3e4:	50 e0       	ldi	r21, 0x00	; 0
     3e6:	59 01       	movw	r10, r18
     3e8:	6a 01       	movw	r12, r20
     3ea:	a6 28       	or	r10, r6
     3ec:	b7 28       	or	r11, r7
     3ee:	c8 28       	or	r12, r8
     3f0:	d9 28       	or	r13, r9
     3f2:	0b c0       	rjmp	.+22     	; 0x40a <_fpadd_parts+0x192>
     3f4:	82 15       	cp	r24, r2
     3f6:	93 05       	cpc	r25, r3
     3f8:	2c f0       	brlt	.+10     	; 0x404 <_fpadd_parts+0x18c>
     3fa:	1c 01       	movw	r2, r24
     3fc:	aa 24       	eor	r10, r10
     3fe:	bb 24       	eor	r11, r11
     400:	65 01       	movw	r12, r10
     402:	03 c0       	rjmp	.+6      	; 0x40a <_fpadd_parts+0x192>
     404:	ee 24       	eor	r14, r14
     406:	ff 24       	eor	r15, r15
     408:	87 01       	movw	r16, r14
     40a:	11 96       	adiw	r26, 0x01	; 1
     40c:	9c 91       	ld	r25, X
     40e:	d2 01       	movw	r26, r4
     410:	11 96       	adiw	r26, 0x01	; 1
     412:	8c 91       	ld	r24, X
     414:	98 17       	cp	r25, r24
     416:	09 f4       	brne	.+2      	; 0x41a <_fpadd_parts+0x1a2>
     418:	45 c0       	rjmp	.+138    	; 0x4a4 <_fpadd_parts+0x22c>
     41a:	99 23       	and	r25, r25
     41c:	39 f0       	breq	.+14     	; 0x42c <_fpadd_parts+0x1b4>
     41e:	a8 01       	movw	r20, r16
     420:	97 01       	movw	r18, r14
     422:	2a 19       	sub	r18, r10
     424:	3b 09       	sbc	r19, r11
     426:	4c 09       	sbc	r20, r12
     428:	5d 09       	sbc	r21, r13
     42a:	06 c0       	rjmp	.+12     	; 0x438 <_fpadd_parts+0x1c0>
     42c:	a6 01       	movw	r20, r12
     42e:	95 01       	movw	r18, r10
     430:	2e 19       	sub	r18, r14
     432:	3f 09       	sbc	r19, r15
     434:	40 0b       	sbc	r20, r16
     436:	51 0b       	sbc	r21, r17
     438:	57 fd       	sbrc	r21, 7
     43a:	08 c0       	rjmp	.+16     	; 0x44c <_fpadd_parts+0x1d4>
     43c:	11 82       	std	Z+1, r1	; 0x01
     43e:	33 82       	std	Z+3, r3	; 0x03
     440:	22 82       	std	Z+2, r2	; 0x02
     442:	24 83       	std	Z+4, r18	; 0x04
     444:	35 83       	std	Z+5, r19	; 0x05
     446:	46 83       	std	Z+6, r20	; 0x06
     448:	57 83       	std	Z+7, r21	; 0x07
     44a:	1d c0       	rjmp	.+58     	; 0x486 <_fpadd_parts+0x20e>
     44c:	81 e0       	ldi	r24, 0x01	; 1
     44e:	81 83       	std	Z+1, r24	; 0x01
     450:	33 82       	std	Z+3, r3	; 0x03
     452:	22 82       	std	Z+2, r2	; 0x02
     454:	88 27       	eor	r24, r24
     456:	99 27       	eor	r25, r25
     458:	dc 01       	movw	r26, r24
     45a:	82 1b       	sub	r24, r18
     45c:	93 0b       	sbc	r25, r19
     45e:	a4 0b       	sbc	r26, r20
     460:	b5 0b       	sbc	r27, r21
     462:	84 83       	std	Z+4, r24	; 0x04
     464:	95 83       	std	Z+5, r25	; 0x05
     466:	a6 83       	std	Z+6, r26	; 0x06
     468:	b7 83       	std	Z+7, r27	; 0x07
     46a:	0d c0       	rjmp	.+26     	; 0x486 <_fpadd_parts+0x20e>
     46c:	22 0f       	add	r18, r18
     46e:	33 1f       	adc	r19, r19
     470:	44 1f       	adc	r20, r20
     472:	55 1f       	adc	r21, r21
     474:	24 83       	std	Z+4, r18	; 0x04
     476:	35 83       	std	Z+5, r19	; 0x05
     478:	46 83       	std	Z+6, r20	; 0x06
     47a:	57 83       	std	Z+7, r21	; 0x07
     47c:	82 81       	ldd	r24, Z+2	; 0x02
     47e:	93 81       	ldd	r25, Z+3	; 0x03
     480:	01 97       	sbiw	r24, 0x01	; 1
     482:	93 83       	std	Z+3, r25	; 0x03
     484:	82 83       	std	Z+2, r24	; 0x02
     486:	24 81       	ldd	r18, Z+4	; 0x04
     488:	35 81       	ldd	r19, Z+5	; 0x05
     48a:	46 81       	ldd	r20, Z+6	; 0x06
     48c:	57 81       	ldd	r21, Z+7	; 0x07
     48e:	da 01       	movw	r26, r20
     490:	c9 01       	movw	r24, r18
     492:	01 97       	sbiw	r24, 0x01	; 1
     494:	a1 09       	sbc	r26, r1
     496:	b1 09       	sbc	r27, r1
     498:	8f 5f       	subi	r24, 0xFF	; 255
     49a:	9f 4f       	sbci	r25, 0xFF	; 255
     49c:	af 4f       	sbci	r26, 0xFF	; 255
     49e:	bf 43       	sbci	r27, 0x3F	; 63
     4a0:	28 f3       	brcs	.-54     	; 0x46c <_fpadd_parts+0x1f4>
     4a2:	0b c0       	rjmp	.+22     	; 0x4ba <_fpadd_parts+0x242>
     4a4:	91 83       	std	Z+1, r25	; 0x01
     4a6:	33 82       	std	Z+3, r3	; 0x03
     4a8:	22 82       	std	Z+2, r2	; 0x02
     4aa:	ea 0c       	add	r14, r10
     4ac:	fb 1c       	adc	r15, r11
     4ae:	0c 1d       	adc	r16, r12
     4b0:	1d 1d       	adc	r17, r13
     4b2:	e4 82       	std	Z+4, r14	; 0x04
     4b4:	f5 82       	std	Z+5, r15	; 0x05
     4b6:	06 83       	std	Z+6, r16	; 0x06
     4b8:	17 83       	std	Z+7, r17	; 0x07
     4ba:	83 e0       	ldi	r24, 0x03	; 3
     4bc:	80 83       	st	Z, r24
     4be:	24 81       	ldd	r18, Z+4	; 0x04
     4c0:	35 81       	ldd	r19, Z+5	; 0x05
     4c2:	46 81       	ldd	r20, Z+6	; 0x06
     4c4:	57 81       	ldd	r21, Z+7	; 0x07
     4c6:	57 ff       	sbrs	r21, 7
     4c8:	1a c0       	rjmp	.+52     	; 0x4fe <_fpadd_parts+0x286>
     4ca:	c9 01       	movw	r24, r18
     4cc:	aa 27       	eor	r26, r26
     4ce:	97 fd       	sbrc	r25, 7
     4d0:	a0 95       	com	r26
     4d2:	ba 2f       	mov	r27, r26
     4d4:	81 70       	andi	r24, 0x01	; 1
     4d6:	90 70       	andi	r25, 0x00	; 0
     4d8:	a0 70       	andi	r26, 0x00	; 0
     4da:	b0 70       	andi	r27, 0x00	; 0
     4dc:	56 95       	lsr	r21
     4de:	47 95       	ror	r20
     4e0:	37 95       	ror	r19
     4e2:	27 95       	ror	r18
     4e4:	82 2b       	or	r24, r18
     4e6:	93 2b       	or	r25, r19
     4e8:	a4 2b       	or	r26, r20
     4ea:	b5 2b       	or	r27, r21
     4ec:	84 83       	std	Z+4, r24	; 0x04
     4ee:	95 83       	std	Z+5, r25	; 0x05
     4f0:	a6 83       	std	Z+6, r26	; 0x06
     4f2:	b7 83       	std	Z+7, r27	; 0x07
     4f4:	82 81       	ldd	r24, Z+2	; 0x02
     4f6:	93 81       	ldd	r25, Z+3	; 0x03
     4f8:	01 96       	adiw	r24, 0x01	; 1
     4fa:	93 83       	std	Z+3, r25	; 0x03
     4fc:	82 83       	std	Z+2, r24	; 0x02
     4fe:	df 01       	movw	r26, r30
     500:	01 c0       	rjmp	.+2      	; 0x504 <_fpadd_parts+0x28c>
     502:	d2 01       	movw	r26, r4
     504:	cd 01       	movw	r24, r26
     506:	cd b7       	in	r28, 0x3d	; 61
     508:	de b7       	in	r29, 0x3e	; 62
     50a:	e2 e1       	ldi	r30, 0x12	; 18
     50c:	0c 94 fc 3f 	jmp	0x7ff8	; 0x7ff8 <__epilogue_restores__>

00000510 <__subsf3>:
     510:	a0 e2       	ldi	r26, 0x20	; 32
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	ee e8       	ldi	r30, 0x8E	; 142
     516:	f2 e0       	ldi	r31, 0x02	; 2
     518:	0c 94 ec 3f 	jmp	0x7fd8	; 0x7fd8 <__prologue_saves__+0x18>
     51c:	69 83       	std	Y+1, r22	; 0x01
     51e:	7a 83       	std	Y+2, r23	; 0x02
     520:	8b 83       	std	Y+3, r24	; 0x03
     522:	9c 83       	std	Y+4, r25	; 0x04
     524:	2d 83       	std	Y+5, r18	; 0x05
     526:	3e 83       	std	Y+6, r19	; 0x06
     528:	4f 83       	std	Y+7, r20	; 0x07
     52a:	58 87       	std	Y+8, r21	; 0x08
     52c:	e9 e0       	ldi	r30, 0x09	; 9
     52e:	ee 2e       	mov	r14, r30
     530:	f1 2c       	mov	r15, r1
     532:	ec 0e       	add	r14, r28
     534:	fd 1e       	adc	r15, r29
     536:	ce 01       	movw	r24, r28
     538:	01 96       	adiw	r24, 0x01	; 1
     53a:	b7 01       	movw	r22, r14
     53c:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     540:	8e 01       	movw	r16, r28
     542:	0f 5e       	subi	r16, 0xEF	; 239
     544:	1f 4f       	sbci	r17, 0xFF	; 255
     546:	ce 01       	movw	r24, r28
     548:	05 96       	adiw	r24, 0x05	; 5
     54a:	b8 01       	movw	r22, r16
     54c:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     550:	8a 89       	ldd	r24, Y+18	; 0x12
     552:	91 e0       	ldi	r25, 0x01	; 1
     554:	89 27       	eor	r24, r25
     556:	8a 8b       	std	Y+18, r24	; 0x12
     558:	c7 01       	movw	r24, r14
     55a:	b8 01       	movw	r22, r16
     55c:	ae 01       	movw	r20, r28
     55e:	47 5e       	subi	r20, 0xE7	; 231
     560:	5f 4f       	sbci	r21, 0xFF	; 255
     562:	0e 94 3c 01 	call	0x278	; 0x278 <_fpadd_parts>
     566:	0e 94 96 06 	call	0xd2c	; 0xd2c <__pack_f>
     56a:	a0 96       	adiw	r28, 0x20	; 32
     56c:	e6 e0       	ldi	r30, 0x06	; 6
     56e:	0c 94 08 40 	jmp	0x8010	; 0x8010 <__epilogue_restores__+0x18>

00000572 <__addsf3>:
     572:	a0 e2       	ldi	r26, 0x20	; 32
     574:	b0 e0       	ldi	r27, 0x00	; 0
     576:	ef eb       	ldi	r30, 0xBF	; 191
     578:	f2 e0       	ldi	r31, 0x02	; 2
     57a:	0c 94 ec 3f 	jmp	0x7fd8	; 0x7fd8 <__prologue_saves__+0x18>
     57e:	69 83       	std	Y+1, r22	; 0x01
     580:	7a 83       	std	Y+2, r23	; 0x02
     582:	8b 83       	std	Y+3, r24	; 0x03
     584:	9c 83       	std	Y+4, r25	; 0x04
     586:	2d 83       	std	Y+5, r18	; 0x05
     588:	3e 83       	std	Y+6, r19	; 0x06
     58a:	4f 83       	std	Y+7, r20	; 0x07
     58c:	58 87       	std	Y+8, r21	; 0x08
     58e:	f9 e0       	ldi	r31, 0x09	; 9
     590:	ef 2e       	mov	r14, r31
     592:	f1 2c       	mov	r15, r1
     594:	ec 0e       	add	r14, r28
     596:	fd 1e       	adc	r15, r29
     598:	ce 01       	movw	r24, r28
     59a:	01 96       	adiw	r24, 0x01	; 1
     59c:	b7 01       	movw	r22, r14
     59e:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     5a2:	8e 01       	movw	r16, r28
     5a4:	0f 5e       	subi	r16, 0xEF	; 239
     5a6:	1f 4f       	sbci	r17, 0xFF	; 255
     5a8:	ce 01       	movw	r24, r28
     5aa:	05 96       	adiw	r24, 0x05	; 5
     5ac:	b8 01       	movw	r22, r16
     5ae:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     5b2:	c7 01       	movw	r24, r14
     5b4:	b8 01       	movw	r22, r16
     5b6:	ae 01       	movw	r20, r28
     5b8:	47 5e       	subi	r20, 0xE7	; 231
     5ba:	5f 4f       	sbci	r21, 0xFF	; 255
     5bc:	0e 94 3c 01 	call	0x278	; 0x278 <_fpadd_parts>
     5c0:	0e 94 96 06 	call	0xd2c	; 0xd2c <__pack_f>
     5c4:	a0 96       	adiw	r28, 0x20	; 32
     5c6:	e6 e0       	ldi	r30, 0x06	; 6
     5c8:	0c 94 08 40 	jmp	0x8010	; 0x8010 <__epilogue_restores__+0x18>

000005cc <__mulsf3>:
     5cc:	a0 e2       	ldi	r26, 0x20	; 32
     5ce:	b0 e0       	ldi	r27, 0x00	; 0
     5d0:	ec ee       	ldi	r30, 0xEC	; 236
     5d2:	f2 e0       	ldi	r31, 0x02	; 2
     5d4:	0c 94 e0 3f 	jmp	0x7fc0	; 0x7fc0 <__prologue_saves__>
     5d8:	69 83       	std	Y+1, r22	; 0x01
     5da:	7a 83       	std	Y+2, r23	; 0x02
     5dc:	8b 83       	std	Y+3, r24	; 0x03
     5de:	9c 83       	std	Y+4, r25	; 0x04
     5e0:	2d 83       	std	Y+5, r18	; 0x05
     5e2:	3e 83       	std	Y+6, r19	; 0x06
     5e4:	4f 83       	std	Y+7, r20	; 0x07
     5e6:	58 87       	std	Y+8, r21	; 0x08
     5e8:	ce 01       	movw	r24, r28
     5ea:	01 96       	adiw	r24, 0x01	; 1
     5ec:	be 01       	movw	r22, r28
     5ee:	67 5f       	subi	r22, 0xF7	; 247
     5f0:	7f 4f       	sbci	r23, 0xFF	; 255
     5f2:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     5f6:	ce 01       	movw	r24, r28
     5f8:	05 96       	adiw	r24, 0x05	; 5
     5fa:	be 01       	movw	r22, r28
     5fc:	6f 5e       	subi	r22, 0xEF	; 239
     5fe:	7f 4f       	sbci	r23, 0xFF	; 255
     600:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     604:	99 85       	ldd	r25, Y+9	; 0x09
     606:	92 30       	cpi	r25, 0x02	; 2
     608:	88 f0       	brcs	.+34     	; 0x62c <__mulsf3+0x60>
     60a:	89 89       	ldd	r24, Y+17	; 0x11
     60c:	82 30       	cpi	r24, 0x02	; 2
     60e:	c8 f0       	brcs	.+50     	; 0x642 <__mulsf3+0x76>
     610:	94 30       	cpi	r25, 0x04	; 4
     612:	19 f4       	brne	.+6      	; 0x61a <__mulsf3+0x4e>
     614:	82 30       	cpi	r24, 0x02	; 2
     616:	51 f4       	brne	.+20     	; 0x62c <__mulsf3+0x60>
     618:	04 c0       	rjmp	.+8      	; 0x622 <__mulsf3+0x56>
     61a:	84 30       	cpi	r24, 0x04	; 4
     61c:	29 f4       	brne	.+10     	; 0x628 <__mulsf3+0x5c>
     61e:	92 30       	cpi	r25, 0x02	; 2
     620:	81 f4       	brne	.+32     	; 0x642 <__mulsf3+0x76>
     622:	82 e4       	ldi	r24, 0x42	; 66
     624:	92 e0       	ldi	r25, 0x02	; 2
     626:	c6 c0       	rjmp	.+396    	; 0x7b4 <__mulsf3+0x1e8>
     628:	92 30       	cpi	r25, 0x02	; 2
     62a:	49 f4       	brne	.+18     	; 0x63e <__mulsf3+0x72>
     62c:	20 e0       	ldi	r18, 0x00	; 0
     62e:	9a 85       	ldd	r25, Y+10	; 0x0a
     630:	8a 89       	ldd	r24, Y+18	; 0x12
     632:	98 13       	cpse	r25, r24
     634:	21 e0       	ldi	r18, 0x01	; 1
     636:	2a 87       	std	Y+10, r18	; 0x0a
     638:	ce 01       	movw	r24, r28
     63a:	09 96       	adiw	r24, 0x09	; 9
     63c:	bb c0       	rjmp	.+374    	; 0x7b4 <__mulsf3+0x1e8>
     63e:	82 30       	cpi	r24, 0x02	; 2
     640:	49 f4       	brne	.+18     	; 0x654 <__mulsf3+0x88>
     642:	20 e0       	ldi	r18, 0x00	; 0
     644:	9a 85       	ldd	r25, Y+10	; 0x0a
     646:	8a 89       	ldd	r24, Y+18	; 0x12
     648:	98 13       	cpse	r25, r24
     64a:	21 e0       	ldi	r18, 0x01	; 1
     64c:	2a 8b       	std	Y+18, r18	; 0x12
     64e:	ce 01       	movw	r24, r28
     650:	41 96       	adiw	r24, 0x11	; 17
     652:	b0 c0       	rjmp	.+352    	; 0x7b4 <__mulsf3+0x1e8>
     654:	2d 84       	ldd	r2, Y+13	; 0x0d
     656:	3e 84       	ldd	r3, Y+14	; 0x0e
     658:	4f 84       	ldd	r4, Y+15	; 0x0f
     65a:	58 88       	ldd	r5, Y+16	; 0x10
     65c:	6d 88       	ldd	r6, Y+21	; 0x15
     65e:	7e 88       	ldd	r7, Y+22	; 0x16
     660:	8f 88       	ldd	r8, Y+23	; 0x17
     662:	98 8c       	ldd	r9, Y+24	; 0x18
     664:	ee 24       	eor	r14, r14
     666:	ff 24       	eor	r15, r15
     668:	87 01       	movw	r16, r14
     66a:	aa 24       	eor	r10, r10
     66c:	bb 24       	eor	r11, r11
     66e:	65 01       	movw	r12, r10
     670:	40 e0       	ldi	r20, 0x00	; 0
     672:	50 e0       	ldi	r21, 0x00	; 0
     674:	60 e0       	ldi	r22, 0x00	; 0
     676:	70 e0       	ldi	r23, 0x00	; 0
     678:	e0 e0       	ldi	r30, 0x00	; 0
     67a:	f0 e0       	ldi	r31, 0x00	; 0
     67c:	c1 01       	movw	r24, r2
     67e:	81 70       	andi	r24, 0x01	; 1
     680:	90 70       	andi	r25, 0x00	; 0
     682:	89 2b       	or	r24, r25
     684:	e9 f0       	breq	.+58     	; 0x6c0 <__mulsf3+0xf4>
     686:	e6 0c       	add	r14, r6
     688:	f7 1c       	adc	r15, r7
     68a:	08 1d       	adc	r16, r8
     68c:	19 1d       	adc	r17, r9
     68e:	9a 01       	movw	r18, r20
     690:	ab 01       	movw	r20, r22
     692:	2a 0d       	add	r18, r10
     694:	3b 1d       	adc	r19, r11
     696:	4c 1d       	adc	r20, r12
     698:	5d 1d       	adc	r21, r13
     69a:	80 e0       	ldi	r24, 0x00	; 0
     69c:	90 e0       	ldi	r25, 0x00	; 0
     69e:	a0 e0       	ldi	r26, 0x00	; 0
     6a0:	b0 e0       	ldi	r27, 0x00	; 0
     6a2:	e6 14       	cp	r14, r6
     6a4:	f7 04       	cpc	r15, r7
     6a6:	08 05       	cpc	r16, r8
     6a8:	19 05       	cpc	r17, r9
     6aa:	20 f4       	brcc	.+8      	; 0x6b4 <__mulsf3+0xe8>
     6ac:	81 e0       	ldi	r24, 0x01	; 1
     6ae:	90 e0       	ldi	r25, 0x00	; 0
     6b0:	a0 e0       	ldi	r26, 0x00	; 0
     6b2:	b0 e0       	ldi	r27, 0x00	; 0
     6b4:	ba 01       	movw	r22, r20
     6b6:	a9 01       	movw	r20, r18
     6b8:	48 0f       	add	r20, r24
     6ba:	59 1f       	adc	r21, r25
     6bc:	6a 1f       	adc	r22, r26
     6be:	7b 1f       	adc	r23, r27
     6c0:	aa 0c       	add	r10, r10
     6c2:	bb 1c       	adc	r11, r11
     6c4:	cc 1c       	adc	r12, r12
     6c6:	dd 1c       	adc	r13, r13
     6c8:	97 fe       	sbrs	r9, 7
     6ca:	08 c0       	rjmp	.+16     	; 0x6dc <__mulsf3+0x110>
     6cc:	81 e0       	ldi	r24, 0x01	; 1
     6ce:	90 e0       	ldi	r25, 0x00	; 0
     6d0:	a0 e0       	ldi	r26, 0x00	; 0
     6d2:	b0 e0       	ldi	r27, 0x00	; 0
     6d4:	a8 2a       	or	r10, r24
     6d6:	b9 2a       	or	r11, r25
     6d8:	ca 2a       	or	r12, r26
     6da:	db 2a       	or	r13, r27
     6dc:	31 96       	adiw	r30, 0x01	; 1
     6de:	e0 32       	cpi	r30, 0x20	; 32
     6e0:	f1 05       	cpc	r31, r1
     6e2:	49 f0       	breq	.+18     	; 0x6f6 <__mulsf3+0x12a>
     6e4:	66 0c       	add	r6, r6
     6e6:	77 1c       	adc	r7, r7
     6e8:	88 1c       	adc	r8, r8
     6ea:	99 1c       	adc	r9, r9
     6ec:	56 94       	lsr	r5
     6ee:	47 94       	ror	r4
     6f0:	37 94       	ror	r3
     6f2:	27 94       	ror	r2
     6f4:	c3 cf       	rjmp	.-122    	; 0x67c <__mulsf3+0xb0>
     6f6:	fa 85       	ldd	r31, Y+10	; 0x0a
     6f8:	ea 89       	ldd	r30, Y+18	; 0x12
     6fa:	2b 89       	ldd	r18, Y+19	; 0x13
     6fc:	3c 89       	ldd	r19, Y+20	; 0x14
     6fe:	8b 85       	ldd	r24, Y+11	; 0x0b
     700:	9c 85       	ldd	r25, Y+12	; 0x0c
     702:	28 0f       	add	r18, r24
     704:	39 1f       	adc	r19, r25
     706:	2e 5f       	subi	r18, 0xFE	; 254
     708:	3f 4f       	sbci	r19, 0xFF	; 255
     70a:	17 c0       	rjmp	.+46     	; 0x73a <__mulsf3+0x16e>
     70c:	ca 01       	movw	r24, r20
     70e:	81 70       	andi	r24, 0x01	; 1
     710:	90 70       	andi	r25, 0x00	; 0
     712:	89 2b       	or	r24, r25
     714:	61 f0       	breq	.+24     	; 0x72e <__mulsf3+0x162>
     716:	16 95       	lsr	r17
     718:	07 95       	ror	r16
     71a:	f7 94       	ror	r15
     71c:	e7 94       	ror	r14
     71e:	80 e0       	ldi	r24, 0x00	; 0
     720:	90 e0       	ldi	r25, 0x00	; 0
     722:	a0 e0       	ldi	r26, 0x00	; 0
     724:	b0 e8       	ldi	r27, 0x80	; 128
     726:	e8 2a       	or	r14, r24
     728:	f9 2a       	or	r15, r25
     72a:	0a 2b       	or	r16, r26
     72c:	1b 2b       	or	r17, r27
     72e:	76 95       	lsr	r23
     730:	67 95       	ror	r22
     732:	57 95       	ror	r21
     734:	47 95       	ror	r20
     736:	2f 5f       	subi	r18, 0xFF	; 255
     738:	3f 4f       	sbci	r19, 0xFF	; 255
     73a:	77 fd       	sbrc	r23, 7
     73c:	e7 cf       	rjmp	.-50     	; 0x70c <__mulsf3+0x140>
     73e:	0c c0       	rjmp	.+24     	; 0x758 <__mulsf3+0x18c>
     740:	44 0f       	add	r20, r20
     742:	55 1f       	adc	r21, r21
     744:	66 1f       	adc	r22, r22
     746:	77 1f       	adc	r23, r23
     748:	17 fd       	sbrc	r17, 7
     74a:	41 60       	ori	r20, 0x01	; 1
     74c:	ee 0c       	add	r14, r14
     74e:	ff 1c       	adc	r15, r15
     750:	00 1f       	adc	r16, r16
     752:	11 1f       	adc	r17, r17
     754:	21 50       	subi	r18, 0x01	; 1
     756:	30 40       	sbci	r19, 0x00	; 0
     758:	40 30       	cpi	r20, 0x00	; 0
     75a:	90 e0       	ldi	r25, 0x00	; 0
     75c:	59 07       	cpc	r21, r25
     75e:	90 e0       	ldi	r25, 0x00	; 0
     760:	69 07       	cpc	r22, r25
     762:	90 e4       	ldi	r25, 0x40	; 64
     764:	79 07       	cpc	r23, r25
     766:	60 f3       	brcs	.-40     	; 0x740 <__mulsf3+0x174>
     768:	2b 8f       	std	Y+27, r18	; 0x1b
     76a:	3c 8f       	std	Y+28, r19	; 0x1c
     76c:	db 01       	movw	r26, r22
     76e:	ca 01       	movw	r24, r20
     770:	8f 77       	andi	r24, 0x7F	; 127
     772:	90 70       	andi	r25, 0x00	; 0
     774:	a0 70       	andi	r26, 0x00	; 0
     776:	b0 70       	andi	r27, 0x00	; 0
     778:	80 34       	cpi	r24, 0x40	; 64
     77a:	91 05       	cpc	r25, r1
     77c:	a1 05       	cpc	r26, r1
     77e:	b1 05       	cpc	r27, r1
     780:	61 f4       	brne	.+24     	; 0x79a <__mulsf3+0x1ce>
     782:	47 fd       	sbrc	r20, 7
     784:	0a c0       	rjmp	.+20     	; 0x79a <__mulsf3+0x1ce>
     786:	e1 14       	cp	r14, r1
     788:	f1 04       	cpc	r15, r1
     78a:	01 05       	cpc	r16, r1
     78c:	11 05       	cpc	r17, r1
     78e:	29 f0       	breq	.+10     	; 0x79a <__mulsf3+0x1ce>
     790:	40 5c       	subi	r20, 0xC0	; 192
     792:	5f 4f       	sbci	r21, 0xFF	; 255
     794:	6f 4f       	sbci	r22, 0xFF	; 255
     796:	7f 4f       	sbci	r23, 0xFF	; 255
     798:	40 78       	andi	r20, 0x80	; 128
     79a:	1a 8e       	std	Y+26, r1	; 0x1a
     79c:	fe 17       	cp	r31, r30
     79e:	11 f0       	breq	.+4      	; 0x7a4 <__mulsf3+0x1d8>
     7a0:	81 e0       	ldi	r24, 0x01	; 1
     7a2:	8a 8f       	std	Y+26, r24	; 0x1a
     7a4:	4d 8f       	std	Y+29, r20	; 0x1d
     7a6:	5e 8f       	std	Y+30, r21	; 0x1e
     7a8:	6f 8f       	std	Y+31, r22	; 0x1f
     7aa:	78 a3       	std	Y+32, r23	; 0x20
     7ac:	83 e0       	ldi	r24, 0x03	; 3
     7ae:	89 8f       	std	Y+25, r24	; 0x19
     7b0:	ce 01       	movw	r24, r28
     7b2:	49 96       	adiw	r24, 0x19	; 25
     7b4:	0e 94 96 06 	call	0xd2c	; 0xd2c <__pack_f>
     7b8:	a0 96       	adiw	r28, 0x20	; 32
     7ba:	e2 e1       	ldi	r30, 0x12	; 18
     7bc:	0c 94 fc 3f 	jmp	0x7ff8	; 0x7ff8 <__epilogue_restores__>

000007c0 <__divsf3>:
     7c0:	a8 e1       	ldi	r26, 0x18	; 24
     7c2:	b0 e0       	ldi	r27, 0x00	; 0
     7c4:	e6 ee       	ldi	r30, 0xE6	; 230
     7c6:	f3 e0       	ldi	r31, 0x03	; 3
     7c8:	0c 94 e8 3f 	jmp	0x7fd0	; 0x7fd0 <__prologue_saves__+0x10>
     7cc:	69 83       	std	Y+1, r22	; 0x01
     7ce:	7a 83       	std	Y+2, r23	; 0x02
     7d0:	8b 83       	std	Y+3, r24	; 0x03
     7d2:	9c 83       	std	Y+4, r25	; 0x04
     7d4:	2d 83       	std	Y+5, r18	; 0x05
     7d6:	3e 83       	std	Y+6, r19	; 0x06
     7d8:	4f 83       	std	Y+7, r20	; 0x07
     7da:	58 87       	std	Y+8, r21	; 0x08
     7dc:	b9 e0       	ldi	r27, 0x09	; 9
     7de:	eb 2e       	mov	r14, r27
     7e0:	f1 2c       	mov	r15, r1
     7e2:	ec 0e       	add	r14, r28
     7e4:	fd 1e       	adc	r15, r29
     7e6:	ce 01       	movw	r24, r28
     7e8:	01 96       	adiw	r24, 0x01	; 1
     7ea:	b7 01       	movw	r22, r14
     7ec:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     7f0:	8e 01       	movw	r16, r28
     7f2:	0f 5e       	subi	r16, 0xEF	; 239
     7f4:	1f 4f       	sbci	r17, 0xFF	; 255
     7f6:	ce 01       	movw	r24, r28
     7f8:	05 96       	adiw	r24, 0x05	; 5
     7fa:	b8 01       	movw	r22, r16
     7fc:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     800:	29 85       	ldd	r18, Y+9	; 0x09
     802:	22 30       	cpi	r18, 0x02	; 2
     804:	08 f4       	brcc	.+2      	; 0x808 <__divsf3+0x48>
     806:	7e c0       	rjmp	.+252    	; 0x904 <__divsf3+0x144>
     808:	39 89       	ldd	r19, Y+17	; 0x11
     80a:	32 30       	cpi	r19, 0x02	; 2
     80c:	10 f4       	brcc	.+4      	; 0x812 <__divsf3+0x52>
     80e:	b8 01       	movw	r22, r16
     810:	7c c0       	rjmp	.+248    	; 0x90a <__divsf3+0x14a>
     812:	8a 85       	ldd	r24, Y+10	; 0x0a
     814:	9a 89       	ldd	r25, Y+18	; 0x12
     816:	89 27       	eor	r24, r25
     818:	8a 87       	std	Y+10, r24	; 0x0a
     81a:	24 30       	cpi	r18, 0x04	; 4
     81c:	11 f0       	breq	.+4      	; 0x822 <__divsf3+0x62>
     81e:	22 30       	cpi	r18, 0x02	; 2
     820:	31 f4       	brne	.+12     	; 0x82e <__divsf3+0x6e>
     822:	23 17       	cp	r18, r19
     824:	09 f0       	breq	.+2      	; 0x828 <__divsf3+0x68>
     826:	6e c0       	rjmp	.+220    	; 0x904 <__divsf3+0x144>
     828:	62 e4       	ldi	r22, 0x42	; 66
     82a:	72 e0       	ldi	r23, 0x02	; 2
     82c:	6e c0       	rjmp	.+220    	; 0x90a <__divsf3+0x14a>
     82e:	34 30       	cpi	r19, 0x04	; 4
     830:	39 f4       	brne	.+14     	; 0x840 <__divsf3+0x80>
     832:	1d 86       	std	Y+13, r1	; 0x0d
     834:	1e 86       	std	Y+14, r1	; 0x0e
     836:	1f 86       	std	Y+15, r1	; 0x0f
     838:	18 8a       	std	Y+16, r1	; 0x10
     83a:	1c 86       	std	Y+12, r1	; 0x0c
     83c:	1b 86       	std	Y+11, r1	; 0x0b
     83e:	04 c0       	rjmp	.+8      	; 0x848 <__divsf3+0x88>
     840:	32 30       	cpi	r19, 0x02	; 2
     842:	21 f4       	brne	.+8      	; 0x84c <__divsf3+0x8c>
     844:	84 e0       	ldi	r24, 0x04	; 4
     846:	89 87       	std	Y+9, r24	; 0x09
     848:	b7 01       	movw	r22, r14
     84a:	5f c0       	rjmp	.+190    	; 0x90a <__divsf3+0x14a>
     84c:	2b 85       	ldd	r18, Y+11	; 0x0b
     84e:	3c 85       	ldd	r19, Y+12	; 0x0c
     850:	8b 89       	ldd	r24, Y+19	; 0x13
     852:	9c 89       	ldd	r25, Y+20	; 0x14
     854:	28 1b       	sub	r18, r24
     856:	39 0b       	sbc	r19, r25
     858:	3c 87       	std	Y+12, r19	; 0x0c
     85a:	2b 87       	std	Y+11, r18	; 0x0b
     85c:	ed 84       	ldd	r14, Y+13	; 0x0d
     85e:	fe 84       	ldd	r15, Y+14	; 0x0e
     860:	0f 85       	ldd	r16, Y+15	; 0x0f
     862:	18 89       	ldd	r17, Y+16	; 0x10
     864:	ad 88       	ldd	r10, Y+21	; 0x15
     866:	be 88       	ldd	r11, Y+22	; 0x16
     868:	cf 88       	ldd	r12, Y+23	; 0x17
     86a:	d8 8c       	ldd	r13, Y+24	; 0x18
     86c:	ea 14       	cp	r14, r10
     86e:	fb 04       	cpc	r15, r11
     870:	0c 05       	cpc	r16, r12
     872:	1d 05       	cpc	r17, r13
     874:	40 f4       	brcc	.+16     	; 0x886 <__divsf3+0xc6>
     876:	ee 0c       	add	r14, r14
     878:	ff 1c       	adc	r15, r15
     87a:	00 1f       	adc	r16, r16
     87c:	11 1f       	adc	r17, r17
     87e:	21 50       	subi	r18, 0x01	; 1
     880:	30 40       	sbci	r19, 0x00	; 0
     882:	3c 87       	std	Y+12, r19	; 0x0c
     884:	2b 87       	std	Y+11, r18	; 0x0b
     886:	20 e0       	ldi	r18, 0x00	; 0
     888:	30 e0       	ldi	r19, 0x00	; 0
     88a:	40 e0       	ldi	r20, 0x00	; 0
     88c:	50 e0       	ldi	r21, 0x00	; 0
     88e:	80 e0       	ldi	r24, 0x00	; 0
     890:	90 e0       	ldi	r25, 0x00	; 0
     892:	a0 e0       	ldi	r26, 0x00	; 0
     894:	b0 e4       	ldi	r27, 0x40	; 64
     896:	60 e0       	ldi	r22, 0x00	; 0
     898:	70 e0       	ldi	r23, 0x00	; 0
     89a:	ea 14       	cp	r14, r10
     89c:	fb 04       	cpc	r15, r11
     89e:	0c 05       	cpc	r16, r12
     8a0:	1d 05       	cpc	r17, r13
     8a2:	40 f0       	brcs	.+16     	; 0x8b4 <__divsf3+0xf4>
     8a4:	28 2b       	or	r18, r24
     8a6:	39 2b       	or	r19, r25
     8a8:	4a 2b       	or	r20, r26
     8aa:	5b 2b       	or	r21, r27
     8ac:	ea 18       	sub	r14, r10
     8ae:	fb 08       	sbc	r15, r11
     8b0:	0c 09       	sbc	r16, r12
     8b2:	1d 09       	sbc	r17, r13
     8b4:	b6 95       	lsr	r27
     8b6:	a7 95       	ror	r26
     8b8:	97 95       	ror	r25
     8ba:	87 95       	ror	r24
     8bc:	ee 0c       	add	r14, r14
     8be:	ff 1c       	adc	r15, r15
     8c0:	00 1f       	adc	r16, r16
     8c2:	11 1f       	adc	r17, r17
     8c4:	6f 5f       	subi	r22, 0xFF	; 255
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	6f 31       	cpi	r22, 0x1F	; 31
     8ca:	71 05       	cpc	r23, r1
     8cc:	31 f7       	brne	.-52     	; 0x89a <__divsf3+0xda>
     8ce:	da 01       	movw	r26, r20
     8d0:	c9 01       	movw	r24, r18
     8d2:	8f 77       	andi	r24, 0x7F	; 127
     8d4:	90 70       	andi	r25, 0x00	; 0
     8d6:	a0 70       	andi	r26, 0x00	; 0
     8d8:	b0 70       	andi	r27, 0x00	; 0
     8da:	80 34       	cpi	r24, 0x40	; 64
     8dc:	91 05       	cpc	r25, r1
     8de:	a1 05       	cpc	r26, r1
     8e0:	b1 05       	cpc	r27, r1
     8e2:	61 f4       	brne	.+24     	; 0x8fc <__divsf3+0x13c>
     8e4:	27 fd       	sbrc	r18, 7
     8e6:	0a c0       	rjmp	.+20     	; 0x8fc <__divsf3+0x13c>
     8e8:	e1 14       	cp	r14, r1
     8ea:	f1 04       	cpc	r15, r1
     8ec:	01 05       	cpc	r16, r1
     8ee:	11 05       	cpc	r17, r1
     8f0:	29 f0       	breq	.+10     	; 0x8fc <__divsf3+0x13c>
     8f2:	20 5c       	subi	r18, 0xC0	; 192
     8f4:	3f 4f       	sbci	r19, 0xFF	; 255
     8f6:	4f 4f       	sbci	r20, 0xFF	; 255
     8f8:	5f 4f       	sbci	r21, 0xFF	; 255
     8fa:	20 78       	andi	r18, 0x80	; 128
     8fc:	2d 87       	std	Y+13, r18	; 0x0d
     8fe:	3e 87       	std	Y+14, r19	; 0x0e
     900:	4f 87       	std	Y+15, r20	; 0x0f
     902:	58 8b       	std	Y+16, r21	; 0x10
     904:	be 01       	movw	r22, r28
     906:	67 5f       	subi	r22, 0xF7	; 247
     908:	7f 4f       	sbci	r23, 0xFF	; 255
     90a:	cb 01       	movw	r24, r22
     90c:	0e 94 96 06 	call	0xd2c	; 0xd2c <__pack_f>
     910:	68 96       	adiw	r28, 0x18	; 24
     912:	ea e0       	ldi	r30, 0x0A	; 10
     914:	0c 94 04 40 	jmp	0x8008	; 0x8008 <__epilogue_restores__+0x10>

00000918 <__gtsf2>:
     918:	a8 e1       	ldi	r26, 0x18	; 24
     91a:	b0 e0       	ldi	r27, 0x00	; 0
     91c:	e2 e9       	ldi	r30, 0x92	; 146
     91e:	f4 e0       	ldi	r31, 0x04	; 4
     920:	0c 94 ec 3f 	jmp	0x7fd8	; 0x7fd8 <__prologue_saves__+0x18>
     924:	69 83       	std	Y+1, r22	; 0x01
     926:	7a 83       	std	Y+2, r23	; 0x02
     928:	8b 83       	std	Y+3, r24	; 0x03
     92a:	9c 83       	std	Y+4, r25	; 0x04
     92c:	2d 83       	std	Y+5, r18	; 0x05
     92e:	3e 83       	std	Y+6, r19	; 0x06
     930:	4f 83       	std	Y+7, r20	; 0x07
     932:	58 87       	std	Y+8, r21	; 0x08
     934:	89 e0       	ldi	r24, 0x09	; 9
     936:	e8 2e       	mov	r14, r24
     938:	f1 2c       	mov	r15, r1
     93a:	ec 0e       	add	r14, r28
     93c:	fd 1e       	adc	r15, r29
     93e:	ce 01       	movw	r24, r28
     940:	01 96       	adiw	r24, 0x01	; 1
     942:	b7 01       	movw	r22, r14
     944:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     948:	8e 01       	movw	r16, r28
     94a:	0f 5e       	subi	r16, 0xEF	; 239
     94c:	1f 4f       	sbci	r17, 0xFF	; 255
     94e:	ce 01       	movw	r24, r28
     950:	05 96       	adiw	r24, 0x05	; 5
     952:	b8 01       	movw	r22, r16
     954:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     958:	89 85       	ldd	r24, Y+9	; 0x09
     95a:	82 30       	cpi	r24, 0x02	; 2
     95c:	40 f0       	brcs	.+16     	; 0x96e <__gtsf2+0x56>
     95e:	89 89       	ldd	r24, Y+17	; 0x11
     960:	82 30       	cpi	r24, 0x02	; 2
     962:	28 f0       	brcs	.+10     	; 0x96e <__gtsf2+0x56>
     964:	c7 01       	movw	r24, r14
     966:	b8 01       	movw	r22, r16
     968:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <__fpcmp_parts_f>
     96c:	01 c0       	rjmp	.+2      	; 0x970 <__gtsf2+0x58>
     96e:	8f ef       	ldi	r24, 0xFF	; 255
     970:	68 96       	adiw	r28, 0x18	; 24
     972:	e6 e0       	ldi	r30, 0x06	; 6
     974:	0c 94 08 40 	jmp	0x8010	; 0x8010 <__epilogue_restores__+0x18>

00000978 <__gesf2>:
     978:	a8 e1       	ldi	r26, 0x18	; 24
     97a:	b0 e0       	ldi	r27, 0x00	; 0
     97c:	e2 ec       	ldi	r30, 0xC2	; 194
     97e:	f4 e0       	ldi	r31, 0x04	; 4
     980:	0c 94 ec 3f 	jmp	0x7fd8	; 0x7fd8 <__prologue_saves__+0x18>
     984:	69 83       	std	Y+1, r22	; 0x01
     986:	7a 83       	std	Y+2, r23	; 0x02
     988:	8b 83       	std	Y+3, r24	; 0x03
     98a:	9c 83       	std	Y+4, r25	; 0x04
     98c:	2d 83       	std	Y+5, r18	; 0x05
     98e:	3e 83       	std	Y+6, r19	; 0x06
     990:	4f 83       	std	Y+7, r20	; 0x07
     992:	58 87       	std	Y+8, r21	; 0x08
     994:	89 e0       	ldi	r24, 0x09	; 9
     996:	e8 2e       	mov	r14, r24
     998:	f1 2c       	mov	r15, r1
     99a:	ec 0e       	add	r14, r28
     99c:	fd 1e       	adc	r15, r29
     99e:	ce 01       	movw	r24, r28
     9a0:	01 96       	adiw	r24, 0x01	; 1
     9a2:	b7 01       	movw	r22, r14
     9a4:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     9a8:	8e 01       	movw	r16, r28
     9aa:	0f 5e       	subi	r16, 0xEF	; 239
     9ac:	1f 4f       	sbci	r17, 0xFF	; 255
     9ae:	ce 01       	movw	r24, r28
     9b0:	05 96       	adiw	r24, 0x05	; 5
     9b2:	b8 01       	movw	r22, r16
     9b4:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     9b8:	89 85       	ldd	r24, Y+9	; 0x09
     9ba:	82 30       	cpi	r24, 0x02	; 2
     9bc:	40 f0       	brcs	.+16     	; 0x9ce <__gesf2+0x56>
     9be:	89 89       	ldd	r24, Y+17	; 0x11
     9c0:	82 30       	cpi	r24, 0x02	; 2
     9c2:	28 f0       	brcs	.+10     	; 0x9ce <__gesf2+0x56>
     9c4:	c7 01       	movw	r24, r14
     9c6:	b8 01       	movw	r22, r16
     9c8:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <__fpcmp_parts_f>
     9cc:	01 c0       	rjmp	.+2      	; 0x9d0 <__gesf2+0x58>
     9ce:	8f ef       	ldi	r24, 0xFF	; 255
     9d0:	68 96       	adiw	r28, 0x18	; 24
     9d2:	e6 e0       	ldi	r30, 0x06	; 6
     9d4:	0c 94 08 40 	jmp	0x8010	; 0x8010 <__epilogue_restores__+0x18>

000009d8 <__ltsf2>:
     9d8:	a8 e1       	ldi	r26, 0x18	; 24
     9da:	b0 e0       	ldi	r27, 0x00	; 0
     9dc:	e2 ef       	ldi	r30, 0xF2	; 242
     9de:	f4 e0       	ldi	r31, 0x04	; 4
     9e0:	0c 94 ec 3f 	jmp	0x7fd8	; 0x7fd8 <__prologue_saves__+0x18>
     9e4:	69 83       	std	Y+1, r22	; 0x01
     9e6:	7a 83       	std	Y+2, r23	; 0x02
     9e8:	8b 83       	std	Y+3, r24	; 0x03
     9ea:	9c 83       	std	Y+4, r25	; 0x04
     9ec:	2d 83       	std	Y+5, r18	; 0x05
     9ee:	3e 83       	std	Y+6, r19	; 0x06
     9f0:	4f 83       	std	Y+7, r20	; 0x07
     9f2:	58 87       	std	Y+8, r21	; 0x08
     9f4:	89 e0       	ldi	r24, 0x09	; 9
     9f6:	e8 2e       	mov	r14, r24
     9f8:	f1 2c       	mov	r15, r1
     9fa:	ec 0e       	add	r14, r28
     9fc:	fd 1e       	adc	r15, r29
     9fe:	ce 01       	movw	r24, r28
     a00:	01 96       	adiw	r24, 0x01	; 1
     a02:	b7 01       	movw	r22, r14
     a04:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     a08:	8e 01       	movw	r16, r28
     a0a:	0f 5e       	subi	r16, 0xEF	; 239
     a0c:	1f 4f       	sbci	r17, 0xFF	; 255
     a0e:	ce 01       	movw	r24, r28
     a10:	05 96       	adiw	r24, 0x05	; 5
     a12:	b8 01       	movw	r22, r16
     a14:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     a18:	89 85       	ldd	r24, Y+9	; 0x09
     a1a:	82 30       	cpi	r24, 0x02	; 2
     a1c:	40 f0       	brcs	.+16     	; 0xa2e <__ltsf2+0x56>
     a1e:	89 89       	ldd	r24, Y+17	; 0x11
     a20:	82 30       	cpi	r24, 0x02	; 2
     a22:	28 f0       	brcs	.+10     	; 0xa2e <__ltsf2+0x56>
     a24:	c7 01       	movw	r24, r14
     a26:	b8 01       	movw	r22, r16
     a28:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <__fpcmp_parts_f>
     a2c:	01 c0       	rjmp	.+2      	; 0xa30 <__ltsf2+0x58>
     a2e:	81 e0       	ldi	r24, 0x01	; 1
     a30:	68 96       	adiw	r28, 0x18	; 24
     a32:	e6 e0       	ldi	r30, 0x06	; 6
     a34:	0c 94 08 40 	jmp	0x8010	; 0x8010 <__epilogue_restores__+0x18>

00000a38 <__floatsisf>:
     a38:	a8 e0       	ldi	r26, 0x08	; 8
     a3a:	b0 e0       	ldi	r27, 0x00	; 0
     a3c:	e2 e2       	ldi	r30, 0x22	; 34
     a3e:	f5 e0       	ldi	r31, 0x05	; 5
     a40:	0c 94 e9 3f 	jmp	0x7fd2	; 0x7fd2 <__prologue_saves__+0x12>
     a44:	9b 01       	movw	r18, r22
     a46:	ac 01       	movw	r20, r24
     a48:	83 e0       	ldi	r24, 0x03	; 3
     a4a:	89 83       	std	Y+1, r24	; 0x01
     a4c:	da 01       	movw	r26, r20
     a4e:	c9 01       	movw	r24, r18
     a50:	88 27       	eor	r24, r24
     a52:	b7 fd       	sbrc	r27, 7
     a54:	83 95       	inc	r24
     a56:	99 27       	eor	r25, r25
     a58:	aa 27       	eor	r26, r26
     a5a:	bb 27       	eor	r27, r27
     a5c:	b8 2e       	mov	r11, r24
     a5e:	21 15       	cp	r18, r1
     a60:	31 05       	cpc	r19, r1
     a62:	41 05       	cpc	r20, r1
     a64:	51 05       	cpc	r21, r1
     a66:	19 f4       	brne	.+6      	; 0xa6e <__floatsisf+0x36>
     a68:	82 e0       	ldi	r24, 0x02	; 2
     a6a:	89 83       	std	Y+1, r24	; 0x01
     a6c:	3a c0       	rjmp	.+116    	; 0xae2 <__floatsisf+0xaa>
     a6e:	88 23       	and	r24, r24
     a70:	a9 f0       	breq	.+42     	; 0xa9c <__floatsisf+0x64>
     a72:	20 30       	cpi	r18, 0x00	; 0
     a74:	80 e0       	ldi	r24, 0x00	; 0
     a76:	38 07       	cpc	r19, r24
     a78:	80 e0       	ldi	r24, 0x00	; 0
     a7a:	48 07       	cpc	r20, r24
     a7c:	80 e8       	ldi	r24, 0x80	; 128
     a7e:	58 07       	cpc	r21, r24
     a80:	29 f4       	brne	.+10     	; 0xa8c <__floatsisf+0x54>
     a82:	60 e0       	ldi	r22, 0x00	; 0
     a84:	70 e0       	ldi	r23, 0x00	; 0
     a86:	80 e0       	ldi	r24, 0x00	; 0
     a88:	9f ec       	ldi	r25, 0xCF	; 207
     a8a:	30 c0       	rjmp	.+96     	; 0xaec <__floatsisf+0xb4>
     a8c:	ee 24       	eor	r14, r14
     a8e:	ff 24       	eor	r15, r15
     a90:	87 01       	movw	r16, r14
     a92:	e2 1a       	sub	r14, r18
     a94:	f3 0a       	sbc	r15, r19
     a96:	04 0b       	sbc	r16, r20
     a98:	15 0b       	sbc	r17, r21
     a9a:	02 c0       	rjmp	.+4      	; 0xaa0 <__floatsisf+0x68>
     a9c:	79 01       	movw	r14, r18
     a9e:	8a 01       	movw	r16, r20
     aa0:	8e e1       	ldi	r24, 0x1E	; 30
     aa2:	c8 2e       	mov	r12, r24
     aa4:	d1 2c       	mov	r13, r1
     aa6:	dc 82       	std	Y+4, r13	; 0x04
     aa8:	cb 82       	std	Y+3, r12	; 0x03
     aaa:	ed 82       	std	Y+5, r14	; 0x05
     aac:	fe 82       	std	Y+6, r15	; 0x06
     aae:	0f 83       	std	Y+7, r16	; 0x07
     ab0:	18 87       	std	Y+8, r17	; 0x08
     ab2:	c8 01       	movw	r24, r16
     ab4:	b7 01       	movw	r22, r14
     ab6:	0e 94 47 06 	call	0xc8e	; 0xc8e <__clzsi2>
     aba:	01 97       	sbiw	r24, 0x01	; 1
     abc:	18 16       	cp	r1, r24
     abe:	19 06       	cpc	r1, r25
     ac0:	84 f4       	brge	.+32     	; 0xae2 <__floatsisf+0xaa>
     ac2:	08 2e       	mov	r0, r24
     ac4:	04 c0       	rjmp	.+8      	; 0xace <__floatsisf+0x96>
     ac6:	ee 0c       	add	r14, r14
     ac8:	ff 1c       	adc	r15, r15
     aca:	00 1f       	adc	r16, r16
     acc:	11 1f       	adc	r17, r17
     ace:	0a 94       	dec	r0
     ad0:	d2 f7       	brpl	.-12     	; 0xac6 <__floatsisf+0x8e>
     ad2:	ed 82       	std	Y+5, r14	; 0x05
     ad4:	fe 82       	std	Y+6, r15	; 0x06
     ad6:	0f 83       	std	Y+7, r16	; 0x07
     ad8:	18 87       	std	Y+8, r17	; 0x08
     ada:	c8 1a       	sub	r12, r24
     adc:	d9 0a       	sbc	r13, r25
     ade:	dc 82       	std	Y+4, r13	; 0x04
     ae0:	cb 82       	std	Y+3, r12	; 0x03
     ae2:	ba 82       	std	Y+2, r11	; 0x02
     ae4:	ce 01       	movw	r24, r28
     ae6:	01 96       	adiw	r24, 0x01	; 1
     ae8:	0e 94 96 06 	call	0xd2c	; 0xd2c <__pack_f>
     aec:	28 96       	adiw	r28, 0x08	; 8
     aee:	e9 e0       	ldi	r30, 0x09	; 9
     af0:	0c 94 05 40 	jmp	0x800a	; 0x800a <__epilogue_restores__+0x12>

00000af4 <__fixsfsi>:
     af4:	ac e0       	ldi	r26, 0x0C	; 12
     af6:	b0 e0       	ldi	r27, 0x00	; 0
     af8:	e0 e8       	ldi	r30, 0x80	; 128
     afa:	f5 e0       	ldi	r31, 0x05	; 5
     afc:	0c 94 f0 3f 	jmp	0x7fe0	; 0x7fe0 <__prologue_saves__+0x20>
     b00:	69 83       	std	Y+1, r22	; 0x01
     b02:	7a 83       	std	Y+2, r23	; 0x02
     b04:	8b 83       	std	Y+3, r24	; 0x03
     b06:	9c 83       	std	Y+4, r25	; 0x04
     b08:	ce 01       	movw	r24, r28
     b0a:	01 96       	adiw	r24, 0x01	; 1
     b0c:	be 01       	movw	r22, r28
     b0e:	6b 5f       	subi	r22, 0xFB	; 251
     b10:	7f 4f       	sbci	r23, 0xFF	; 255
     b12:	0e 94 6b 07 	call	0xed6	; 0xed6 <__unpack_f>
     b16:	8d 81       	ldd	r24, Y+5	; 0x05
     b18:	82 30       	cpi	r24, 0x02	; 2
     b1a:	61 f1       	breq	.+88     	; 0xb74 <__fixsfsi+0x80>
     b1c:	82 30       	cpi	r24, 0x02	; 2
     b1e:	50 f1       	brcs	.+84     	; 0xb74 <__fixsfsi+0x80>
     b20:	84 30       	cpi	r24, 0x04	; 4
     b22:	21 f4       	brne	.+8      	; 0xb2c <__fixsfsi+0x38>
     b24:	8e 81       	ldd	r24, Y+6	; 0x06
     b26:	88 23       	and	r24, r24
     b28:	51 f1       	breq	.+84     	; 0xb7e <__fixsfsi+0x8a>
     b2a:	2e c0       	rjmp	.+92     	; 0xb88 <__fixsfsi+0x94>
     b2c:	2f 81       	ldd	r18, Y+7	; 0x07
     b2e:	38 85       	ldd	r19, Y+8	; 0x08
     b30:	37 fd       	sbrc	r19, 7
     b32:	20 c0       	rjmp	.+64     	; 0xb74 <__fixsfsi+0x80>
     b34:	6e 81       	ldd	r22, Y+6	; 0x06
     b36:	2f 31       	cpi	r18, 0x1F	; 31
     b38:	31 05       	cpc	r19, r1
     b3a:	1c f0       	brlt	.+6      	; 0xb42 <__fixsfsi+0x4e>
     b3c:	66 23       	and	r22, r22
     b3e:	f9 f0       	breq	.+62     	; 0xb7e <__fixsfsi+0x8a>
     b40:	23 c0       	rjmp	.+70     	; 0xb88 <__fixsfsi+0x94>
     b42:	8e e1       	ldi	r24, 0x1E	; 30
     b44:	90 e0       	ldi	r25, 0x00	; 0
     b46:	82 1b       	sub	r24, r18
     b48:	93 0b       	sbc	r25, r19
     b4a:	29 85       	ldd	r18, Y+9	; 0x09
     b4c:	3a 85       	ldd	r19, Y+10	; 0x0a
     b4e:	4b 85       	ldd	r20, Y+11	; 0x0b
     b50:	5c 85       	ldd	r21, Y+12	; 0x0c
     b52:	04 c0       	rjmp	.+8      	; 0xb5c <__fixsfsi+0x68>
     b54:	56 95       	lsr	r21
     b56:	47 95       	ror	r20
     b58:	37 95       	ror	r19
     b5a:	27 95       	ror	r18
     b5c:	8a 95       	dec	r24
     b5e:	d2 f7       	brpl	.-12     	; 0xb54 <__fixsfsi+0x60>
     b60:	66 23       	and	r22, r22
     b62:	b1 f0       	breq	.+44     	; 0xb90 <__fixsfsi+0x9c>
     b64:	50 95       	com	r21
     b66:	40 95       	com	r20
     b68:	30 95       	com	r19
     b6a:	21 95       	neg	r18
     b6c:	3f 4f       	sbci	r19, 0xFF	; 255
     b6e:	4f 4f       	sbci	r20, 0xFF	; 255
     b70:	5f 4f       	sbci	r21, 0xFF	; 255
     b72:	0e c0       	rjmp	.+28     	; 0xb90 <__fixsfsi+0x9c>
     b74:	20 e0       	ldi	r18, 0x00	; 0
     b76:	30 e0       	ldi	r19, 0x00	; 0
     b78:	40 e0       	ldi	r20, 0x00	; 0
     b7a:	50 e0       	ldi	r21, 0x00	; 0
     b7c:	09 c0       	rjmp	.+18     	; 0xb90 <__fixsfsi+0x9c>
     b7e:	2f ef       	ldi	r18, 0xFF	; 255
     b80:	3f ef       	ldi	r19, 0xFF	; 255
     b82:	4f ef       	ldi	r20, 0xFF	; 255
     b84:	5f e7       	ldi	r21, 0x7F	; 127
     b86:	04 c0       	rjmp	.+8      	; 0xb90 <__fixsfsi+0x9c>
     b88:	20 e0       	ldi	r18, 0x00	; 0
     b8a:	30 e0       	ldi	r19, 0x00	; 0
     b8c:	40 e0       	ldi	r20, 0x00	; 0
     b8e:	50 e8       	ldi	r21, 0x80	; 128
     b90:	b9 01       	movw	r22, r18
     b92:	ca 01       	movw	r24, r20
     b94:	2c 96       	adiw	r28, 0x0c	; 12
     b96:	e2 e0       	ldi	r30, 0x02	; 2
     b98:	0c 94 0c 40 	jmp	0x8018	; 0x8018 <__epilogue_restores__+0x20>

00000b9c <__floatunsisf>:
     b9c:	a8 e0       	ldi	r26, 0x08	; 8
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
     ba0:	e4 ed       	ldi	r30, 0xD4	; 212
     ba2:	f5 e0       	ldi	r31, 0x05	; 5
     ba4:	0c 94 e8 3f 	jmp	0x7fd0	; 0x7fd0 <__prologue_saves__+0x10>
     ba8:	7b 01       	movw	r14, r22
     baa:	8c 01       	movw	r16, r24
     bac:	61 15       	cp	r22, r1
     bae:	71 05       	cpc	r23, r1
     bb0:	81 05       	cpc	r24, r1
     bb2:	91 05       	cpc	r25, r1
     bb4:	19 f4       	brne	.+6      	; 0xbbc <__floatunsisf+0x20>
     bb6:	82 e0       	ldi	r24, 0x02	; 2
     bb8:	89 83       	std	Y+1, r24	; 0x01
     bba:	60 c0       	rjmp	.+192    	; 0xc7c <__floatunsisf+0xe0>
     bbc:	83 e0       	ldi	r24, 0x03	; 3
     bbe:	89 83       	std	Y+1, r24	; 0x01
     bc0:	8e e1       	ldi	r24, 0x1E	; 30
     bc2:	c8 2e       	mov	r12, r24
     bc4:	d1 2c       	mov	r13, r1
     bc6:	dc 82       	std	Y+4, r13	; 0x04
     bc8:	cb 82       	std	Y+3, r12	; 0x03
     bca:	ed 82       	std	Y+5, r14	; 0x05
     bcc:	fe 82       	std	Y+6, r15	; 0x06
     bce:	0f 83       	std	Y+7, r16	; 0x07
     bd0:	18 87       	std	Y+8, r17	; 0x08
     bd2:	c8 01       	movw	r24, r16
     bd4:	b7 01       	movw	r22, r14
     bd6:	0e 94 47 06 	call	0xc8e	; 0xc8e <__clzsi2>
     bda:	fc 01       	movw	r30, r24
     bdc:	31 97       	sbiw	r30, 0x01	; 1
     bde:	f7 ff       	sbrs	r31, 7
     be0:	3b c0       	rjmp	.+118    	; 0xc58 <__floatunsisf+0xbc>
     be2:	22 27       	eor	r18, r18
     be4:	33 27       	eor	r19, r19
     be6:	2e 1b       	sub	r18, r30
     be8:	3f 0b       	sbc	r19, r31
     bea:	57 01       	movw	r10, r14
     bec:	68 01       	movw	r12, r16
     bee:	02 2e       	mov	r0, r18
     bf0:	04 c0       	rjmp	.+8      	; 0xbfa <__floatunsisf+0x5e>
     bf2:	d6 94       	lsr	r13
     bf4:	c7 94       	ror	r12
     bf6:	b7 94       	ror	r11
     bf8:	a7 94       	ror	r10
     bfa:	0a 94       	dec	r0
     bfc:	d2 f7       	brpl	.-12     	; 0xbf2 <__floatunsisf+0x56>
     bfe:	40 e0       	ldi	r20, 0x00	; 0
     c00:	50 e0       	ldi	r21, 0x00	; 0
     c02:	60 e0       	ldi	r22, 0x00	; 0
     c04:	70 e0       	ldi	r23, 0x00	; 0
     c06:	81 e0       	ldi	r24, 0x01	; 1
     c08:	90 e0       	ldi	r25, 0x00	; 0
     c0a:	a0 e0       	ldi	r26, 0x00	; 0
     c0c:	b0 e0       	ldi	r27, 0x00	; 0
     c0e:	04 c0       	rjmp	.+8      	; 0xc18 <__floatunsisf+0x7c>
     c10:	88 0f       	add	r24, r24
     c12:	99 1f       	adc	r25, r25
     c14:	aa 1f       	adc	r26, r26
     c16:	bb 1f       	adc	r27, r27
     c18:	2a 95       	dec	r18
     c1a:	d2 f7       	brpl	.-12     	; 0xc10 <__floatunsisf+0x74>
     c1c:	01 97       	sbiw	r24, 0x01	; 1
     c1e:	a1 09       	sbc	r26, r1
     c20:	b1 09       	sbc	r27, r1
     c22:	8e 21       	and	r24, r14
     c24:	9f 21       	and	r25, r15
     c26:	a0 23       	and	r26, r16
     c28:	b1 23       	and	r27, r17
     c2a:	00 97       	sbiw	r24, 0x00	; 0
     c2c:	a1 05       	cpc	r26, r1
     c2e:	b1 05       	cpc	r27, r1
     c30:	21 f0       	breq	.+8      	; 0xc3a <__floatunsisf+0x9e>
     c32:	41 e0       	ldi	r20, 0x01	; 1
     c34:	50 e0       	ldi	r21, 0x00	; 0
     c36:	60 e0       	ldi	r22, 0x00	; 0
     c38:	70 e0       	ldi	r23, 0x00	; 0
     c3a:	4a 29       	or	r20, r10
     c3c:	5b 29       	or	r21, r11
     c3e:	6c 29       	or	r22, r12
     c40:	7d 29       	or	r23, r13
     c42:	4d 83       	std	Y+5, r20	; 0x05
     c44:	5e 83       	std	Y+6, r21	; 0x06
     c46:	6f 83       	std	Y+7, r22	; 0x07
     c48:	78 87       	std	Y+8, r23	; 0x08
     c4a:	8e e1       	ldi	r24, 0x1E	; 30
     c4c:	90 e0       	ldi	r25, 0x00	; 0
     c4e:	8e 1b       	sub	r24, r30
     c50:	9f 0b       	sbc	r25, r31
     c52:	9c 83       	std	Y+4, r25	; 0x04
     c54:	8b 83       	std	Y+3, r24	; 0x03
     c56:	12 c0       	rjmp	.+36     	; 0xc7c <__floatunsisf+0xe0>
     c58:	30 97       	sbiw	r30, 0x00	; 0
     c5a:	81 f0       	breq	.+32     	; 0xc7c <__floatunsisf+0xe0>
     c5c:	0e 2e       	mov	r0, r30
     c5e:	04 c0       	rjmp	.+8      	; 0xc68 <__floatunsisf+0xcc>
     c60:	ee 0c       	add	r14, r14
     c62:	ff 1c       	adc	r15, r15
     c64:	00 1f       	adc	r16, r16
     c66:	11 1f       	adc	r17, r17
     c68:	0a 94       	dec	r0
     c6a:	d2 f7       	brpl	.-12     	; 0xc60 <__floatunsisf+0xc4>
     c6c:	ed 82       	std	Y+5, r14	; 0x05
     c6e:	fe 82       	std	Y+6, r15	; 0x06
     c70:	0f 83       	std	Y+7, r16	; 0x07
     c72:	18 87       	std	Y+8, r17	; 0x08
     c74:	ce 1a       	sub	r12, r30
     c76:	df 0a       	sbc	r13, r31
     c78:	dc 82       	std	Y+4, r13	; 0x04
     c7a:	cb 82       	std	Y+3, r12	; 0x03
     c7c:	1a 82       	std	Y+2, r1	; 0x02
     c7e:	ce 01       	movw	r24, r28
     c80:	01 96       	adiw	r24, 0x01	; 1
     c82:	0e 94 96 06 	call	0xd2c	; 0xd2c <__pack_f>
     c86:	28 96       	adiw	r28, 0x08	; 8
     c88:	ea e0       	ldi	r30, 0x0A	; 10
     c8a:	0c 94 04 40 	jmp	0x8008	; 0x8008 <__epilogue_restores__+0x10>

00000c8e <__clzsi2>:
     c8e:	ef 92       	push	r14
     c90:	ff 92       	push	r15
     c92:	0f 93       	push	r16
     c94:	1f 93       	push	r17
     c96:	7b 01       	movw	r14, r22
     c98:	8c 01       	movw	r16, r24
     c9a:	80 e0       	ldi	r24, 0x00	; 0
     c9c:	e8 16       	cp	r14, r24
     c9e:	80 e0       	ldi	r24, 0x00	; 0
     ca0:	f8 06       	cpc	r15, r24
     ca2:	81 e0       	ldi	r24, 0x01	; 1
     ca4:	08 07       	cpc	r16, r24
     ca6:	80 e0       	ldi	r24, 0x00	; 0
     ca8:	18 07       	cpc	r17, r24
     caa:	88 f4       	brcc	.+34     	; 0xcce <__clzsi2+0x40>
     cac:	8f ef       	ldi	r24, 0xFF	; 255
     cae:	e8 16       	cp	r14, r24
     cb0:	f1 04       	cpc	r15, r1
     cb2:	01 05       	cpc	r16, r1
     cb4:	11 05       	cpc	r17, r1
     cb6:	31 f0       	breq	.+12     	; 0xcc4 <__clzsi2+0x36>
     cb8:	28 f0       	brcs	.+10     	; 0xcc4 <__clzsi2+0x36>
     cba:	88 e0       	ldi	r24, 0x08	; 8
     cbc:	90 e0       	ldi	r25, 0x00	; 0
     cbe:	a0 e0       	ldi	r26, 0x00	; 0
     cc0:	b0 e0       	ldi	r27, 0x00	; 0
     cc2:	17 c0       	rjmp	.+46     	; 0xcf2 <__clzsi2+0x64>
     cc4:	80 e0       	ldi	r24, 0x00	; 0
     cc6:	90 e0       	ldi	r25, 0x00	; 0
     cc8:	a0 e0       	ldi	r26, 0x00	; 0
     cca:	b0 e0       	ldi	r27, 0x00	; 0
     ccc:	12 c0       	rjmp	.+36     	; 0xcf2 <__clzsi2+0x64>
     cce:	80 e0       	ldi	r24, 0x00	; 0
     cd0:	e8 16       	cp	r14, r24
     cd2:	80 e0       	ldi	r24, 0x00	; 0
     cd4:	f8 06       	cpc	r15, r24
     cd6:	80 e0       	ldi	r24, 0x00	; 0
     cd8:	08 07       	cpc	r16, r24
     cda:	81 e0       	ldi	r24, 0x01	; 1
     cdc:	18 07       	cpc	r17, r24
     cde:	28 f0       	brcs	.+10     	; 0xcea <__clzsi2+0x5c>
     ce0:	88 e1       	ldi	r24, 0x18	; 24
     ce2:	90 e0       	ldi	r25, 0x00	; 0
     ce4:	a0 e0       	ldi	r26, 0x00	; 0
     ce6:	b0 e0       	ldi	r27, 0x00	; 0
     ce8:	04 c0       	rjmp	.+8      	; 0xcf2 <__clzsi2+0x64>
     cea:	80 e1       	ldi	r24, 0x10	; 16
     cec:	90 e0       	ldi	r25, 0x00	; 0
     cee:	a0 e0       	ldi	r26, 0x00	; 0
     cf0:	b0 e0       	ldi	r27, 0x00	; 0
     cf2:	20 e2       	ldi	r18, 0x20	; 32
     cf4:	30 e0       	ldi	r19, 0x00	; 0
     cf6:	40 e0       	ldi	r20, 0x00	; 0
     cf8:	50 e0       	ldi	r21, 0x00	; 0
     cfa:	28 1b       	sub	r18, r24
     cfc:	39 0b       	sbc	r19, r25
     cfe:	4a 0b       	sbc	r20, r26
     d00:	5b 0b       	sbc	r21, r27
     d02:	04 c0       	rjmp	.+8      	; 0xd0c <__clzsi2+0x7e>
     d04:	16 95       	lsr	r17
     d06:	07 95       	ror	r16
     d08:	f7 94       	ror	r15
     d0a:	e7 94       	ror	r14
     d0c:	8a 95       	dec	r24
     d0e:	d2 f7       	brpl	.-12     	; 0xd04 <__clzsi2+0x76>
     d10:	f7 01       	movw	r30, r14
     d12:	e6 5b       	subi	r30, 0xB6	; 182
     d14:	fd 4f       	sbci	r31, 0xFD	; 253
     d16:	80 81       	ld	r24, Z
     d18:	28 1b       	sub	r18, r24
     d1a:	31 09       	sbc	r19, r1
     d1c:	41 09       	sbc	r20, r1
     d1e:	51 09       	sbc	r21, r1
     d20:	c9 01       	movw	r24, r18
     d22:	1f 91       	pop	r17
     d24:	0f 91       	pop	r16
     d26:	ff 90       	pop	r15
     d28:	ef 90       	pop	r14
     d2a:	08 95       	ret

00000d2c <__pack_f>:
     d2c:	df 92       	push	r13
     d2e:	ef 92       	push	r14
     d30:	ff 92       	push	r15
     d32:	0f 93       	push	r16
     d34:	1f 93       	push	r17
     d36:	fc 01       	movw	r30, r24
     d38:	e4 80       	ldd	r14, Z+4	; 0x04
     d3a:	f5 80       	ldd	r15, Z+5	; 0x05
     d3c:	06 81       	ldd	r16, Z+6	; 0x06
     d3e:	17 81       	ldd	r17, Z+7	; 0x07
     d40:	d1 80       	ldd	r13, Z+1	; 0x01
     d42:	80 81       	ld	r24, Z
     d44:	82 30       	cpi	r24, 0x02	; 2
     d46:	48 f4       	brcc	.+18     	; 0xd5a <__pack_f+0x2e>
     d48:	80 e0       	ldi	r24, 0x00	; 0
     d4a:	90 e0       	ldi	r25, 0x00	; 0
     d4c:	a0 e1       	ldi	r26, 0x10	; 16
     d4e:	b0 e0       	ldi	r27, 0x00	; 0
     d50:	e8 2a       	or	r14, r24
     d52:	f9 2a       	or	r15, r25
     d54:	0a 2b       	or	r16, r26
     d56:	1b 2b       	or	r17, r27
     d58:	a5 c0       	rjmp	.+330    	; 0xea4 <__pack_f+0x178>
     d5a:	84 30       	cpi	r24, 0x04	; 4
     d5c:	09 f4       	brne	.+2      	; 0xd60 <__pack_f+0x34>
     d5e:	9f c0       	rjmp	.+318    	; 0xe9e <__pack_f+0x172>
     d60:	82 30       	cpi	r24, 0x02	; 2
     d62:	21 f4       	brne	.+8      	; 0xd6c <__pack_f+0x40>
     d64:	ee 24       	eor	r14, r14
     d66:	ff 24       	eor	r15, r15
     d68:	87 01       	movw	r16, r14
     d6a:	05 c0       	rjmp	.+10     	; 0xd76 <__pack_f+0x4a>
     d6c:	e1 14       	cp	r14, r1
     d6e:	f1 04       	cpc	r15, r1
     d70:	01 05       	cpc	r16, r1
     d72:	11 05       	cpc	r17, r1
     d74:	19 f4       	brne	.+6      	; 0xd7c <__pack_f+0x50>
     d76:	e0 e0       	ldi	r30, 0x00	; 0
     d78:	f0 e0       	ldi	r31, 0x00	; 0
     d7a:	96 c0       	rjmp	.+300    	; 0xea8 <__pack_f+0x17c>
     d7c:	62 81       	ldd	r22, Z+2	; 0x02
     d7e:	73 81       	ldd	r23, Z+3	; 0x03
     d80:	9f ef       	ldi	r25, 0xFF	; 255
     d82:	62 38       	cpi	r22, 0x82	; 130
     d84:	79 07       	cpc	r23, r25
     d86:	0c f0       	brlt	.+2      	; 0xd8a <__pack_f+0x5e>
     d88:	5b c0       	rjmp	.+182    	; 0xe40 <__pack_f+0x114>
     d8a:	22 e8       	ldi	r18, 0x82	; 130
     d8c:	3f ef       	ldi	r19, 0xFF	; 255
     d8e:	26 1b       	sub	r18, r22
     d90:	37 0b       	sbc	r19, r23
     d92:	2a 31       	cpi	r18, 0x1A	; 26
     d94:	31 05       	cpc	r19, r1
     d96:	2c f0       	brlt	.+10     	; 0xda2 <__pack_f+0x76>
     d98:	20 e0       	ldi	r18, 0x00	; 0
     d9a:	30 e0       	ldi	r19, 0x00	; 0
     d9c:	40 e0       	ldi	r20, 0x00	; 0
     d9e:	50 e0       	ldi	r21, 0x00	; 0
     da0:	2a c0       	rjmp	.+84     	; 0xdf6 <__pack_f+0xca>
     da2:	b8 01       	movw	r22, r16
     da4:	a7 01       	movw	r20, r14
     da6:	02 2e       	mov	r0, r18
     da8:	04 c0       	rjmp	.+8      	; 0xdb2 <__pack_f+0x86>
     daa:	76 95       	lsr	r23
     dac:	67 95       	ror	r22
     dae:	57 95       	ror	r21
     db0:	47 95       	ror	r20
     db2:	0a 94       	dec	r0
     db4:	d2 f7       	brpl	.-12     	; 0xdaa <__pack_f+0x7e>
     db6:	81 e0       	ldi	r24, 0x01	; 1
     db8:	90 e0       	ldi	r25, 0x00	; 0
     dba:	a0 e0       	ldi	r26, 0x00	; 0
     dbc:	b0 e0       	ldi	r27, 0x00	; 0
     dbe:	04 c0       	rjmp	.+8      	; 0xdc8 <__pack_f+0x9c>
     dc0:	88 0f       	add	r24, r24
     dc2:	99 1f       	adc	r25, r25
     dc4:	aa 1f       	adc	r26, r26
     dc6:	bb 1f       	adc	r27, r27
     dc8:	2a 95       	dec	r18
     dca:	d2 f7       	brpl	.-12     	; 0xdc0 <__pack_f+0x94>
     dcc:	01 97       	sbiw	r24, 0x01	; 1
     dce:	a1 09       	sbc	r26, r1
     dd0:	b1 09       	sbc	r27, r1
     dd2:	8e 21       	and	r24, r14
     dd4:	9f 21       	and	r25, r15
     dd6:	a0 23       	and	r26, r16
     dd8:	b1 23       	and	r27, r17
     dda:	00 97       	sbiw	r24, 0x00	; 0
     ddc:	a1 05       	cpc	r26, r1
     dde:	b1 05       	cpc	r27, r1
     de0:	21 f0       	breq	.+8      	; 0xdea <__pack_f+0xbe>
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	90 e0       	ldi	r25, 0x00	; 0
     de6:	a0 e0       	ldi	r26, 0x00	; 0
     de8:	b0 e0       	ldi	r27, 0x00	; 0
     dea:	9a 01       	movw	r18, r20
     dec:	ab 01       	movw	r20, r22
     dee:	28 2b       	or	r18, r24
     df0:	39 2b       	or	r19, r25
     df2:	4a 2b       	or	r20, r26
     df4:	5b 2b       	or	r21, r27
     df6:	da 01       	movw	r26, r20
     df8:	c9 01       	movw	r24, r18
     dfa:	8f 77       	andi	r24, 0x7F	; 127
     dfc:	90 70       	andi	r25, 0x00	; 0
     dfe:	a0 70       	andi	r26, 0x00	; 0
     e00:	b0 70       	andi	r27, 0x00	; 0
     e02:	80 34       	cpi	r24, 0x40	; 64
     e04:	91 05       	cpc	r25, r1
     e06:	a1 05       	cpc	r26, r1
     e08:	b1 05       	cpc	r27, r1
     e0a:	39 f4       	brne	.+14     	; 0xe1a <__pack_f+0xee>
     e0c:	27 ff       	sbrs	r18, 7
     e0e:	09 c0       	rjmp	.+18     	; 0xe22 <__pack_f+0xf6>
     e10:	20 5c       	subi	r18, 0xC0	; 192
     e12:	3f 4f       	sbci	r19, 0xFF	; 255
     e14:	4f 4f       	sbci	r20, 0xFF	; 255
     e16:	5f 4f       	sbci	r21, 0xFF	; 255
     e18:	04 c0       	rjmp	.+8      	; 0xe22 <__pack_f+0xf6>
     e1a:	21 5c       	subi	r18, 0xC1	; 193
     e1c:	3f 4f       	sbci	r19, 0xFF	; 255
     e1e:	4f 4f       	sbci	r20, 0xFF	; 255
     e20:	5f 4f       	sbci	r21, 0xFF	; 255
     e22:	e0 e0       	ldi	r30, 0x00	; 0
     e24:	f0 e0       	ldi	r31, 0x00	; 0
     e26:	20 30       	cpi	r18, 0x00	; 0
     e28:	a0 e0       	ldi	r26, 0x00	; 0
     e2a:	3a 07       	cpc	r19, r26
     e2c:	a0 e0       	ldi	r26, 0x00	; 0
     e2e:	4a 07       	cpc	r20, r26
     e30:	a0 e4       	ldi	r26, 0x40	; 64
     e32:	5a 07       	cpc	r21, r26
     e34:	10 f0       	brcs	.+4      	; 0xe3a <__pack_f+0x10e>
     e36:	e1 e0       	ldi	r30, 0x01	; 1
     e38:	f0 e0       	ldi	r31, 0x00	; 0
     e3a:	79 01       	movw	r14, r18
     e3c:	8a 01       	movw	r16, r20
     e3e:	27 c0       	rjmp	.+78     	; 0xe8e <__pack_f+0x162>
     e40:	60 38       	cpi	r22, 0x80	; 128
     e42:	71 05       	cpc	r23, r1
     e44:	64 f5       	brge	.+88     	; 0xe9e <__pack_f+0x172>
     e46:	fb 01       	movw	r30, r22
     e48:	e1 58       	subi	r30, 0x81	; 129
     e4a:	ff 4f       	sbci	r31, 0xFF	; 255
     e4c:	d8 01       	movw	r26, r16
     e4e:	c7 01       	movw	r24, r14
     e50:	8f 77       	andi	r24, 0x7F	; 127
     e52:	90 70       	andi	r25, 0x00	; 0
     e54:	a0 70       	andi	r26, 0x00	; 0
     e56:	b0 70       	andi	r27, 0x00	; 0
     e58:	80 34       	cpi	r24, 0x40	; 64
     e5a:	91 05       	cpc	r25, r1
     e5c:	a1 05       	cpc	r26, r1
     e5e:	b1 05       	cpc	r27, r1
     e60:	39 f4       	brne	.+14     	; 0xe70 <__pack_f+0x144>
     e62:	e7 fe       	sbrs	r14, 7
     e64:	0d c0       	rjmp	.+26     	; 0xe80 <__pack_f+0x154>
     e66:	80 e4       	ldi	r24, 0x40	; 64
     e68:	90 e0       	ldi	r25, 0x00	; 0
     e6a:	a0 e0       	ldi	r26, 0x00	; 0
     e6c:	b0 e0       	ldi	r27, 0x00	; 0
     e6e:	04 c0       	rjmp	.+8      	; 0xe78 <__pack_f+0x14c>
     e70:	8f e3       	ldi	r24, 0x3F	; 63
     e72:	90 e0       	ldi	r25, 0x00	; 0
     e74:	a0 e0       	ldi	r26, 0x00	; 0
     e76:	b0 e0       	ldi	r27, 0x00	; 0
     e78:	e8 0e       	add	r14, r24
     e7a:	f9 1e       	adc	r15, r25
     e7c:	0a 1f       	adc	r16, r26
     e7e:	1b 1f       	adc	r17, r27
     e80:	17 ff       	sbrs	r17, 7
     e82:	05 c0       	rjmp	.+10     	; 0xe8e <__pack_f+0x162>
     e84:	16 95       	lsr	r17
     e86:	07 95       	ror	r16
     e88:	f7 94       	ror	r15
     e8a:	e7 94       	ror	r14
     e8c:	31 96       	adiw	r30, 0x01	; 1
     e8e:	87 e0       	ldi	r24, 0x07	; 7
     e90:	16 95       	lsr	r17
     e92:	07 95       	ror	r16
     e94:	f7 94       	ror	r15
     e96:	e7 94       	ror	r14
     e98:	8a 95       	dec	r24
     e9a:	d1 f7       	brne	.-12     	; 0xe90 <__pack_f+0x164>
     e9c:	05 c0       	rjmp	.+10     	; 0xea8 <__pack_f+0x17c>
     e9e:	ee 24       	eor	r14, r14
     ea0:	ff 24       	eor	r15, r15
     ea2:	87 01       	movw	r16, r14
     ea4:	ef ef       	ldi	r30, 0xFF	; 255
     ea6:	f0 e0       	ldi	r31, 0x00	; 0
     ea8:	6e 2f       	mov	r22, r30
     eaa:	67 95       	ror	r22
     eac:	66 27       	eor	r22, r22
     eae:	67 95       	ror	r22
     eb0:	90 2f       	mov	r25, r16
     eb2:	9f 77       	andi	r25, 0x7F	; 127
     eb4:	d7 94       	ror	r13
     eb6:	dd 24       	eor	r13, r13
     eb8:	d7 94       	ror	r13
     eba:	8e 2f       	mov	r24, r30
     ebc:	86 95       	lsr	r24
     ebe:	49 2f       	mov	r20, r25
     ec0:	46 2b       	or	r20, r22
     ec2:	58 2f       	mov	r21, r24
     ec4:	5d 29       	or	r21, r13
     ec6:	b7 01       	movw	r22, r14
     ec8:	ca 01       	movw	r24, r20
     eca:	1f 91       	pop	r17
     ecc:	0f 91       	pop	r16
     ece:	ff 90       	pop	r15
     ed0:	ef 90       	pop	r14
     ed2:	df 90       	pop	r13
     ed4:	08 95       	ret

00000ed6 <__unpack_f>:
     ed6:	fc 01       	movw	r30, r24
     ed8:	db 01       	movw	r26, r22
     eda:	40 81       	ld	r20, Z
     edc:	51 81       	ldd	r21, Z+1	; 0x01
     ede:	22 81       	ldd	r18, Z+2	; 0x02
     ee0:	62 2f       	mov	r22, r18
     ee2:	6f 77       	andi	r22, 0x7F	; 127
     ee4:	70 e0       	ldi	r23, 0x00	; 0
     ee6:	22 1f       	adc	r18, r18
     ee8:	22 27       	eor	r18, r18
     eea:	22 1f       	adc	r18, r18
     eec:	93 81       	ldd	r25, Z+3	; 0x03
     eee:	89 2f       	mov	r24, r25
     ef0:	88 0f       	add	r24, r24
     ef2:	82 2b       	or	r24, r18
     ef4:	28 2f       	mov	r18, r24
     ef6:	30 e0       	ldi	r19, 0x00	; 0
     ef8:	99 1f       	adc	r25, r25
     efa:	99 27       	eor	r25, r25
     efc:	99 1f       	adc	r25, r25
     efe:	11 96       	adiw	r26, 0x01	; 1
     f00:	9c 93       	st	X, r25
     f02:	11 97       	sbiw	r26, 0x01	; 1
     f04:	21 15       	cp	r18, r1
     f06:	31 05       	cpc	r19, r1
     f08:	a9 f5       	brne	.+106    	; 0xf74 <__unpack_f+0x9e>
     f0a:	41 15       	cp	r20, r1
     f0c:	51 05       	cpc	r21, r1
     f0e:	61 05       	cpc	r22, r1
     f10:	71 05       	cpc	r23, r1
     f12:	11 f4       	brne	.+4      	; 0xf18 <__unpack_f+0x42>
     f14:	82 e0       	ldi	r24, 0x02	; 2
     f16:	37 c0       	rjmp	.+110    	; 0xf86 <__unpack_f+0xb0>
     f18:	82 e8       	ldi	r24, 0x82	; 130
     f1a:	9f ef       	ldi	r25, 0xFF	; 255
     f1c:	13 96       	adiw	r26, 0x03	; 3
     f1e:	9c 93       	st	X, r25
     f20:	8e 93       	st	-X, r24
     f22:	12 97       	sbiw	r26, 0x02	; 2
     f24:	9a 01       	movw	r18, r20
     f26:	ab 01       	movw	r20, r22
     f28:	67 e0       	ldi	r22, 0x07	; 7
     f2a:	22 0f       	add	r18, r18
     f2c:	33 1f       	adc	r19, r19
     f2e:	44 1f       	adc	r20, r20
     f30:	55 1f       	adc	r21, r21
     f32:	6a 95       	dec	r22
     f34:	d1 f7       	brne	.-12     	; 0xf2a <__unpack_f+0x54>
     f36:	83 e0       	ldi	r24, 0x03	; 3
     f38:	8c 93       	st	X, r24
     f3a:	0d c0       	rjmp	.+26     	; 0xf56 <__unpack_f+0x80>
     f3c:	22 0f       	add	r18, r18
     f3e:	33 1f       	adc	r19, r19
     f40:	44 1f       	adc	r20, r20
     f42:	55 1f       	adc	r21, r21
     f44:	12 96       	adiw	r26, 0x02	; 2
     f46:	8d 91       	ld	r24, X+
     f48:	9c 91       	ld	r25, X
     f4a:	13 97       	sbiw	r26, 0x03	; 3
     f4c:	01 97       	sbiw	r24, 0x01	; 1
     f4e:	13 96       	adiw	r26, 0x03	; 3
     f50:	9c 93       	st	X, r25
     f52:	8e 93       	st	-X, r24
     f54:	12 97       	sbiw	r26, 0x02	; 2
     f56:	20 30       	cpi	r18, 0x00	; 0
     f58:	80 e0       	ldi	r24, 0x00	; 0
     f5a:	38 07       	cpc	r19, r24
     f5c:	80 e0       	ldi	r24, 0x00	; 0
     f5e:	48 07       	cpc	r20, r24
     f60:	80 e4       	ldi	r24, 0x40	; 64
     f62:	58 07       	cpc	r21, r24
     f64:	58 f3       	brcs	.-42     	; 0xf3c <__unpack_f+0x66>
     f66:	14 96       	adiw	r26, 0x04	; 4
     f68:	2d 93       	st	X+, r18
     f6a:	3d 93       	st	X+, r19
     f6c:	4d 93       	st	X+, r20
     f6e:	5c 93       	st	X, r21
     f70:	17 97       	sbiw	r26, 0x07	; 7
     f72:	08 95       	ret
     f74:	2f 3f       	cpi	r18, 0xFF	; 255
     f76:	31 05       	cpc	r19, r1
     f78:	79 f4       	brne	.+30     	; 0xf98 <__unpack_f+0xc2>
     f7a:	41 15       	cp	r20, r1
     f7c:	51 05       	cpc	r21, r1
     f7e:	61 05       	cpc	r22, r1
     f80:	71 05       	cpc	r23, r1
     f82:	19 f4       	brne	.+6      	; 0xf8a <__unpack_f+0xb4>
     f84:	84 e0       	ldi	r24, 0x04	; 4
     f86:	8c 93       	st	X, r24
     f88:	08 95       	ret
     f8a:	64 ff       	sbrs	r22, 4
     f8c:	03 c0       	rjmp	.+6      	; 0xf94 <__unpack_f+0xbe>
     f8e:	81 e0       	ldi	r24, 0x01	; 1
     f90:	8c 93       	st	X, r24
     f92:	12 c0       	rjmp	.+36     	; 0xfb8 <__unpack_f+0xe2>
     f94:	1c 92       	st	X, r1
     f96:	10 c0       	rjmp	.+32     	; 0xfb8 <__unpack_f+0xe2>
     f98:	2f 57       	subi	r18, 0x7F	; 127
     f9a:	30 40       	sbci	r19, 0x00	; 0
     f9c:	13 96       	adiw	r26, 0x03	; 3
     f9e:	3c 93       	st	X, r19
     fa0:	2e 93       	st	-X, r18
     fa2:	12 97       	sbiw	r26, 0x02	; 2
     fa4:	83 e0       	ldi	r24, 0x03	; 3
     fa6:	8c 93       	st	X, r24
     fa8:	87 e0       	ldi	r24, 0x07	; 7
     faa:	44 0f       	add	r20, r20
     fac:	55 1f       	adc	r21, r21
     fae:	66 1f       	adc	r22, r22
     fb0:	77 1f       	adc	r23, r23
     fb2:	8a 95       	dec	r24
     fb4:	d1 f7       	brne	.-12     	; 0xfaa <__unpack_f+0xd4>
     fb6:	70 64       	ori	r23, 0x40	; 64
     fb8:	14 96       	adiw	r26, 0x04	; 4
     fba:	4d 93       	st	X+, r20
     fbc:	5d 93       	st	X+, r21
     fbe:	6d 93       	st	X+, r22
     fc0:	7c 93       	st	X, r23
     fc2:	17 97       	sbiw	r26, 0x07	; 7
     fc4:	08 95       	ret

00000fc6 <__fpcmp_parts_f>:
     fc6:	1f 93       	push	r17
     fc8:	dc 01       	movw	r26, r24
     fca:	fb 01       	movw	r30, r22
     fcc:	9c 91       	ld	r25, X
     fce:	92 30       	cpi	r25, 0x02	; 2
     fd0:	08 f4       	brcc	.+2      	; 0xfd4 <__fpcmp_parts_f+0xe>
     fd2:	47 c0       	rjmp	.+142    	; 0x1062 <__fpcmp_parts_f+0x9c>
     fd4:	80 81       	ld	r24, Z
     fd6:	82 30       	cpi	r24, 0x02	; 2
     fd8:	08 f4       	brcc	.+2      	; 0xfdc <__fpcmp_parts_f+0x16>
     fda:	43 c0       	rjmp	.+134    	; 0x1062 <__fpcmp_parts_f+0x9c>
     fdc:	94 30       	cpi	r25, 0x04	; 4
     fde:	51 f4       	brne	.+20     	; 0xff4 <__fpcmp_parts_f+0x2e>
     fe0:	11 96       	adiw	r26, 0x01	; 1
     fe2:	1c 91       	ld	r17, X
     fe4:	84 30       	cpi	r24, 0x04	; 4
     fe6:	99 f5       	brne	.+102    	; 0x104e <__fpcmp_parts_f+0x88>
     fe8:	81 81       	ldd	r24, Z+1	; 0x01
     fea:	68 2f       	mov	r22, r24
     fec:	70 e0       	ldi	r23, 0x00	; 0
     fee:	61 1b       	sub	r22, r17
     ff0:	71 09       	sbc	r23, r1
     ff2:	3f c0       	rjmp	.+126    	; 0x1072 <__fpcmp_parts_f+0xac>
     ff4:	84 30       	cpi	r24, 0x04	; 4
     ff6:	21 f0       	breq	.+8      	; 0x1000 <__fpcmp_parts_f+0x3a>
     ff8:	92 30       	cpi	r25, 0x02	; 2
     ffa:	31 f4       	brne	.+12     	; 0x1008 <__fpcmp_parts_f+0x42>
     ffc:	82 30       	cpi	r24, 0x02	; 2
     ffe:	b9 f1       	breq	.+110    	; 0x106e <__fpcmp_parts_f+0xa8>
    1000:	81 81       	ldd	r24, Z+1	; 0x01
    1002:	88 23       	and	r24, r24
    1004:	89 f1       	breq	.+98     	; 0x1068 <__fpcmp_parts_f+0xa2>
    1006:	2d c0       	rjmp	.+90     	; 0x1062 <__fpcmp_parts_f+0x9c>
    1008:	11 96       	adiw	r26, 0x01	; 1
    100a:	1c 91       	ld	r17, X
    100c:	11 97       	sbiw	r26, 0x01	; 1
    100e:	82 30       	cpi	r24, 0x02	; 2
    1010:	f1 f0       	breq	.+60     	; 0x104e <__fpcmp_parts_f+0x88>
    1012:	81 81       	ldd	r24, Z+1	; 0x01
    1014:	18 17       	cp	r17, r24
    1016:	d9 f4       	brne	.+54     	; 0x104e <__fpcmp_parts_f+0x88>
    1018:	12 96       	adiw	r26, 0x02	; 2
    101a:	2d 91       	ld	r18, X+
    101c:	3c 91       	ld	r19, X
    101e:	13 97       	sbiw	r26, 0x03	; 3
    1020:	82 81       	ldd	r24, Z+2	; 0x02
    1022:	93 81       	ldd	r25, Z+3	; 0x03
    1024:	82 17       	cp	r24, r18
    1026:	93 07       	cpc	r25, r19
    1028:	94 f0       	brlt	.+36     	; 0x104e <__fpcmp_parts_f+0x88>
    102a:	28 17       	cp	r18, r24
    102c:	39 07       	cpc	r19, r25
    102e:	bc f0       	brlt	.+46     	; 0x105e <__fpcmp_parts_f+0x98>
    1030:	14 96       	adiw	r26, 0x04	; 4
    1032:	8d 91       	ld	r24, X+
    1034:	9d 91       	ld	r25, X+
    1036:	0d 90       	ld	r0, X+
    1038:	bc 91       	ld	r27, X
    103a:	a0 2d       	mov	r26, r0
    103c:	24 81       	ldd	r18, Z+4	; 0x04
    103e:	35 81       	ldd	r19, Z+5	; 0x05
    1040:	46 81       	ldd	r20, Z+6	; 0x06
    1042:	57 81       	ldd	r21, Z+7	; 0x07
    1044:	28 17       	cp	r18, r24
    1046:	39 07       	cpc	r19, r25
    1048:	4a 07       	cpc	r20, r26
    104a:	5b 07       	cpc	r21, r27
    104c:	18 f4       	brcc	.+6      	; 0x1054 <__fpcmp_parts_f+0x8e>
    104e:	11 23       	and	r17, r17
    1050:	41 f0       	breq	.+16     	; 0x1062 <__fpcmp_parts_f+0x9c>
    1052:	0a c0       	rjmp	.+20     	; 0x1068 <__fpcmp_parts_f+0xa2>
    1054:	82 17       	cp	r24, r18
    1056:	93 07       	cpc	r25, r19
    1058:	a4 07       	cpc	r26, r20
    105a:	b5 07       	cpc	r27, r21
    105c:	40 f4       	brcc	.+16     	; 0x106e <__fpcmp_parts_f+0xa8>
    105e:	11 23       	and	r17, r17
    1060:	19 f0       	breq	.+6      	; 0x1068 <__fpcmp_parts_f+0xa2>
    1062:	61 e0       	ldi	r22, 0x01	; 1
    1064:	70 e0       	ldi	r23, 0x00	; 0
    1066:	05 c0       	rjmp	.+10     	; 0x1072 <__fpcmp_parts_f+0xac>
    1068:	6f ef       	ldi	r22, 0xFF	; 255
    106a:	7f ef       	ldi	r23, 0xFF	; 255
    106c:	02 c0       	rjmp	.+4      	; 0x1072 <__fpcmp_parts_f+0xac>
    106e:	60 e0       	ldi	r22, 0x00	; 0
    1070:	70 e0       	ldi	r23, 0x00	; 0
    1072:	cb 01       	movw	r24, r22
    1074:	1f 91       	pop	r17
    1076:	08 95       	ret

00001078 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1078:	df 93       	push	r29
    107a:	cf 93       	push	r28
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
    1080:	28 97       	sbiw	r28, 0x08	; 8
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	f8 94       	cli
    1086:	de bf       	out	0x3e, r29	; 62
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	cd bf       	out	0x3d, r28	; 61
    108c:	9c 83       	std	Y+4, r25	; 0x04
    108e:	8b 83       	std	Y+3, r24	; 0x03
    1090:	7e 83       	std	Y+6, r23	; 0x06
    1092:	6d 83       	std	Y+5, r22	; 0x05
    1094:	58 87       	std	Y+8, r21	; 0x08
    1096:	4f 83       	std	Y+7, r20	; 0x07
    /* Simulate how the stack would look after a call to vPortYield() generated by
    the compiler. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    usAddress = ( uint16_t ) pxCode;
    1098:	8d 81       	ldd	r24, Y+5	; 0x05
    109a:	9e 81       	ldd	r25, Y+6	; 0x06
    109c:	9a 83       	std	Y+2, r25	; 0x02
    109e:	89 83       	std	Y+1, r24	; 0x01
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    10a0:	89 81       	ldd	r24, Y+1	; 0x01
    10a2:	eb 81       	ldd	r30, Y+3	; 0x03
    10a4:	fc 81       	ldd	r31, Y+4	; 0x04
    10a6:	80 83       	st	Z, r24
    pxTopOfStack--;
    10a8:	8b 81       	ldd	r24, Y+3	; 0x03
    10aa:	9c 81       	ldd	r25, Y+4	; 0x04
    10ac:	01 97       	sbiw	r24, 0x01	; 1
    10ae:	9c 83       	std	Y+4, r25	; 0x04
    10b0:	8b 83       	std	Y+3, r24	; 0x03

    usAddress >>= 8;
    10b2:	89 81       	ldd	r24, Y+1	; 0x01
    10b4:	9a 81       	ldd	r25, Y+2	; 0x02
    10b6:	89 2f       	mov	r24, r25
    10b8:	99 27       	eor	r25, r25
    10ba:	9a 83       	std	Y+2, r25	; 0x02
    10bc:	89 83       	std	Y+1, r24	; 0x01
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    10be:	89 81       	ldd	r24, Y+1	; 0x01
    10c0:	eb 81       	ldd	r30, Y+3	; 0x03
    10c2:	fc 81       	ldd	r31, Y+4	; 0x04
    10c4:	80 83       	st	Z, r24
    pxTopOfStack--;
    10c6:	8b 81       	ldd	r24, Y+3	; 0x03
    10c8:	9c 81       	ldd	r25, Y+4	; 0x04
    10ca:	01 97       	sbiw	r24, 0x01	; 1
    10cc:	9c 83       	std	Y+4, r25	; 0x04
    10ce:	8b 83       	std	Y+3, r24	; 0x03

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;    /* R0 */
    10d0:	eb 81       	ldd	r30, Y+3	; 0x03
    10d2:	fc 81       	ldd	r31, Y+4	; 0x04
    10d4:	10 82       	st	Z, r1
    pxTopOfStack--;
    10d6:	8b 81       	ldd	r24, Y+3	; 0x03
    10d8:	9c 81       	ldd	r25, Y+4	; 0x04
    10da:	01 97       	sbiw	r24, 0x01	; 1
    10dc:	9c 83       	std	Y+4, r25	; 0x04
    10de:	8b 83       	std	Y+3, r24	; 0x03
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    10e0:	eb 81       	ldd	r30, Y+3	; 0x03
    10e2:	fc 81       	ldd	r31, Y+4	; 0x04
    10e4:	80 e8       	ldi	r24, 0x80	; 128
    10e6:	80 83       	st	Z, r24
    pxTopOfStack--;
    10e8:	8b 81       	ldd	r24, Y+3	; 0x03
    10ea:	9c 81       	ldd	r25, Y+4	; 0x04
    10ec:	01 97       	sbiw	r24, 0x01	; 1
    10ee:	9c 83       	std	Y+4, r25	; 0x04
    10f0:	8b 83       	std	Y+3, r24	; 0x03
    *pxTopOfStack = ( StackType_t ) 0x00;    /* RAMPZ */
    pxTopOfStack--;
#endif

    /* Now the remaining registers. The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;    /* R1 */
    10f2:	eb 81       	ldd	r30, Y+3	; 0x03
    10f4:	fc 81       	ldd	r31, Y+4	; 0x04
    10f6:	10 82       	st	Z, r1

    /* Leave R2 - R23 untouched */
    pxTopOfStack -= 23;
    10f8:	8b 81       	ldd	r24, Y+3	; 0x03
    10fa:	9c 81       	ldd	r25, Y+4	; 0x04
    10fc:	47 97       	sbiw	r24, 0x17	; 23
    10fe:	9c 83       	std	Y+4, r25	; 0x04
    1100:	8b 83       	std	Y+3, r24	; 0x03

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    1102:	8f 81       	ldd	r24, Y+7	; 0x07
    1104:	98 85       	ldd	r25, Y+8	; 0x08
    1106:	9a 83       	std	Y+2, r25	; 0x02
    1108:	89 83       	std	Y+1, r24	; 0x01
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    110a:	89 81       	ldd	r24, Y+1	; 0x01
    110c:	eb 81       	ldd	r30, Y+3	; 0x03
    110e:	fc 81       	ldd	r31, Y+4	; 0x04
    1110:	80 83       	st	Z, r24
    pxTopOfStack--;
    1112:	8b 81       	ldd	r24, Y+3	; 0x03
    1114:	9c 81       	ldd	r25, Y+4	; 0x04
    1116:	01 97       	sbiw	r24, 0x01	; 1
    1118:	9c 83       	std	Y+4, r25	; 0x04
    111a:	8b 83       	std	Y+3, r24	; 0x03

    usAddress >>= 8;
    111c:	89 81       	ldd	r24, Y+1	; 0x01
    111e:	9a 81       	ldd	r25, Y+2	; 0x02
    1120:	89 2f       	mov	r24, r25
    1122:	99 27       	eor	r25, r25
    1124:	9a 83       	std	Y+2, r25	; 0x02
    1126:	89 83       	std	Y+1, r24	; 0x01
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1128:	89 81       	ldd	r24, Y+1	; 0x01
    112a:	eb 81       	ldd	r30, Y+3	; 0x03
    112c:	fc 81       	ldd	r31, Y+4	; 0x04
    112e:	80 83       	st	Z, r24

    /* Leave register R26 - R31 untouched */
    pxTopOfStack -= 7;
    1130:	8b 81       	ldd	r24, Y+3	; 0x03
    1132:	9c 81       	ldd	r25, Y+4	; 0x04
    1134:	07 97       	sbiw	r24, 0x07	; 7
    1136:	9c 83       	std	Y+4, r25	; 0x04
    1138:	8b 83       	std	Y+3, r24	; 0x03

    return pxTopOfStack;
    113a:	8b 81       	ldd	r24, Y+3	; 0x03
    113c:	9c 81       	ldd	r25, Y+4	; 0x04
}
    113e:	28 96       	adiw	r28, 0x08	; 8
    1140:	0f b6       	in	r0, 0x3f	; 63
    1142:	f8 94       	cli
    1144:	de bf       	out	0x3e, r29	; 62
    1146:	0f be       	out	0x3f, r0	; 63
    1148:	cd bf       	out	0x3d, r28	; 61
    114a:	cf 91       	pop	r28
    114c:	df 91       	pop	r29
    114e:	08 95       	ret

00001150 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1150:	df 93       	push	r29
    1152:	cf 93       	push	r28
    1154:	cd b7       	in	r28, 0x3d	; 61
    1156:	de b7       	in	r29, 0x3e	; 62
    /* Setup the relevant timer hardware to generate the tick. */
    prvSetupTimerInterrupt();
    1158:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <prvSetupTimerInterrupt>

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    115c:	a0 91 32 15 	lds	r26, 0x1532
    1160:	b0 91 33 15 	lds	r27, 0x1533
    1164:	cd 91       	ld	r28, X+
    1166:	cd bf       	out	0x3d, r28	; 61
    1168:	dd 91       	ld	r29, X+
    116a:	de bf       	out	0x3e, r29	; 62
    116c:	ff 91       	pop	r31
    116e:	ef 91       	pop	r30
    1170:	df 91       	pop	r29
    1172:	cf 91       	pop	r28
    1174:	bf 91       	pop	r27
    1176:	af 91       	pop	r26
    1178:	9f 91       	pop	r25
    117a:	8f 91       	pop	r24
    117c:	7f 91       	pop	r23
    117e:	6f 91       	pop	r22
    1180:	5f 91       	pop	r21
    1182:	4f 91       	pop	r20
    1184:	3f 91       	pop	r19
    1186:	2f 91       	pop	r18
    1188:	1f 91       	pop	r17
    118a:	0f 91       	pop	r16
    118c:	ff 90       	pop	r15
    118e:	ef 90       	pop	r14
    1190:	df 90       	pop	r13
    1192:	cf 90       	pop	r12
    1194:	bf 90       	pop	r11
    1196:	af 90       	pop	r10
    1198:	9f 90       	pop	r9
    119a:	8f 90       	pop	r8
    119c:	7f 90       	pop	r7
    119e:	6f 90       	pop	r6
    11a0:	5f 90       	pop	r5
    11a2:	4f 90       	pop	r4
    11a4:	3f 90       	pop	r3
    11a6:	2f 90       	pop	r2
    11a8:	1f 90       	pop	r1
    11aa:	0f 90       	pop	r0
    11ac:	0f be       	out	0x3f, r0	; 63
    11ae:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler. We will now
    jump to the start of the task the context of which we have just restored. */
    __asm__ __volatile__ ( "ret" );
    11b0:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
    11b2:	81 e0       	ldi	r24, 0x01	; 1
}
    11b4:	cf 91       	pop	r28
    11b6:	df 91       	pop	r29
    11b8:	08 95       	ret

000011ba <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    11ba:	df 93       	push	r29
    11bc:	cf 93       	push	r28
    11be:	cd b7       	in	r28, 0x3d	; 61
    11c0:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the ATmega port will get stopped. */
}
    11c2:	cf 91       	pop	r28
    11c4:	df 91       	pop	r29
    11c6:	08 95       	ret

000011c8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    11c8:	0f 92       	push	r0
    11ca:	0f b6       	in	r0, 0x3f	; 63
    11cc:	f8 94       	cli
    11ce:	0f 92       	push	r0
    11d0:	1f 92       	push	r1
    11d2:	11 24       	eor	r1, r1
    11d4:	2f 92       	push	r2
    11d6:	3f 92       	push	r3
    11d8:	4f 92       	push	r4
    11da:	5f 92       	push	r5
    11dc:	6f 92       	push	r6
    11de:	7f 92       	push	r7
    11e0:	8f 92       	push	r8
    11e2:	9f 92       	push	r9
    11e4:	af 92       	push	r10
    11e6:	bf 92       	push	r11
    11e8:	cf 92       	push	r12
    11ea:	df 92       	push	r13
    11ec:	ef 92       	push	r14
    11ee:	ff 92       	push	r15
    11f0:	0f 93       	push	r16
    11f2:	1f 93       	push	r17
    11f4:	2f 93       	push	r18
    11f6:	3f 93       	push	r19
    11f8:	4f 93       	push	r20
    11fa:	5f 93       	push	r21
    11fc:	6f 93       	push	r22
    11fe:	7f 93       	push	r23
    1200:	8f 93       	push	r24
    1202:	9f 93       	push	r25
    1204:	af 93       	push	r26
    1206:	bf 93       	push	r27
    1208:	cf 93       	push	r28
    120a:	df 93       	push	r29
    120c:	ef 93       	push	r30
    120e:	ff 93       	push	r31
    1210:	a0 91 32 15 	lds	r26, 0x1532
    1214:	b0 91 33 15 	lds	r27, 0x1533
    1218:	0d b6       	in	r0, 0x3d	; 61
    121a:	0d 92       	st	X+, r0
    121c:	0e b6       	in	r0, 0x3e	; 62
    121e:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    1220:	0e 94 bc 20 	call	0x4178	; 0x4178 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    1224:	a0 91 32 15 	lds	r26, 0x1532
    1228:	b0 91 33 15 	lds	r27, 0x1533
    122c:	cd 91       	ld	r28, X+
    122e:	cd bf       	out	0x3d, r28	; 61
    1230:	dd 91       	ld	r29, X+
    1232:	de bf       	out	0x3e, r29	; 62
    1234:	ff 91       	pop	r31
    1236:	ef 91       	pop	r30
    1238:	df 91       	pop	r29
    123a:	cf 91       	pop	r28
    123c:	bf 91       	pop	r27
    123e:	af 91       	pop	r26
    1240:	9f 91       	pop	r25
    1242:	8f 91       	pop	r24
    1244:	7f 91       	pop	r23
    1246:	6f 91       	pop	r22
    1248:	5f 91       	pop	r21
    124a:	4f 91       	pop	r20
    124c:	3f 91       	pop	r19
    124e:	2f 91       	pop	r18
    1250:	1f 91       	pop	r17
    1252:	0f 91       	pop	r16
    1254:	ff 90       	pop	r15
    1256:	ef 90       	pop	r14
    1258:	df 90       	pop	r13
    125a:	cf 90       	pop	r12
    125c:	bf 90       	pop	r11
    125e:	af 90       	pop	r10
    1260:	9f 90       	pop	r9
    1262:	8f 90       	pop	r8
    1264:	7f 90       	pop	r7
    1266:	6f 90       	pop	r6
    1268:	5f 90       	pop	r5
    126a:	4f 90       	pop	r4
    126c:	3f 90       	pop	r3
    126e:	2f 90       	pop	r2
    1270:	1f 90       	pop	r1
    1272:	0f 90       	pop	r0
    1274:	0f be       	out	0x3f, r0	; 63
    1276:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    1278:	08 95       	ret

0000127a <vPortYieldFromISR>:
 * the registers so we can use a naked attribute.
 */
void vPortYieldFromISR(void) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromISR(void)
{
    portSAVE_CONTEXT();
    127a:	0f 92       	push	r0
    127c:	0f b6       	in	r0, 0x3f	; 63
    127e:	f8 94       	cli
    1280:	0f 92       	push	r0
    1282:	1f 92       	push	r1
    1284:	11 24       	eor	r1, r1
    1286:	2f 92       	push	r2
    1288:	3f 92       	push	r3
    128a:	4f 92       	push	r4
    128c:	5f 92       	push	r5
    128e:	6f 92       	push	r6
    1290:	7f 92       	push	r7
    1292:	8f 92       	push	r8
    1294:	9f 92       	push	r9
    1296:	af 92       	push	r10
    1298:	bf 92       	push	r11
    129a:	cf 92       	push	r12
    129c:	df 92       	push	r13
    129e:	ef 92       	push	r14
    12a0:	ff 92       	push	r15
    12a2:	0f 93       	push	r16
    12a4:	1f 93       	push	r17
    12a6:	2f 93       	push	r18
    12a8:	3f 93       	push	r19
    12aa:	4f 93       	push	r20
    12ac:	5f 93       	push	r21
    12ae:	6f 93       	push	r22
    12b0:	7f 93       	push	r23
    12b2:	8f 93       	push	r24
    12b4:	9f 93       	push	r25
    12b6:	af 93       	push	r26
    12b8:	bf 93       	push	r27
    12ba:	cf 93       	push	r28
    12bc:	df 93       	push	r29
    12be:	ef 93       	push	r30
    12c0:	ff 93       	push	r31
    12c2:	a0 91 32 15 	lds	r26, 0x1532
    12c6:	b0 91 33 15 	lds	r27, 0x1533
    12ca:	0d b6       	in	r0, 0x3d	; 61
    12cc:	0d 92       	st	X+, r0
    12ce:	0e b6       	in	r0, 0x3e	; 62
    12d0:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    12d2:	0e 94 bc 20 	call	0x4178	; 0x4178 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    12d6:	a0 91 32 15 	lds	r26, 0x1532
    12da:	b0 91 33 15 	lds	r27, 0x1533
    12de:	cd 91       	ld	r28, X+
    12e0:	cd bf       	out	0x3d, r28	; 61
    12e2:	dd 91       	ld	r29, X+
    12e4:	de bf       	out	0x3e, r29	; 62
    12e6:	ff 91       	pop	r31
    12e8:	ef 91       	pop	r30
    12ea:	df 91       	pop	r29
    12ec:	cf 91       	pop	r28
    12ee:	bf 91       	pop	r27
    12f0:	af 91       	pop	r26
    12f2:	9f 91       	pop	r25
    12f4:	8f 91       	pop	r24
    12f6:	7f 91       	pop	r23
    12f8:	6f 91       	pop	r22
    12fa:	5f 91       	pop	r21
    12fc:	4f 91       	pop	r20
    12fe:	3f 91       	pop	r19
    1300:	2f 91       	pop	r18
    1302:	1f 91       	pop	r17
    1304:	0f 91       	pop	r16
    1306:	ff 90       	pop	r15
    1308:	ef 90       	pop	r14
    130a:	df 90       	pop	r13
    130c:	cf 90       	pop	r12
    130e:	bf 90       	pop	r11
    1310:	af 90       	pop	r10
    1312:	9f 90       	pop	r9
    1314:	8f 90       	pop	r8
    1316:	7f 90       	pop	r7
    1318:	6f 90       	pop	r6
    131a:	5f 90       	pop	r5
    131c:	4f 90       	pop	r4
    131e:	3f 90       	pop	r3
    1320:	2f 90       	pop	r2
    1322:	1f 90       	pop	r1
    1324:	0f 90       	pop	r0
    1326:	0f be       	out	0x3f, r0	; 63
    1328:	0f 90       	pop	r0

    __asm__ __volatile__ ( "reti" );
    132a:	18 95       	reti

0000132c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    132c:	0f 92       	push	r0
    132e:	0f b6       	in	r0, 0x3f	; 63
    1330:	f8 94       	cli
    1332:	0f 92       	push	r0
    1334:	1f 92       	push	r1
    1336:	11 24       	eor	r1, r1
    1338:	2f 92       	push	r2
    133a:	3f 92       	push	r3
    133c:	4f 92       	push	r4
    133e:	5f 92       	push	r5
    1340:	6f 92       	push	r6
    1342:	7f 92       	push	r7
    1344:	8f 92       	push	r8
    1346:	9f 92       	push	r9
    1348:	af 92       	push	r10
    134a:	bf 92       	push	r11
    134c:	cf 92       	push	r12
    134e:	df 92       	push	r13
    1350:	ef 92       	push	r14
    1352:	ff 92       	push	r15
    1354:	0f 93       	push	r16
    1356:	1f 93       	push	r17
    1358:	2f 93       	push	r18
    135a:	3f 93       	push	r19
    135c:	4f 93       	push	r20
    135e:	5f 93       	push	r21
    1360:	6f 93       	push	r22
    1362:	7f 93       	push	r23
    1364:	8f 93       	push	r24
    1366:	9f 93       	push	r25
    1368:	af 93       	push	r26
    136a:	bf 93       	push	r27
    136c:	cf 93       	push	r28
    136e:	df 93       	push	r29
    1370:	ef 93       	push	r30
    1372:	ff 93       	push	r31
    1374:	a0 91 32 15 	lds	r26, 0x1532
    1378:	b0 91 33 15 	lds	r27, 0x1533
    137c:	0d b6       	in	r0, 0x3d	; 61
    137e:	0d 92       	st	X+, r0
    1380:	0e b6       	in	r0, 0x3e	; 62
    1382:	0d 92       	st	X+, r0
    if( xTaskIncrementTick() != pdFALSE )
    1384:	0e 94 d6 1e 	call	0x3dac	; 0x3dac <xTaskIncrementTick>
    1388:	88 23       	and	r24, r24
    138a:	11 f0       	breq	.+4      	; 0x1390 <vPortYieldFromTick+0x64>
    {
        vTaskSwitchContext();
    138c:	0e 94 bc 20 	call	0x4178	; 0x4178 <vTaskSwitchContext>
    }
    portRESTORE_CONTEXT();
    1390:	a0 91 32 15 	lds	r26, 0x1532
    1394:	b0 91 33 15 	lds	r27, 0x1533
    1398:	cd 91       	ld	r28, X+
    139a:	cd bf       	out	0x3d, r28	; 61
    139c:	dd 91       	ld	r29, X+
    139e:	de bf       	out	0x3e, r29	; 62
    13a0:	ff 91       	pop	r31
    13a2:	ef 91       	pop	r30
    13a4:	df 91       	pop	r29
    13a6:	cf 91       	pop	r28
    13a8:	bf 91       	pop	r27
    13aa:	af 91       	pop	r26
    13ac:	9f 91       	pop	r25
    13ae:	8f 91       	pop	r24
    13b0:	7f 91       	pop	r23
    13b2:	6f 91       	pop	r22
    13b4:	5f 91       	pop	r21
    13b6:	4f 91       	pop	r20
    13b8:	3f 91       	pop	r19
    13ba:	2f 91       	pop	r18
    13bc:	1f 91       	pop	r17
    13be:	0f 91       	pop	r16
    13c0:	ff 90       	pop	r15
    13c2:	ef 90       	pop	r14
    13c4:	df 90       	pop	r13
    13c6:	cf 90       	pop	r12
    13c8:	bf 90       	pop	r11
    13ca:	af 90       	pop	r10
    13cc:	9f 90       	pop	r9
    13ce:	8f 90       	pop	r8
    13d0:	7f 90       	pop	r7
    13d2:	6f 90       	pop	r6
    13d4:	5f 90       	pop	r5
    13d6:	4f 90       	pop	r4
    13d8:	3f 90       	pop	r3
    13da:	2f 90       	pop	r2
    13dc:	1f 90       	pop	r1
    13de:	0f 90       	pop	r0
    13e0:	0f be       	out	0x3f, r0	; 63
    13e2:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    13e4:	08 95       	ret

000013e6 <prvSetupTimerInterrupt>:
#if defined(portUSE_WDTO)
/*
 * Setup WDT to generate a tick interrupt.
 */
void prvSetupTimerInterrupt( void )
{
    13e6:	df 93       	push	r29
    13e8:	cf 93       	push	r28
    13ea:	0f 92       	push	r0
    13ec:	cd b7       	in	r28, 0x3d	; 61
    13ee:	de b7       	in	r29, 0x3e	; 62
    /* reset watchdog */
    wdt_reset();
    13f0:	a8 95       	wdr
                : "r0"
        );
    }
    else
    {
        __asm__ __volatile__ (
    13f2:	80 e0       	ldi	r24, 0x00	; 0
    13f4:	90 e0       	ldi	r25, 0x00	; 0
    13f6:	88 70       	andi	r24, 0x08	; 8
    13f8:	90 70       	andi	r25, 0x00	; 0
    13fa:	00 97       	sbiw	r24, 0x00	; 0
    13fc:	19 f0       	breq	.+6      	; 0x1404 <prvSetupTimerInterrupt+0x1e>
    13fe:	80 ee       	ldi	r24, 0xE0	; 224
    1400:	89 83       	std	Y+1, r24	; 0x01
    1402:	02 c0       	rjmp	.+4      	; 0x1408 <prvSetupTimerInterrupt+0x22>
    1404:	90 ec       	ldi	r25, 0xC0	; 192
    1406:	99 83       	std	Y+1, r25	; 0x01
    1408:	80 e0       	ldi	r24, 0x00	; 0
    140a:	87 70       	andi	r24, 0x07	; 7
    140c:	99 81       	ldd	r25, Y+1	; 0x01
    140e:	89 2b       	or	r24, r25
    1410:	98 2f       	mov	r25, r24
    1412:	88 e1       	ldi	r24, 0x18	; 24
    1414:	0f b6       	in	r0, 0x3f	; 63
    1416:	f8 94       	cli
    1418:	a8 95       	wdr
    141a:	80 93 60 00 	sts	0x0060, r24
    141e:	0f be       	out	0x3f, r0	; 63
    1420:	90 93 60 00 	sts	0x0060, r25
    /* reset watchdog */
    wdt_reset();

    /* set up WDT Interrupt (rather than the WDT Reset). */
    wdt_interrupt_enable( portUSE_WDTO );
}
    1424:	0f 90       	pop	r0
    1426:	cf 91       	pop	r28
    1428:	df 91       	pop	r29
    142a:	08 95       	ret

0000142c <__vector_12>:
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
/*  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
 */
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
    142c:	0e 94 96 09 	call	0x132c	; 0x132c <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
    1430:	18 95       	reti

00001432 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    1432:	df 93       	push	r29
    1434:	cf 93       	push	r28
    1436:	00 d0       	rcall	.+0      	; 0x1438 <pvPortMalloc+0x6>
    1438:	00 d0       	rcall	.+0      	; 0x143a <pvPortMalloc+0x8>
    143a:	cd b7       	in	r28, 0x3d	; 61
    143c:	de b7       	in	r29, 0x3e	; 62
    143e:	9c 83       	std	Y+4, r25	; 0x04
    1440:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
    1442:	1a 82       	std	Y+2, r1	; 0x02
    1444:	19 82       	std	Y+1, r1	; 0x01
            }
        }
    }
    #endif /* if ( portBYTE_ALIGNMENT != 1 ) */

    vTaskSuspendAll();
    1446:	0e 94 9a 1c 	call	0x3934	; 0x3934 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
    144a:	80 91 30 05 	lds	r24, 0x0530
    144e:	90 91 31 05 	lds	r25, 0x0531
    1452:	00 97       	sbiw	r24, 0x00	; 0
    1454:	31 f4       	brne	.+12     	; 0x1462 <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1456:	82 e3       	ldi	r24, 0x32	; 50
    1458:	95 e0       	ldi	r25, 0x05	; 5
    145a:	90 93 31 05 	sts	0x0531, r25
    145e:	80 93 30 05 	sts	0x0530, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
    1462:	8b 81       	ldd	r24, Y+3	; 0x03
    1464:	9c 81       	ldd	r25, Y+4	; 0x04
    1466:	00 97       	sbiw	r24, 0x00	; 0
    1468:	99 f1       	breq	.+102    	; 0x14d0 <pvPortMalloc+0x9e>
    146a:	80 91 2e 05 	lds	r24, 0x052E
    146e:	90 91 2f 05 	lds	r25, 0x052F
    1472:	2b 81       	ldd	r18, Y+3	; 0x03
    1474:	3c 81       	ldd	r19, Y+4	; 0x04
    1476:	82 0f       	add	r24, r18
    1478:	93 1f       	adc	r25, r19
    147a:	2f e0       	ldi	r18, 0x0F	; 15
    147c:	8f 3f       	cpi	r24, 0xFF	; 255
    147e:	92 07       	cpc	r25, r18
    1480:	38 f5       	brcc	.+78     	; 0x14d0 <pvPortMalloc+0x9e>
    1482:	20 91 2e 05 	lds	r18, 0x052E
    1486:	30 91 2f 05 	lds	r19, 0x052F
    148a:	8b 81       	ldd	r24, Y+3	; 0x03
    148c:	9c 81       	ldd	r25, Y+4	; 0x04
    148e:	28 0f       	add	r18, r24
    1490:	39 1f       	adc	r19, r25
    1492:	80 91 2e 05 	lds	r24, 0x052E
    1496:	90 91 2f 05 	lds	r25, 0x052F
    149a:	82 17       	cp	r24, r18
    149c:	93 07       	cpc	r25, r19
    149e:	c0 f4       	brcc	.+48     	; 0x14d0 <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
    14a0:	20 91 30 05 	lds	r18, 0x0530
    14a4:	30 91 31 05 	lds	r19, 0x0531
    14a8:	80 91 2e 05 	lds	r24, 0x052E
    14ac:	90 91 2f 05 	lds	r25, 0x052F
    14b0:	82 0f       	add	r24, r18
    14b2:	93 1f       	adc	r25, r19
    14b4:	9a 83       	std	Y+2, r25	; 0x02
    14b6:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
    14b8:	20 91 2e 05 	lds	r18, 0x052E
    14bc:	30 91 2f 05 	lds	r19, 0x052F
    14c0:	8b 81       	ldd	r24, Y+3	; 0x03
    14c2:	9c 81       	ldd	r25, Y+4	; 0x04
    14c4:	82 0f       	add	r24, r18
    14c6:	93 1f       	adc	r25, r19
    14c8:	90 93 2f 05 	sts	0x052F, r25
    14cc:	80 93 2e 05 	sts	0x052E, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    14d0:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>
            vApplicationMallocFailedHook();
        }
    }
    #endif

    return pvReturn;
    14d4:	89 81       	ldd	r24, Y+1	; 0x01
    14d6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    14d8:	0f 90       	pop	r0
    14da:	0f 90       	pop	r0
    14dc:	0f 90       	pop	r0
    14de:	0f 90       	pop	r0
    14e0:	cf 91       	pop	r28
    14e2:	df 91       	pop	r29
    14e4:	08 95       	ret

000014e6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    14e6:	df 93       	push	r29
    14e8:	cf 93       	push	r28
    14ea:	00 d0       	rcall	.+0      	; 0x14ec <vPortFree+0x6>
    14ec:	cd b7       	in	r28, 0x3d	; 61
    14ee:	de b7       	in	r29, 0x3e	; 62
    14f0:	9a 83       	std	Y+2, r25	; 0x02
    14f2:	89 83       	std	Y+1, r24	; 0x01
     * heap_4.c for alternative implementations, and the memory management pages of
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
    14f4:	89 81       	ldd	r24, Y+1	; 0x01
    14f6:	9a 81       	ldd	r25, Y+2	; 0x02
    14f8:	00 97       	sbiw	r24, 0x00	; 0
    14fa:	11 f0       	breq	.+4      	; 0x1500 <vPortFree+0x1a>
    14fc:	f8 94       	cli
    14fe:	ff cf       	rjmp	.-2      	; 0x14fe <vPortFree+0x18>
}
    1500:	0f 90       	pop	r0
    1502:	0f 90       	pop	r0
    1504:	cf 91       	pop	r28
    1506:	df 91       	pop	r29
    1508:	08 95       	ret

0000150a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    150a:	df 93       	push	r29
    150c:	cf 93       	push	r28
    150e:	cd b7       	in	r28, 0x3d	; 61
    1510:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
    1512:	10 92 2f 05 	sts	0x052F, r1
    1516:	10 92 2e 05 	sts	0x052E, r1
}
    151a:	cf 91       	pop	r28
    151c:	df 91       	pop	r29
    151e:	08 95       	ret

00001520 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1520:	df 93       	push	r29
    1522:	cf 93       	push	r28
    1524:	cd b7       	in	r28, 0x3d	; 61
    1526:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1528:	20 91 2e 05 	lds	r18, 0x052E
    152c:	30 91 2f 05 	lds	r19, 0x052F
    1530:	8f ef       	ldi	r24, 0xFF	; 255
    1532:	9f e0       	ldi	r25, 0x0F	; 15
    1534:	82 1b       	sub	r24, r18
    1536:	93 0b       	sbc	r25, r19
}
    1538:	cf 91       	pop	r28
    153a:	df 91       	pop	r29
    153c:	08 95       	ret

0000153e <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    153e:	df 93       	push	r29
    1540:	cf 93       	push	r28
    1542:	00 d0       	rcall	.+0      	; 0x1544 <xEventGroupCreate+0x6>
    1544:	cd b7       	in	r28, 0x3d	; 61
    1546:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1548:	8f e0       	ldi	r24, 0x0F	; 15
    154a:	90 e0       	ldi	r25, 0x00	; 0
    154c:	0e 94 19 0a 	call	0x1432	; 0x1432 <pvPortMalloc>
    1550:	9a 83       	std	Y+2, r25	; 0x02
    1552:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    1554:	89 81       	ldd	r24, Y+1	; 0x01
    1556:	9a 81       	ldd	r25, Y+2	; 0x02
    1558:	00 97       	sbiw	r24, 0x00	; 0
    155a:	59 f0       	breq	.+22     	; 0x1572 <xEventGroupCreate+0x34>
        {
            pxEventBits->uxEventBits = 0;
    155c:	e9 81       	ldd	r30, Y+1	; 0x01
    155e:	fa 81       	ldd	r31, Y+2	; 0x02
    1560:	10 82       	st	Z, r1
    1562:	11 82       	std	Z+1, r1	; 0x01
    1564:	12 82       	std	Z+2, r1	; 0x02
    1566:	13 82       	std	Z+3, r1	; 0x03
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1568:	89 81       	ldd	r24, Y+1	; 0x01
    156a:	9a 81       	ldd	r25, Y+2	; 0x02
    156c:	04 96       	adiw	r24, 0x04	; 4
    156e:	0e 94 ce 0f 	call	0x1f9c	; 0x1f9c <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    1572:	89 81       	ldd	r24, Y+1	; 0x01
    1574:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    1576:	0f 90       	pop	r0
    1578:	0f 90       	pop	r0
    157a:	cf 91       	pop	r28
    157c:	df 91       	pop	r29
    157e:	08 95       	ret

00001580 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    1580:	cf 92       	push	r12
    1582:	df 92       	push	r13
    1584:	ef 92       	push	r14
    1586:	ff 92       	push	r15
    1588:	0f 93       	push	r16
    158a:	1f 93       	push	r17
    158c:	df 93       	push	r29
    158e:	cf 93       	push	r28
    1590:	cd b7       	in	r28, 0x3d	; 61
    1592:	de b7       	in	r29, 0x3e	; 62
    1594:	6a 97       	sbiw	r28, 0x1a	; 26
    1596:	0f b6       	in	r0, 0x3f	; 63
    1598:	f8 94       	cli
    159a:	de bf       	out	0x3e, r29	; 62
    159c:	0f be       	out	0x3f, r0	; 63
    159e:	cd bf       	out	0x3d, r28	; 61
    15a0:	9e 87       	std	Y+14, r25	; 0x0e
    15a2:	8d 87       	std	Y+13, r24	; 0x0d
    15a4:	4f 87       	std	Y+15, r20	; 0x0f
    15a6:	58 8b       	std	Y+16, r21	; 0x10
    15a8:	69 8b       	std	Y+17, r22	; 0x11
    15aa:	7a 8b       	std	Y+18, r23	; 0x12
    15ac:	0b 8b       	std	Y+19, r16	; 0x13
    15ae:	1c 8b       	std	Y+20, r17	; 0x14
    15b0:	2d 8b       	std	Y+21, r18	; 0x15
    15b2:	3e 8b       	std	Y+22, r19	; 0x16
    15b4:	cf 8a       	std	Y+23, r12	; 0x17
    15b6:	d8 8e       	std	Y+24, r13	; 0x18
    15b8:	e9 8e       	std	Y+25, r14	; 0x19
    15ba:	fa 8e       	std	Y+26, r15	; 0x1a
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    15bc:	8d 85       	ldd	r24, Y+13	; 0x0d
    15be:	9e 85       	ldd	r25, Y+14	; 0x0e
    15c0:	9c 83       	std	Y+4, r25	; 0x04
    15c2:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    15c4:	19 82       	std	Y+1, r1	; 0x01

    configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    15c6:	8b 89       	ldd	r24, Y+19	; 0x13
    15c8:	9c 89       	ldd	r25, Y+20	; 0x14
    15ca:	ad 89       	ldd	r26, Y+21	; 0x15
    15cc:	be 89       	ldd	r27, Y+22	; 0x16
    15ce:	80 70       	andi	r24, 0x00	; 0
    15d0:	90 70       	andi	r25, 0x00	; 0
    15d2:	a0 70       	andi	r26, 0x00	; 0
    15d4:	00 97       	sbiw	r24, 0x00	; 0
    15d6:	a1 05       	cpc	r26, r1
    15d8:	b1 05       	cpc	r27, r1
    15da:	11 f0       	breq	.+4      	; 0x15e0 <xEventGroupSync+0x60>
    15dc:	f8 94       	cli
    15de:	ff cf       	rjmp	.-2      	; 0x15de <xEventGroupSync+0x5e>
    configASSERT( uxBitsToWaitFor != 0 );
    15e0:	8b 89       	ldd	r24, Y+19	; 0x13
    15e2:	9c 89       	ldd	r25, Y+20	; 0x14
    15e4:	ad 89       	ldd	r26, Y+21	; 0x15
    15e6:	be 89       	ldd	r27, Y+22	; 0x16
    15e8:	00 97       	sbiw	r24, 0x00	; 0
    15ea:	a1 05       	cpc	r26, r1
    15ec:	b1 05       	cpc	r27, r1
    15ee:	11 f4       	brne	.+4      	; 0x15f4 <xEventGroupSync+0x74>
    15f0:	f8 94       	cli
    15f2:	ff cf       	rjmp	.-2      	; 0x15f2 <xEventGroupSync+0x72>
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
    15f4:	0e 94 9a 1c 	call	0x3934	; 0x3934 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    15f8:	eb 81       	ldd	r30, Y+3	; 0x03
    15fa:	fc 81       	ldd	r31, Y+4	; 0x04
    15fc:	80 81       	ld	r24, Z
    15fe:	91 81       	ldd	r25, Z+1	; 0x01
    1600:	a2 81       	ldd	r26, Z+2	; 0x02
    1602:	b3 81       	ldd	r27, Z+3	; 0x03
    1604:	89 87       	std	Y+9, r24	; 0x09
    1606:	9a 87       	std	Y+10, r25	; 0x0a
    1608:	ab 87       	std	Y+11, r26	; 0x0b
    160a:	bc 87       	std	Y+12, r27	; 0x0c

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    160c:	8d 85       	ldd	r24, Y+13	; 0x0d
    160e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1610:	2f 85       	ldd	r18, Y+15	; 0x0f
    1612:	38 89       	ldd	r19, Y+16	; 0x10
    1614:	49 89       	ldd	r20, Y+17	; 0x11
    1616:	5a 89       	ldd	r21, Y+18	; 0x12
    1618:	ba 01       	movw	r22, r20
    161a:	a9 01       	movw	r20, r18
    161c:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1620:	29 85       	ldd	r18, Y+9	; 0x09
    1622:	3a 85       	ldd	r19, Y+10	; 0x0a
    1624:	4b 85       	ldd	r20, Y+11	; 0x0b
    1626:	5c 85       	ldd	r21, Y+12	; 0x0c
    1628:	8f 85       	ldd	r24, Y+15	; 0x0f
    162a:	98 89       	ldd	r25, Y+16	; 0x10
    162c:	a9 89       	ldd	r26, Y+17	; 0x11
    162e:	ba 89       	ldd	r27, Y+18	; 0x12
    1630:	28 2b       	or	r18, r24
    1632:	39 2b       	or	r19, r25
    1634:	4a 2b       	or	r20, r26
    1636:	5b 2b       	or	r21, r27
    1638:	8b 89       	ldd	r24, Y+19	; 0x13
    163a:	9c 89       	ldd	r25, Y+20	; 0x14
    163c:	ad 89       	ldd	r26, Y+21	; 0x15
    163e:	be 89       	ldd	r27, Y+22	; 0x16
    1640:	28 23       	and	r18, r24
    1642:	39 23       	and	r19, r25
    1644:	4a 23       	and	r20, r26
    1646:	5b 23       	and	r21, r27
    1648:	8b 89       	ldd	r24, Y+19	; 0x13
    164a:	9c 89       	ldd	r25, Y+20	; 0x14
    164c:	ad 89       	ldd	r26, Y+21	; 0x15
    164e:	be 89       	ldd	r27, Y+22	; 0x16
    1650:	28 17       	cp	r18, r24
    1652:	39 07       	cpc	r19, r25
    1654:	4a 07       	cpc	r20, r26
    1656:	5b 07       	cpc	r21, r27
    1658:	69 f5       	brne	.+90     	; 0x16b4 <xEventGroupSync+0x134>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    165a:	29 85       	ldd	r18, Y+9	; 0x09
    165c:	3a 85       	ldd	r19, Y+10	; 0x0a
    165e:	4b 85       	ldd	r20, Y+11	; 0x0b
    1660:	5c 85       	ldd	r21, Y+12	; 0x0c
    1662:	8f 85       	ldd	r24, Y+15	; 0x0f
    1664:	98 89       	ldd	r25, Y+16	; 0x10
    1666:	a9 89       	ldd	r26, Y+17	; 0x11
    1668:	ba 89       	ldd	r27, Y+18	; 0x12
    166a:	82 2b       	or	r24, r18
    166c:	93 2b       	or	r25, r19
    166e:	a4 2b       	or	r26, r20
    1670:	b5 2b       	or	r27, r21
    1672:	8d 83       	std	Y+5, r24	; 0x05
    1674:	9e 83       	std	Y+6, r25	; 0x06
    1676:	af 83       	std	Y+7, r26	; 0x07
    1678:	b8 87       	std	Y+8, r27	; 0x08

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    167a:	eb 81       	ldd	r30, Y+3	; 0x03
    167c:	fc 81       	ldd	r31, Y+4	; 0x04
    167e:	20 81       	ld	r18, Z
    1680:	31 81       	ldd	r19, Z+1	; 0x01
    1682:	42 81       	ldd	r20, Z+2	; 0x02
    1684:	53 81       	ldd	r21, Z+3	; 0x03
    1686:	8b 89       	ldd	r24, Y+19	; 0x13
    1688:	9c 89       	ldd	r25, Y+20	; 0x14
    168a:	ad 89       	ldd	r26, Y+21	; 0x15
    168c:	be 89       	ldd	r27, Y+22	; 0x16
    168e:	80 95       	com	r24
    1690:	90 95       	com	r25
    1692:	a0 95       	com	r26
    1694:	b0 95       	com	r27
    1696:	82 23       	and	r24, r18
    1698:	93 23       	and	r25, r19
    169a:	a4 23       	and	r26, r20
    169c:	b5 23       	and	r27, r21
    169e:	eb 81       	ldd	r30, Y+3	; 0x03
    16a0:	fc 81       	ldd	r31, Y+4	; 0x04
    16a2:	80 83       	st	Z, r24
    16a4:	91 83       	std	Z+1, r25	; 0x01
    16a6:	a2 83       	std	Z+2, r26	; 0x02
    16a8:	b3 83       	std	Z+3, r27	; 0x03

            xTicksToWait = 0;
    16aa:	1f 8a       	std	Y+23, r1	; 0x17
    16ac:	18 8e       	std	Y+24, r1	; 0x18
    16ae:	19 8e       	std	Y+25, r1	; 0x19
    16b0:	1a 8e       	std	Y+26, r1	; 0x1a
    16b2:	30 c0       	rjmp	.+96     	; 0x1714 <xEventGroupSync+0x194>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    16b4:	8f 89       	ldd	r24, Y+23	; 0x17
    16b6:	98 8d       	ldd	r25, Y+24	; 0x18
    16b8:	a9 8d       	ldd	r26, Y+25	; 0x19
    16ba:	ba 8d       	ldd	r27, Y+26	; 0x1a
    16bc:	00 97       	sbiw	r24, 0x00	; 0
    16be:	a1 05       	cpc	r26, r1
    16c0:	b1 05       	cpc	r27, r1
    16c2:	e1 f0       	breq	.+56     	; 0x16fc <xEventGroupSync+0x17c>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    16c4:	8b 81       	ldd	r24, Y+3	; 0x03
    16c6:	9c 81       	ldd	r25, Y+4	; 0x04
    16c8:	bc 01       	movw	r22, r24
    16ca:	6c 5f       	subi	r22, 0xFC	; 252
    16cc:	7f 4f       	sbci	r23, 0xFF	; 255
    16ce:	8b 89       	ldd	r24, Y+19	; 0x13
    16d0:	9c 89       	ldd	r25, Y+20	; 0x14
    16d2:	ad 89       	ldd	r26, Y+21	; 0x15
    16d4:	be 89       	ldd	r27, Y+22	; 0x16
    16d6:	9c 01       	movw	r18, r24
    16d8:	ad 01       	movw	r20, r26
    16da:	55 60       	ori	r21, 0x05	; 5
    16dc:	ef 88       	ldd	r14, Y+23	; 0x17
    16de:	f8 8c       	ldd	r15, Y+24	; 0x18
    16e0:	09 8d       	ldd	r16, Y+25	; 0x19
    16e2:	1a 8d       	ldd	r17, Y+26	; 0x1a
    16e4:	cb 01       	movw	r24, r22
    16e6:	ba 01       	movw	r22, r20
    16e8:	a9 01       	movw	r20, r18
    16ea:	98 01       	movw	r18, r16
    16ec:	87 01       	movw	r16, r14
    16ee:	0e 94 65 21 	call	0x42ca	; 0x42ca <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    16f2:	1d 82       	std	Y+5, r1	; 0x05
    16f4:	1e 82       	std	Y+6, r1	; 0x06
    16f6:	1f 82       	std	Y+7, r1	; 0x07
    16f8:	18 86       	std	Y+8, r1	; 0x08
    16fa:	0c c0       	rjmp	.+24     	; 0x1714 <xEventGroupSync+0x194>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    16fc:	eb 81       	ldd	r30, Y+3	; 0x03
    16fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1700:	80 81       	ld	r24, Z
    1702:	91 81       	ldd	r25, Z+1	; 0x01
    1704:	a2 81       	ldd	r26, Z+2	; 0x02
    1706:	b3 81       	ldd	r27, Z+3	; 0x03
    1708:	8d 83       	std	Y+5, r24	; 0x05
    170a:	9e 83       	std	Y+6, r25	; 0x06
    170c:	af 83       	std	Y+7, r26	; 0x07
    170e:	b8 87       	std	Y+8, r27	; 0x08
                xTimeoutOccurred = pdTRUE;
    1710:	81 e0       	ldi	r24, 0x01	; 1
    1712:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1714:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>
    1718:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    171a:	8f 89       	ldd	r24, Y+23	; 0x17
    171c:	98 8d       	ldd	r25, Y+24	; 0x18
    171e:	a9 8d       	ldd	r26, Y+25	; 0x19
    1720:	ba 8d       	ldd	r27, Y+26	; 0x1a
    1722:	00 97       	sbiw	r24, 0x00	; 0
    1724:	a1 05       	cpc	r26, r1
    1726:	b1 05       	cpc	r27, r1
    1728:	09 f4       	brne	.+2      	; 0x172c <xEventGroupSync+0x1ac>
    172a:	61 c0       	rjmp	.+194    	; 0x17ee <xEventGroupSync+0x26e>
    {
        if( xAlreadyYielded == pdFALSE )
    172c:	8a 81       	ldd	r24, Y+2	; 0x02
    172e:	88 23       	and	r24, r24
    1730:	11 f4       	brne	.+4      	; 0x1736 <xEventGroupSync+0x1b6>
        {
            portYIELD_WITHIN_API();
    1732:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1736:	0e 94 eb 25 	call	0x4bd6	; 0x4bd6 <uxTaskResetEventItemValue>
    173a:	dc 01       	movw	r26, r24
    173c:	cb 01       	movw	r24, r22
    173e:	8d 83       	std	Y+5, r24	; 0x05
    1740:	9e 83       	std	Y+6, r25	; 0x06
    1742:	af 83       	std	Y+7, r26	; 0x07
    1744:	b8 87       	std	Y+8, r27	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1746:	8d 81       	ldd	r24, Y+5	; 0x05
    1748:	9e 81       	ldd	r25, Y+6	; 0x06
    174a:	af 81       	ldd	r26, Y+7	; 0x07
    174c:	b8 85       	ldd	r27, Y+8	; 0x08
    174e:	80 70       	andi	r24, 0x00	; 0
    1750:	90 70       	andi	r25, 0x00	; 0
    1752:	a0 70       	andi	r26, 0x00	; 0
    1754:	b2 70       	andi	r27, 0x02	; 2
    1756:	00 97       	sbiw	r24, 0x00	; 0
    1758:	a1 05       	cpc	r26, r1
    175a:	b1 05       	cpc	r27, r1
    175c:	09 f0       	breq	.+2      	; 0x1760 <xEventGroupSync+0x1e0>
    175e:	3e c0       	rjmp	.+124    	; 0x17dc <xEventGroupSync+0x25c>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    1760:	0f b6       	in	r0, 0x3f	; 63
    1762:	f8 94       	cli
    1764:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    1766:	eb 81       	ldd	r30, Y+3	; 0x03
    1768:	fc 81       	ldd	r31, Y+4	; 0x04
    176a:	80 81       	ld	r24, Z
    176c:	91 81       	ldd	r25, Z+1	; 0x01
    176e:	a2 81       	ldd	r26, Z+2	; 0x02
    1770:	b3 81       	ldd	r27, Z+3	; 0x03
    1772:	8d 83       	std	Y+5, r24	; 0x05
    1774:	9e 83       	std	Y+6, r25	; 0x06
    1776:	af 83       	std	Y+7, r26	; 0x07
    1778:	b8 87       	std	Y+8, r27	; 0x08

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    177a:	2d 81       	ldd	r18, Y+5	; 0x05
    177c:	3e 81       	ldd	r19, Y+6	; 0x06
    177e:	4f 81       	ldd	r20, Y+7	; 0x07
    1780:	58 85       	ldd	r21, Y+8	; 0x08
    1782:	8b 89       	ldd	r24, Y+19	; 0x13
    1784:	9c 89       	ldd	r25, Y+20	; 0x14
    1786:	ad 89       	ldd	r26, Y+21	; 0x15
    1788:	be 89       	ldd	r27, Y+22	; 0x16
    178a:	28 23       	and	r18, r24
    178c:	39 23       	and	r19, r25
    178e:	4a 23       	and	r20, r26
    1790:	5b 23       	and	r21, r27
    1792:	8b 89       	ldd	r24, Y+19	; 0x13
    1794:	9c 89       	ldd	r25, Y+20	; 0x14
    1796:	ad 89       	ldd	r26, Y+21	; 0x15
    1798:	be 89       	ldd	r27, Y+22	; 0x16
    179a:	28 17       	cp	r18, r24
    179c:	39 07       	cpc	r19, r25
    179e:	4a 07       	cpc	r20, r26
    17a0:	5b 07       	cpc	r21, r27
    17a2:	c1 f4       	brne	.+48     	; 0x17d4 <xEventGroupSync+0x254>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    17a4:	eb 81       	ldd	r30, Y+3	; 0x03
    17a6:	fc 81       	ldd	r31, Y+4	; 0x04
    17a8:	20 81       	ld	r18, Z
    17aa:	31 81       	ldd	r19, Z+1	; 0x01
    17ac:	42 81       	ldd	r20, Z+2	; 0x02
    17ae:	53 81       	ldd	r21, Z+3	; 0x03
    17b0:	8b 89       	ldd	r24, Y+19	; 0x13
    17b2:	9c 89       	ldd	r25, Y+20	; 0x14
    17b4:	ad 89       	ldd	r26, Y+21	; 0x15
    17b6:	be 89       	ldd	r27, Y+22	; 0x16
    17b8:	80 95       	com	r24
    17ba:	90 95       	com	r25
    17bc:	a0 95       	com	r26
    17be:	b0 95       	com	r27
    17c0:	82 23       	and	r24, r18
    17c2:	93 23       	and	r25, r19
    17c4:	a4 23       	and	r26, r20
    17c6:	b5 23       	and	r27, r21
    17c8:	eb 81       	ldd	r30, Y+3	; 0x03
    17ca:	fc 81       	ldd	r31, Y+4	; 0x04
    17cc:	80 83       	st	Z, r24
    17ce:	91 83       	std	Z+1, r25	; 0x01
    17d0:	a2 83       	std	Z+2, r26	; 0x02
    17d2:	b3 83       	std	Z+3, r27	; 0x03
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    17d4:	0f 90       	pop	r0
    17d6:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    17d8:	81 e0       	ldi	r24, 0x01	; 1
    17da:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    17dc:	8d 81       	ldd	r24, Y+5	; 0x05
    17de:	9e 81       	ldd	r25, Y+6	; 0x06
    17e0:	af 81       	ldd	r26, Y+7	; 0x07
    17e2:	b8 85       	ldd	r27, Y+8	; 0x08
    17e4:	b0 70       	andi	r27, 0x00	; 0
    17e6:	8d 83       	std	Y+5, r24	; 0x05
    17e8:	9e 83       	std	Y+6, r25	; 0x06
    17ea:	af 83       	std	Y+7, r26	; 0x07
    17ec:	b8 87       	std	Y+8, r27	; 0x08
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    17ee:	8d 81       	ldd	r24, Y+5	; 0x05
    17f0:	9e 81       	ldd	r25, Y+6	; 0x06
    17f2:	af 81       	ldd	r26, Y+7	; 0x07
    17f4:	b8 85       	ldd	r27, Y+8	; 0x08
}
    17f6:	bc 01       	movw	r22, r24
    17f8:	cd 01       	movw	r24, r26
    17fa:	6a 96       	adiw	r28, 0x1a	; 26
    17fc:	0f b6       	in	r0, 0x3f	; 63
    17fe:	f8 94       	cli
    1800:	de bf       	out	0x3e, r29	; 62
    1802:	0f be       	out	0x3f, r0	; 63
    1804:	cd bf       	out	0x3d, r28	; 61
    1806:	cf 91       	pop	r28
    1808:	df 91       	pop	r29
    180a:	1f 91       	pop	r17
    180c:	0f 91       	pop	r16
    180e:	ff 90       	pop	r15
    1810:	ef 90       	pop	r14
    1812:	df 90       	pop	r13
    1814:	cf 90       	pop	r12
    1816:	08 95       	ret

00001818 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    1818:	cf 92       	push	r12
    181a:	df 92       	push	r13
    181c:	ef 92       	push	r14
    181e:	ff 92       	push	r15
    1820:	0f 93       	push	r16
    1822:	1f 93       	push	r17
    1824:	df 93       	push	r29
    1826:	cf 93       	push	r28
    1828:	cd b7       	in	r28, 0x3d	; 61
    182a:	de b7       	in	r29, 0x3e	; 62
    182c:	6d 97       	sbiw	r28, 0x1d	; 29
    182e:	0f b6       	in	r0, 0x3f	; 63
    1830:	f8 94       	cli
    1832:	de bf       	out	0x3e, r29	; 62
    1834:	0f be       	out	0x3f, r0	; 63
    1836:	cd bf       	out	0x3d, r28	; 61
    1838:	9b 8b       	std	Y+19, r25	; 0x13
    183a:	8a 8b       	std	Y+18, r24	; 0x12
    183c:	4c 8b       	std	Y+20, r20	; 0x14
    183e:	5d 8b       	std	Y+21, r21	; 0x15
    1840:	6e 8b       	std	Y+22, r22	; 0x16
    1842:	7f 8b       	std	Y+23, r23	; 0x17
    1844:	28 8f       	std	Y+24, r18	; 0x18
    1846:	09 8f       	std	Y+25, r16	; 0x19
    1848:	ca 8e       	std	Y+26, r12	; 0x1a
    184a:	db 8e       	std	Y+27, r13	; 0x1b
    184c:	ec 8e       	std	Y+28, r14	; 0x1c
    184e:	fd 8e       	std	Y+29, r15	; 0x1d
    EventGroup_t * pxEventBits = xEventGroup;
    1850:	8a 89       	ldd	r24, Y+18	; 0x12
    1852:	9b 89       	ldd	r25, Y+19	; 0x13
    1854:	99 8b       	std	Y+17, r25	; 0x11
    1856:	88 8b       	std	Y+16, r24	; 0x10
    EventBits_t uxReturn, uxControlBits = 0;
    1858:	18 86       	std	Y+8, r1	; 0x08
    185a:	19 86       	std	Y+9, r1	; 0x09
    185c:	1a 86       	std	Y+10, r1	; 0x0a
    185e:	1b 86       	std	Y+11, r1	; 0x0b
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1860:	1d 82       	std	Y+5, r1	; 0x05

    /* Check the user is not attempting to wait on the bits used by the kernel
     * itself, and that at least one bit is being requested. */
    configASSERT( xEventGroup );
    1862:	8a 89       	ldd	r24, Y+18	; 0x12
    1864:	9b 89       	ldd	r25, Y+19	; 0x13
    1866:	00 97       	sbiw	r24, 0x00	; 0
    1868:	11 f4       	brne	.+4      	; 0x186e <xEventGroupWaitBits+0x56>
    186a:	f8 94       	cli
    186c:	ff cf       	rjmp	.-2      	; 0x186c <xEventGroupWaitBits+0x54>
    configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    186e:	8c 89       	ldd	r24, Y+20	; 0x14
    1870:	9d 89       	ldd	r25, Y+21	; 0x15
    1872:	ae 89       	ldd	r26, Y+22	; 0x16
    1874:	bf 89       	ldd	r27, Y+23	; 0x17
    1876:	80 70       	andi	r24, 0x00	; 0
    1878:	90 70       	andi	r25, 0x00	; 0
    187a:	a0 70       	andi	r26, 0x00	; 0
    187c:	00 97       	sbiw	r24, 0x00	; 0
    187e:	a1 05       	cpc	r26, r1
    1880:	b1 05       	cpc	r27, r1
    1882:	11 f0       	breq	.+4      	; 0x1888 <xEventGroupWaitBits+0x70>
    1884:	f8 94       	cli
    1886:	ff cf       	rjmp	.-2      	; 0x1886 <xEventGroupWaitBits+0x6e>
    configASSERT( uxBitsToWaitFor != 0 );
    1888:	8c 89       	ldd	r24, Y+20	; 0x14
    188a:	9d 89       	ldd	r25, Y+21	; 0x15
    188c:	ae 89       	ldd	r26, Y+22	; 0x16
    188e:	bf 89       	ldd	r27, Y+23	; 0x17
    1890:	00 97       	sbiw	r24, 0x00	; 0
    1892:	a1 05       	cpc	r26, r1
    1894:	b1 05       	cpc	r27, r1
    1896:	11 f4       	brne	.+4      	; 0x189c <xEventGroupWaitBits+0x84>
    1898:	f8 94       	cli
    189a:	ff cf       	rjmp	.-2      	; 0x189a <xEventGroupWaitBits+0x82>
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
    189c:	0e 94 9a 1c 	call	0x3934	; 0x3934 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    18a0:	e8 89       	ldd	r30, Y+16	; 0x10
    18a2:	f9 89       	ldd	r31, Y+17	; 0x11
    18a4:	80 81       	ld	r24, Z
    18a6:	91 81       	ldd	r25, Z+1	; 0x01
    18a8:	a2 81       	ldd	r26, Z+2	; 0x02
    18aa:	b3 81       	ldd	r27, Z+3	; 0x03
    18ac:	89 83       	std	Y+1, r24	; 0x01
    18ae:	9a 83       	std	Y+2, r25	; 0x02
    18b0:	ab 83       	std	Y+3, r26	; 0x03
    18b2:	bc 83       	std	Y+4, r27	; 0x04

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    18b4:	89 81       	ldd	r24, Y+1	; 0x01
    18b6:	9a 81       	ldd	r25, Y+2	; 0x02
    18b8:	ab 81       	ldd	r26, Y+3	; 0x03
    18ba:	bc 81       	ldd	r27, Y+4	; 0x04
    18bc:	2c 89       	ldd	r18, Y+20	; 0x14
    18be:	3d 89       	ldd	r19, Y+21	; 0x15
    18c0:	4e 89       	ldd	r20, Y+22	; 0x16
    18c2:	5f 89       	ldd	r21, Y+23	; 0x17
    18c4:	bc 01       	movw	r22, r24
    18c6:	cd 01       	movw	r24, r26
    18c8:	09 8d       	ldd	r16, Y+25	; 0x19
    18ca:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <prvTestWaitCondition>
    18ce:	8f 83       	std	Y+7, r24	; 0x07

        if( xWaitConditionMet != pdFALSE )
    18d0:	8f 81       	ldd	r24, Y+7	; 0x07
    18d2:	88 23       	and	r24, r24
    18d4:	49 f1       	breq	.+82     	; 0x1928 <xEventGroupWaitBits+0x110>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    18d6:	89 81       	ldd	r24, Y+1	; 0x01
    18d8:	9a 81       	ldd	r25, Y+2	; 0x02
    18da:	ab 81       	ldd	r26, Y+3	; 0x03
    18dc:	bc 81       	ldd	r27, Y+4	; 0x04
    18de:	8c 87       	std	Y+12, r24	; 0x0c
    18e0:	9d 87       	std	Y+13, r25	; 0x0d
    18e2:	ae 87       	std	Y+14, r26	; 0x0e
    18e4:	bf 87       	std	Y+15, r27	; 0x0f
            xTicksToWait = ( TickType_t ) 0;
    18e6:	1a 8e       	std	Y+26, r1	; 0x1a
    18e8:	1b 8e       	std	Y+27, r1	; 0x1b
    18ea:	1c 8e       	std	Y+28, r1	; 0x1c
    18ec:	1d 8e       	std	Y+29, r1	; 0x1d

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    18ee:	88 8d       	ldd	r24, Y+24	; 0x18
    18f0:	88 23       	and	r24, r24
    18f2:	09 f4       	brne	.+2      	; 0x18f6 <xEventGroupWaitBits+0xde>
    18f4:	64 c0       	rjmp	.+200    	; 0x19be <xEventGroupWaitBits+0x1a6>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    18f6:	e8 89       	ldd	r30, Y+16	; 0x10
    18f8:	f9 89       	ldd	r31, Y+17	; 0x11
    18fa:	20 81       	ld	r18, Z
    18fc:	31 81       	ldd	r19, Z+1	; 0x01
    18fe:	42 81       	ldd	r20, Z+2	; 0x02
    1900:	53 81       	ldd	r21, Z+3	; 0x03
    1902:	8c 89       	ldd	r24, Y+20	; 0x14
    1904:	9d 89       	ldd	r25, Y+21	; 0x15
    1906:	ae 89       	ldd	r26, Y+22	; 0x16
    1908:	bf 89       	ldd	r27, Y+23	; 0x17
    190a:	80 95       	com	r24
    190c:	90 95       	com	r25
    190e:	a0 95       	com	r26
    1910:	b0 95       	com	r27
    1912:	82 23       	and	r24, r18
    1914:	93 23       	and	r25, r19
    1916:	a4 23       	and	r26, r20
    1918:	b5 23       	and	r27, r21
    191a:	e8 89       	ldd	r30, Y+16	; 0x10
    191c:	f9 89       	ldd	r31, Y+17	; 0x11
    191e:	80 83       	st	Z, r24
    1920:	91 83       	std	Z+1, r25	; 0x01
    1922:	a2 83       	std	Z+2, r26	; 0x02
    1924:	b3 83       	std	Z+3, r27	; 0x03
    1926:	4b c0       	rjmp	.+150    	; 0x19be <xEventGroupWaitBits+0x1a6>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    1928:	8a 8d       	ldd	r24, Y+26	; 0x1a
    192a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    192c:	ac 8d       	ldd	r26, Y+28	; 0x1c
    192e:	bd 8d       	ldd	r27, Y+29	; 0x1d
    1930:	00 97       	sbiw	r24, 0x00	; 0
    1932:	a1 05       	cpc	r26, r1
    1934:	b1 05       	cpc	r27, r1
    1936:	59 f4       	brne	.+22     	; 0x194e <xEventGroupWaitBits+0x136>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    1938:	89 81       	ldd	r24, Y+1	; 0x01
    193a:	9a 81       	ldd	r25, Y+2	; 0x02
    193c:	ab 81       	ldd	r26, Y+3	; 0x03
    193e:	bc 81       	ldd	r27, Y+4	; 0x04
    1940:	8c 87       	std	Y+12, r24	; 0x0c
    1942:	9d 87       	std	Y+13, r25	; 0x0d
    1944:	ae 87       	std	Y+14, r26	; 0x0e
    1946:	bf 87       	std	Y+15, r27	; 0x0f
            xTimeoutOccurred = pdTRUE;
    1948:	81 e0       	ldi	r24, 0x01	; 1
    194a:	8d 83       	std	Y+5, r24	; 0x05
    194c:	38 c0       	rjmp	.+112    	; 0x19be <xEventGroupWaitBits+0x1a6>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    194e:	88 8d       	ldd	r24, Y+24	; 0x18
    1950:	88 23       	and	r24, r24
    1952:	49 f0       	breq	.+18     	; 0x1966 <xEventGroupWaitBits+0x14e>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1954:	88 85       	ldd	r24, Y+8	; 0x08
    1956:	99 85       	ldd	r25, Y+9	; 0x09
    1958:	aa 85       	ldd	r26, Y+10	; 0x0a
    195a:	bb 85       	ldd	r27, Y+11	; 0x0b
    195c:	b1 60       	ori	r27, 0x01	; 1
    195e:	88 87       	std	Y+8, r24	; 0x08
    1960:	99 87       	std	Y+9, r25	; 0x09
    1962:	aa 87       	std	Y+10, r26	; 0x0a
    1964:	bb 87       	std	Y+11, r27	; 0x0b
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    1966:	89 8d       	ldd	r24, Y+25	; 0x19
    1968:	88 23       	and	r24, r24
    196a:	49 f0       	breq	.+18     	; 0x197e <xEventGroupWaitBits+0x166>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    196c:	88 85       	ldd	r24, Y+8	; 0x08
    196e:	99 85       	ldd	r25, Y+9	; 0x09
    1970:	aa 85       	ldd	r26, Y+10	; 0x0a
    1972:	bb 85       	ldd	r27, Y+11	; 0x0b
    1974:	b4 60       	ori	r27, 0x04	; 4
    1976:	88 87       	std	Y+8, r24	; 0x08
    1978:	99 87       	std	Y+9, r25	; 0x09
    197a:	aa 87       	std	Y+10, r26	; 0x0a
    197c:	bb 87       	std	Y+11, r27	; 0x0b
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    197e:	88 89       	ldd	r24, Y+16	; 0x10
    1980:	99 89       	ldd	r25, Y+17	; 0x11
    1982:	bc 01       	movw	r22, r24
    1984:	6c 5f       	subi	r22, 0xFC	; 252
    1986:	7f 4f       	sbci	r23, 0xFF	; 255
    1988:	2c 89       	ldd	r18, Y+20	; 0x14
    198a:	3d 89       	ldd	r19, Y+21	; 0x15
    198c:	4e 89       	ldd	r20, Y+22	; 0x16
    198e:	5f 89       	ldd	r21, Y+23	; 0x17
    1990:	88 85       	ldd	r24, Y+8	; 0x08
    1992:	99 85       	ldd	r25, Y+9	; 0x09
    1994:	aa 85       	ldd	r26, Y+10	; 0x0a
    1996:	bb 85       	ldd	r27, Y+11	; 0x0b
    1998:	28 2b       	or	r18, r24
    199a:	39 2b       	or	r19, r25
    199c:	4a 2b       	or	r20, r26
    199e:	5b 2b       	or	r21, r27
    19a0:	ea 8c       	ldd	r14, Y+26	; 0x1a
    19a2:	fb 8c       	ldd	r15, Y+27	; 0x1b
    19a4:	0c 8d       	ldd	r16, Y+28	; 0x1c
    19a6:	1d 8d       	ldd	r17, Y+29	; 0x1d
    19a8:	cb 01       	movw	r24, r22
    19aa:	ba 01       	movw	r22, r20
    19ac:	a9 01       	movw	r20, r18
    19ae:	98 01       	movw	r18, r16
    19b0:	87 01       	movw	r16, r14
    19b2:	0e 94 65 21 	call	0x42ca	; 0x42ca <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    19b6:	1c 86       	std	Y+12, r1	; 0x0c
    19b8:	1d 86       	std	Y+13, r1	; 0x0d
    19ba:	1e 86       	std	Y+14, r1	; 0x0e
    19bc:	1f 86       	std	Y+15, r1	; 0x0f

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    19be:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>
    19c2:	8e 83       	std	Y+6, r24	; 0x06

    if( xTicksToWait != ( TickType_t ) 0 )
    19c4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19c6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    19c8:	ac 8d       	ldd	r26, Y+28	; 0x1c
    19ca:	bd 8d       	ldd	r27, Y+29	; 0x1d
    19cc:	00 97       	sbiw	r24, 0x00	; 0
    19ce:	a1 05       	cpc	r26, r1
    19d0:	b1 05       	cpc	r27, r1
    19d2:	09 f4       	brne	.+2      	; 0x19d6 <xEventGroupWaitBits+0x1be>
    19d4:	5e c0       	rjmp	.+188    	; 0x1a92 <xEventGroupWaitBits+0x27a>
    {
        if( xAlreadyYielded == pdFALSE )
    19d6:	8e 81       	ldd	r24, Y+6	; 0x06
    19d8:	88 23       	and	r24, r24
    19da:	11 f4       	brne	.+4      	; 0x19e0 <xEventGroupWaitBits+0x1c8>
        {
            portYIELD_WITHIN_API();
    19dc:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    19e0:	0e 94 eb 25 	call	0x4bd6	; 0x4bd6 <uxTaskResetEventItemValue>
    19e4:	dc 01       	movw	r26, r24
    19e6:	cb 01       	movw	r24, r22
    19e8:	8c 87       	std	Y+12, r24	; 0x0c
    19ea:	9d 87       	std	Y+13, r25	; 0x0d
    19ec:	ae 87       	std	Y+14, r26	; 0x0e
    19ee:	bf 87       	std	Y+15, r27	; 0x0f

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    19f0:	8c 85       	ldd	r24, Y+12	; 0x0c
    19f2:	9d 85       	ldd	r25, Y+13	; 0x0d
    19f4:	ae 85       	ldd	r26, Y+14	; 0x0e
    19f6:	bf 85       	ldd	r27, Y+15	; 0x0f
    19f8:	80 70       	andi	r24, 0x00	; 0
    19fa:	90 70       	andi	r25, 0x00	; 0
    19fc:	a0 70       	andi	r26, 0x00	; 0
    19fe:	b2 70       	andi	r27, 0x02	; 2
    1a00:	00 97       	sbiw	r24, 0x00	; 0
    1a02:	a1 05       	cpc	r26, r1
    1a04:	b1 05       	cpc	r27, r1
    1a06:	09 f0       	breq	.+2      	; 0x1a0a <xEventGroupWaitBits+0x1f2>
    1a08:	3b c0       	rjmp	.+118    	; 0x1a80 <xEventGroupWaitBits+0x268>
        {
            taskENTER_CRITICAL();
    1a0a:	0f b6       	in	r0, 0x3f	; 63
    1a0c:	f8 94       	cli
    1a0e:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1a10:	e8 89       	ldd	r30, Y+16	; 0x10
    1a12:	f9 89       	ldd	r31, Y+17	; 0x11
    1a14:	80 81       	ld	r24, Z
    1a16:	91 81       	ldd	r25, Z+1	; 0x01
    1a18:	a2 81       	ldd	r26, Z+2	; 0x02
    1a1a:	b3 81       	ldd	r27, Z+3	; 0x03
    1a1c:	8c 87       	std	Y+12, r24	; 0x0c
    1a1e:	9d 87       	std	Y+13, r25	; 0x0d
    1a20:	ae 87       	std	Y+14, r26	; 0x0e
    1a22:	bf 87       	std	Y+15, r27	; 0x0f

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1a24:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a26:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a28:	ae 85       	ldd	r26, Y+14	; 0x0e
    1a2a:	bf 85       	ldd	r27, Y+15	; 0x0f
    1a2c:	2c 89       	ldd	r18, Y+20	; 0x14
    1a2e:	3d 89       	ldd	r19, Y+21	; 0x15
    1a30:	4e 89       	ldd	r20, Y+22	; 0x16
    1a32:	5f 89       	ldd	r21, Y+23	; 0x17
    1a34:	bc 01       	movw	r22, r24
    1a36:	cd 01       	movw	r24, r26
    1a38:	09 8d       	ldd	r16, Y+25	; 0x19
    1a3a:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <prvTestWaitCondition>
    1a3e:	88 23       	and	r24, r24
    1a40:	d9 f0       	breq	.+54     	; 0x1a78 <xEventGroupWaitBits+0x260>
                {
                    if( xClearOnExit != pdFALSE )
    1a42:	88 8d       	ldd	r24, Y+24	; 0x18
    1a44:	88 23       	and	r24, r24
    1a46:	c1 f0       	breq	.+48     	; 0x1a78 <xEventGroupWaitBits+0x260>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1a48:	e8 89       	ldd	r30, Y+16	; 0x10
    1a4a:	f9 89       	ldd	r31, Y+17	; 0x11
    1a4c:	20 81       	ld	r18, Z
    1a4e:	31 81       	ldd	r19, Z+1	; 0x01
    1a50:	42 81       	ldd	r20, Z+2	; 0x02
    1a52:	53 81       	ldd	r21, Z+3	; 0x03
    1a54:	8c 89       	ldd	r24, Y+20	; 0x14
    1a56:	9d 89       	ldd	r25, Y+21	; 0x15
    1a58:	ae 89       	ldd	r26, Y+22	; 0x16
    1a5a:	bf 89       	ldd	r27, Y+23	; 0x17
    1a5c:	80 95       	com	r24
    1a5e:	90 95       	com	r25
    1a60:	a0 95       	com	r26
    1a62:	b0 95       	com	r27
    1a64:	82 23       	and	r24, r18
    1a66:	93 23       	and	r25, r19
    1a68:	a4 23       	and	r26, r20
    1a6a:	b5 23       	and	r27, r21
    1a6c:	e8 89       	ldd	r30, Y+16	; 0x10
    1a6e:	f9 89       	ldd	r31, Y+17	; 0x11
    1a70:	80 83       	st	Z, r24
    1a72:	91 83       	std	Z+1, r25	; 0x01
    1a74:	a2 83       	std	Z+2, r26	; 0x02
    1a76:	b3 83       	std	Z+3, r27	; 0x03
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    1a78:	81 e0       	ldi	r24, 0x01	; 1
    1a7a:	8d 83       	std	Y+5, r24	; 0x05
            }
            taskEXIT_CRITICAL();
    1a7c:	0f 90       	pop	r0
    1a7e:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1a80:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a82:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a84:	ae 85       	ldd	r26, Y+14	; 0x0e
    1a86:	bf 85       	ldd	r27, Y+15	; 0x0f
    1a88:	b0 70       	andi	r27, 0x00	; 0
    1a8a:	8c 87       	std	Y+12, r24	; 0x0c
    1a8c:	9d 87       	std	Y+13, r25	; 0x0d
    1a8e:	ae 87       	std	Y+14, r26	; 0x0e
    1a90:	bf 87       	std	Y+15, r27	; 0x0f
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1a92:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a94:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a96:	ae 85       	ldd	r26, Y+14	; 0x0e
    1a98:	bf 85       	ldd	r27, Y+15	; 0x0f
}
    1a9a:	bc 01       	movw	r22, r24
    1a9c:	cd 01       	movw	r24, r26
    1a9e:	6d 96       	adiw	r28, 0x1d	; 29
    1aa0:	0f b6       	in	r0, 0x3f	; 63
    1aa2:	f8 94       	cli
    1aa4:	de bf       	out	0x3e, r29	; 62
    1aa6:	0f be       	out	0x3f, r0	; 63
    1aa8:	cd bf       	out	0x3d, r28	; 61
    1aaa:	cf 91       	pop	r28
    1aac:	df 91       	pop	r29
    1aae:	1f 91       	pop	r17
    1ab0:	0f 91       	pop	r16
    1ab2:	ff 90       	pop	r15
    1ab4:	ef 90       	pop	r14
    1ab6:	df 90       	pop	r13
    1ab8:	cf 90       	pop	r12
    1aba:	08 95       	ret

00001abc <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    1abc:	df 93       	push	r29
    1abe:	cf 93       	push	r28
    1ac0:	cd b7       	in	r28, 0x3d	; 61
    1ac2:	de b7       	in	r29, 0x3e	; 62
    1ac4:	2c 97       	sbiw	r28, 0x0c	; 12
    1ac6:	0f b6       	in	r0, 0x3f	; 63
    1ac8:	f8 94       	cli
    1aca:	de bf       	out	0x3e, r29	; 62
    1acc:	0f be       	out	0x3f, r0	; 63
    1ace:	cd bf       	out	0x3d, r28	; 61
    1ad0:	98 87       	std	Y+8, r25	; 0x08
    1ad2:	8f 83       	std	Y+7, r24	; 0x07
    1ad4:	49 87       	std	Y+9, r20	; 0x09
    1ad6:	5a 87       	std	Y+10, r21	; 0x0a
    1ad8:	6b 87       	std	Y+11, r22	; 0x0b
    1ada:	7c 87       	std	Y+12, r23	; 0x0c
    EventGroup_t * pxEventBits = xEventGroup;
    1adc:	8f 81       	ldd	r24, Y+7	; 0x07
    1ade:	98 85       	ldd	r25, Y+8	; 0x08
    1ae0:	9e 83       	std	Y+6, r25	; 0x06
    1ae2:	8d 83       	std	Y+5, r24	; 0x05
    EventBits_t uxReturn;

    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    1ae4:	8f 81       	ldd	r24, Y+7	; 0x07
    1ae6:	98 85       	ldd	r25, Y+8	; 0x08
    1ae8:	00 97       	sbiw	r24, 0x00	; 0
    1aea:	11 f4       	brne	.+4      	; 0x1af0 <xEventGroupClearBits+0x34>
    1aec:	f8 94       	cli
    1aee:	ff cf       	rjmp	.-2      	; 0x1aee <xEventGroupClearBits+0x32>
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    1af0:	89 85       	ldd	r24, Y+9	; 0x09
    1af2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1af4:	ab 85       	ldd	r26, Y+11	; 0x0b
    1af6:	bc 85       	ldd	r27, Y+12	; 0x0c
    1af8:	80 70       	andi	r24, 0x00	; 0
    1afa:	90 70       	andi	r25, 0x00	; 0
    1afc:	a0 70       	andi	r26, 0x00	; 0
    1afe:	00 97       	sbiw	r24, 0x00	; 0
    1b00:	a1 05       	cpc	r26, r1
    1b02:	b1 05       	cpc	r27, r1
    1b04:	11 f0       	breq	.+4      	; 0x1b0a <xEventGroupClearBits+0x4e>
    1b06:	f8 94       	cli
    1b08:	ff cf       	rjmp	.-2      	; 0x1b08 <xEventGroupClearBits+0x4c>

    taskENTER_CRITICAL();
    1b0a:	0f b6       	in	r0, 0x3f	; 63
    1b0c:	f8 94       	cli
    1b0e:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    1b10:	ed 81       	ldd	r30, Y+5	; 0x05
    1b12:	fe 81       	ldd	r31, Y+6	; 0x06
    1b14:	80 81       	ld	r24, Z
    1b16:	91 81       	ldd	r25, Z+1	; 0x01
    1b18:	a2 81       	ldd	r26, Z+2	; 0x02
    1b1a:	b3 81       	ldd	r27, Z+3	; 0x03
    1b1c:	89 83       	std	Y+1, r24	; 0x01
    1b1e:	9a 83       	std	Y+2, r25	; 0x02
    1b20:	ab 83       	std	Y+3, r26	; 0x03
    1b22:	bc 83       	std	Y+4, r27	; 0x04

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1b24:	ed 81       	ldd	r30, Y+5	; 0x05
    1b26:	fe 81       	ldd	r31, Y+6	; 0x06
    1b28:	20 81       	ld	r18, Z
    1b2a:	31 81       	ldd	r19, Z+1	; 0x01
    1b2c:	42 81       	ldd	r20, Z+2	; 0x02
    1b2e:	53 81       	ldd	r21, Z+3	; 0x03
    1b30:	89 85       	ldd	r24, Y+9	; 0x09
    1b32:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b34:	ab 85       	ldd	r26, Y+11	; 0x0b
    1b36:	bc 85       	ldd	r27, Y+12	; 0x0c
    1b38:	80 95       	com	r24
    1b3a:	90 95       	com	r25
    1b3c:	a0 95       	com	r26
    1b3e:	b0 95       	com	r27
    1b40:	82 23       	and	r24, r18
    1b42:	93 23       	and	r25, r19
    1b44:	a4 23       	and	r26, r20
    1b46:	b5 23       	and	r27, r21
    1b48:	ed 81       	ldd	r30, Y+5	; 0x05
    1b4a:	fe 81       	ldd	r31, Y+6	; 0x06
    1b4c:	80 83       	st	Z, r24
    1b4e:	91 83       	std	Z+1, r25	; 0x01
    1b50:	a2 83       	std	Z+2, r26	; 0x02
    1b52:	b3 83       	std	Z+3, r27	; 0x03
    }
    taskEXIT_CRITICAL();
    1b54:	0f 90       	pop	r0
    1b56:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    1b58:	89 81       	ldd	r24, Y+1	; 0x01
    1b5a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b5c:	ab 81       	ldd	r26, Y+3	; 0x03
    1b5e:	bc 81       	ldd	r27, Y+4	; 0x04
}
    1b60:	bc 01       	movw	r22, r24
    1b62:	cd 01       	movw	r24, r26
    1b64:	2c 96       	adiw	r28, 0x0c	; 12
    1b66:	0f b6       	in	r0, 0x3f	; 63
    1b68:	f8 94       	cli
    1b6a:	de bf       	out	0x3e, r29	; 62
    1b6c:	0f be       	out	0x3f, r0	; 63
    1b6e:	cd bf       	out	0x3d, r28	; 61
    1b70:	cf 91       	pop	r28
    1b72:	df 91       	pop	r29
    1b74:	08 95       	ret

00001b76 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1b76:	df 93       	push	r29
    1b78:	cf 93       	push	r28
    1b7a:	cd b7       	in	r28, 0x3d	; 61
    1b7c:	de b7       	in	r29, 0x3e	; 62
    1b7e:	29 97       	sbiw	r28, 0x09	; 9
    1b80:	0f b6       	in	r0, 0x3f	; 63
    1b82:	f8 94       	cli
    1b84:	de bf       	out	0x3e, r29	; 62
    1b86:	0f be       	out	0x3f, r0	; 63
    1b88:	cd bf       	out	0x3d, r28	; 61
    1b8a:	99 87       	std	Y+9, r25	; 0x09
    1b8c:	88 87       	std	Y+8, r24	; 0x08
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    1b8e:	88 85       	ldd	r24, Y+8	; 0x08
    1b90:	99 85       	ldd	r25, Y+9	; 0x09
    1b92:	9e 83       	std	Y+6, r25	; 0x06
    1b94:	8d 83       	std	Y+5, r24	; 0x05
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1b96:	1f 82       	std	Y+7, r1	; 0x07
    {
        uxReturn = pxEventBits->uxEventBits;
    1b98:	ed 81       	ldd	r30, Y+5	; 0x05
    1b9a:	fe 81       	ldd	r31, Y+6	; 0x06
    1b9c:	80 81       	ld	r24, Z
    1b9e:	91 81       	ldd	r25, Z+1	; 0x01
    1ba0:	a2 81       	ldd	r26, Z+2	; 0x02
    1ba2:	b3 81       	ldd	r27, Z+3	; 0x03
    1ba4:	89 83       	std	Y+1, r24	; 0x01
    1ba6:	9a 83       	std	Y+2, r25	; 0x02
    1ba8:	ab 83       	std	Y+3, r26	; 0x03
    1baa:	bc 83       	std	Y+4, r27	; 0x04
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    1bac:	89 81       	ldd	r24, Y+1	; 0x01
    1bae:	9a 81       	ldd	r25, Y+2	; 0x02
    1bb0:	ab 81       	ldd	r26, Y+3	; 0x03
    1bb2:	bc 81       	ldd	r27, Y+4	; 0x04
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1bb4:	bc 01       	movw	r22, r24
    1bb6:	cd 01       	movw	r24, r26
    1bb8:	29 96       	adiw	r28, 0x09	; 9
    1bba:	0f b6       	in	r0, 0x3f	; 63
    1bbc:	f8 94       	cli
    1bbe:	de bf       	out	0x3e, r29	; 62
    1bc0:	0f be       	out	0x3f, r0	; 63
    1bc2:	cd bf       	out	0x3d, r28	; 61
    1bc4:	cf 91       	pop	r28
    1bc6:	df 91       	pop	r29
    1bc8:	08 95       	ret

00001bca <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    1bca:	df 93       	push	r29
    1bcc:	cf 93       	push	r28
    1bce:	cd b7       	in	r28, 0x3d	; 61
    1bd0:	de b7       	in	r29, 0x3e	; 62
    1bd2:	6d 97       	sbiw	r28, 0x1d	; 29
    1bd4:	0f b6       	in	r0, 0x3f	; 63
    1bd6:	f8 94       	cli
    1bd8:	de bf       	out	0x3e, r29	; 62
    1bda:	0f be       	out	0x3f, r0	; 63
    1bdc:	cd bf       	out	0x3d, r28	; 61
    1bde:	99 8f       	std	Y+25, r25	; 0x19
    1be0:	88 8f       	std	Y+24, r24	; 0x18
    1be2:	4a 8f       	std	Y+26, r20	; 0x1a
    1be4:	5b 8f       	std	Y+27, r21	; 0x1b
    1be6:	6c 8f       	std	Y+28, r22	; 0x1c
    1be8:	7d 8f       	std	Y+29, r23	; 0x1d
    ListItem_t * pxListItem;
    ListItem_t * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1bea:	1c 86       	std	Y+12, r1	; 0x0c
    1bec:	1d 86       	std	Y+13, r1	; 0x0d
    1bee:	1e 86       	std	Y+14, r1	; 0x0e
    1bf0:	1f 86       	std	Y+15, r1	; 0x0f
    EventGroup_t * pxEventBits = xEventGroup;
    1bf2:	88 8d       	ldd	r24, Y+24	; 0x18
    1bf4:	99 8d       	ldd	r25, Y+25	; 0x19
    1bf6:	9b 83       	std	Y+3, r25	; 0x03
    1bf8:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    1bfa:	19 82       	std	Y+1, r1	; 0x01

    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    1bfc:	88 8d       	ldd	r24, Y+24	; 0x18
    1bfe:	99 8d       	ldd	r25, Y+25	; 0x19
    1c00:	00 97       	sbiw	r24, 0x00	; 0
    1c02:	11 f4       	brne	.+4      	; 0x1c08 <xEventGroupSetBits+0x3e>
    1c04:	f8 94       	cli
    1c06:	ff cf       	rjmp	.-2      	; 0x1c06 <xEventGroupSetBits+0x3c>
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    1c08:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c0a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1c0c:	ac 8d       	ldd	r26, Y+28	; 0x1c
    1c0e:	bd 8d       	ldd	r27, Y+29	; 0x1d
    1c10:	80 70       	andi	r24, 0x00	; 0
    1c12:	90 70       	andi	r25, 0x00	; 0
    1c14:	a0 70       	andi	r26, 0x00	; 0
    1c16:	00 97       	sbiw	r24, 0x00	; 0
    1c18:	a1 05       	cpc	r26, r1
    1c1a:	b1 05       	cpc	r27, r1
    1c1c:	11 f0       	breq	.+4      	; 0x1c22 <xEventGroupSetBits+0x58>
    1c1e:	f8 94       	cli
    1c20:	ff cf       	rjmp	.-2      	; 0x1c20 <xEventGroupSetBits+0x56>

    pxList = &( pxEventBits->xTasksWaitingForBits );
    1c22:	8a 81       	ldd	r24, Y+2	; 0x02
    1c24:	9b 81       	ldd	r25, Y+3	; 0x03
    1c26:	04 96       	adiw	r24, 0x04	; 4
    1c28:	99 8b       	std	Y+17, r25	; 0x11
    1c2a:	88 8b       	std	Y+16, r24	; 0x10
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c2c:	88 89       	ldd	r24, Y+16	; 0x10
    1c2e:	99 89       	ldd	r25, Y+17	; 0x11
    1c30:	03 96       	adiw	r24, 0x03	; 3
    1c32:	9b 8b       	std	Y+19, r25	; 0x13
    1c34:	8a 8b       	std	Y+18, r24	; 0x12
    vTaskSuspendAll();
    1c36:	0e 94 9a 1c 	call	0x3934	; 0x3934 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    1c3a:	e8 89       	ldd	r30, Y+16	; 0x10
    1c3c:	f9 89       	ldd	r31, Y+17	; 0x11
    1c3e:	87 81       	ldd	r24, Z+7	; 0x07
    1c40:	90 85       	ldd	r25, Z+8	; 0x08
    1c42:	9f 8b       	std	Y+23, r25	; 0x17
    1c44:	8e 8b       	std	Y+22, r24	; 0x16

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    1c46:	ea 81       	ldd	r30, Y+2	; 0x02
    1c48:	fb 81       	ldd	r31, Y+3	; 0x03
    1c4a:	20 81       	ld	r18, Z
    1c4c:	31 81       	ldd	r19, Z+1	; 0x01
    1c4e:	42 81       	ldd	r20, Z+2	; 0x02
    1c50:	53 81       	ldd	r21, Z+3	; 0x03
    1c52:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c54:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1c56:	ac 8d       	ldd	r26, Y+28	; 0x1c
    1c58:	bd 8d       	ldd	r27, Y+29	; 0x1d
    1c5a:	82 2b       	or	r24, r18
    1c5c:	93 2b       	or	r25, r19
    1c5e:	a4 2b       	or	r26, r20
    1c60:	b5 2b       	or	r27, r21
    1c62:	ea 81       	ldd	r30, Y+2	; 0x02
    1c64:	fb 81       	ldd	r31, Y+3	; 0x03
    1c66:	80 83       	st	Z, r24
    1c68:	91 83       	std	Z+1, r25	; 0x01
    1c6a:	a2 83       	std	Z+2, r26	; 0x02
    1c6c:	b3 83       	std	Z+3, r27	; 0x03
    1c6e:	91 c0       	rjmp	.+290    	; 0x1d92 <xEventGroupSetBits+0x1c8>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    1c70:	ee 89       	ldd	r30, Y+22	; 0x16
    1c72:	ff 89       	ldd	r31, Y+23	; 0x17
    1c74:	84 81       	ldd	r24, Z+4	; 0x04
    1c76:	95 81       	ldd	r25, Z+5	; 0x05
    1c78:	9d 8b       	std	Y+21, r25	; 0x15
    1c7a:	8c 8b       	std	Y+20, r24	; 0x14
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1c7c:	ee 89       	ldd	r30, Y+22	; 0x16
    1c7e:	ff 89       	ldd	r31, Y+23	; 0x17
    1c80:	80 81       	ld	r24, Z
    1c82:	91 81       	ldd	r25, Z+1	; 0x01
    1c84:	a2 81       	ldd	r26, Z+2	; 0x02
    1c86:	b3 81       	ldd	r27, Z+3	; 0x03
    1c88:	88 87       	std	Y+8, r24	; 0x08
    1c8a:	99 87       	std	Y+9, r25	; 0x09
    1c8c:	aa 87       	std	Y+10, r26	; 0x0a
    1c8e:	bb 87       	std	Y+11, r27	; 0x0b
            xMatchFound = pdFALSE;
    1c90:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1c92:	88 85       	ldd	r24, Y+8	; 0x08
    1c94:	99 85       	ldd	r25, Y+9	; 0x09
    1c96:	aa 85       	ldd	r26, Y+10	; 0x0a
    1c98:	bb 85       	ldd	r27, Y+11	; 0x0b
    1c9a:	80 70       	andi	r24, 0x00	; 0
    1c9c:	90 70       	andi	r25, 0x00	; 0
    1c9e:	a0 70       	andi	r26, 0x00	; 0
    1ca0:	8c 83       	std	Y+4, r24	; 0x04
    1ca2:	9d 83       	std	Y+5, r25	; 0x05
    1ca4:	ae 83       	std	Y+6, r26	; 0x06
    1ca6:	bf 83       	std	Y+7, r27	; 0x07
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1ca8:	88 85       	ldd	r24, Y+8	; 0x08
    1caa:	99 85       	ldd	r25, Y+9	; 0x09
    1cac:	aa 85       	ldd	r26, Y+10	; 0x0a
    1cae:	bb 85       	ldd	r27, Y+11	; 0x0b
    1cb0:	b0 70       	andi	r27, 0x00	; 0
    1cb2:	88 87       	std	Y+8, r24	; 0x08
    1cb4:	99 87       	std	Y+9, r25	; 0x09
    1cb6:	aa 87       	std	Y+10, r26	; 0x0a
    1cb8:	bb 87       	std	Y+11, r27	; 0x0b

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1cba:	8c 81       	ldd	r24, Y+4	; 0x04
    1cbc:	9d 81       	ldd	r25, Y+5	; 0x05
    1cbe:	ae 81       	ldd	r26, Y+6	; 0x06
    1cc0:	bf 81       	ldd	r27, Y+7	; 0x07
    1cc2:	80 70       	andi	r24, 0x00	; 0
    1cc4:	90 70       	andi	r25, 0x00	; 0
    1cc6:	a0 70       	andi	r26, 0x00	; 0
    1cc8:	b4 70       	andi	r27, 0x04	; 4
    1cca:	00 97       	sbiw	r24, 0x00	; 0
    1ccc:	a1 05       	cpc	r26, r1
    1cce:	b1 05       	cpc	r27, r1
    1cd0:	a9 f4       	brne	.+42     	; 0x1cfc <xEventGroupSetBits+0x132>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1cd2:	ea 81       	ldd	r30, Y+2	; 0x02
    1cd4:	fb 81       	ldd	r31, Y+3	; 0x03
    1cd6:	20 81       	ld	r18, Z
    1cd8:	31 81       	ldd	r19, Z+1	; 0x01
    1cda:	42 81       	ldd	r20, Z+2	; 0x02
    1cdc:	53 81       	ldd	r21, Z+3	; 0x03
    1cde:	88 85       	ldd	r24, Y+8	; 0x08
    1ce0:	99 85       	ldd	r25, Y+9	; 0x09
    1ce2:	aa 85       	ldd	r26, Y+10	; 0x0a
    1ce4:	bb 85       	ldd	r27, Y+11	; 0x0b
    1ce6:	82 23       	and	r24, r18
    1ce8:	93 23       	and	r25, r19
    1cea:	a4 23       	and	r26, r20
    1cec:	b5 23       	and	r27, r21
    1cee:	00 97       	sbiw	r24, 0x00	; 0
    1cf0:	a1 05       	cpc	r26, r1
    1cf2:	b1 05       	cpc	r27, r1
    1cf4:	e1 f0       	breq	.+56     	; 0x1d2e <xEventGroupSetBits+0x164>
                {
                    xMatchFound = pdTRUE;
    1cf6:	81 e0       	ldi	r24, 0x01	; 1
    1cf8:	89 83       	std	Y+1, r24	; 0x01
    1cfa:	19 c0       	rjmp	.+50     	; 0x1d2e <xEventGroupSetBits+0x164>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1cfc:	ea 81       	ldd	r30, Y+2	; 0x02
    1cfe:	fb 81       	ldd	r31, Y+3	; 0x03
    1d00:	20 81       	ld	r18, Z
    1d02:	31 81       	ldd	r19, Z+1	; 0x01
    1d04:	42 81       	ldd	r20, Z+2	; 0x02
    1d06:	53 81       	ldd	r21, Z+3	; 0x03
    1d08:	88 85       	ldd	r24, Y+8	; 0x08
    1d0a:	99 85       	ldd	r25, Y+9	; 0x09
    1d0c:	aa 85       	ldd	r26, Y+10	; 0x0a
    1d0e:	bb 85       	ldd	r27, Y+11	; 0x0b
    1d10:	28 23       	and	r18, r24
    1d12:	39 23       	and	r19, r25
    1d14:	4a 23       	and	r20, r26
    1d16:	5b 23       	and	r21, r27
    1d18:	88 85       	ldd	r24, Y+8	; 0x08
    1d1a:	99 85       	ldd	r25, Y+9	; 0x09
    1d1c:	aa 85       	ldd	r26, Y+10	; 0x0a
    1d1e:	bb 85       	ldd	r27, Y+11	; 0x0b
    1d20:	28 17       	cp	r18, r24
    1d22:	39 07       	cpc	r19, r25
    1d24:	4a 07       	cpc	r20, r26
    1d26:	5b 07       	cpc	r21, r27
    1d28:	11 f4       	brne	.+4      	; 0x1d2e <xEventGroupSetBits+0x164>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    1d2a:	81 e0       	ldi	r24, 0x01	; 1
    1d2c:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    1d2e:	89 81       	ldd	r24, Y+1	; 0x01
    1d30:	88 23       	and	r24, r24
    1d32:	59 f1       	breq	.+86     	; 0x1d8a <xEventGroupSetBits+0x1c0>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1d34:	8c 81       	ldd	r24, Y+4	; 0x04
    1d36:	9d 81       	ldd	r25, Y+5	; 0x05
    1d38:	ae 81       	ldd	r26, Y+6	; 0x06
    1d3a:	bf 81       	ldd	r27, Y+7	; 0x07
    1d3c:	80 70       	andi	r24, 0x00	; 0
    1d3e:	90 70       	andi	r25, 0x00	; 0
    1d40:	a0 70       	andi	r26, 0x00	; 0
    1d42:	b1 70       	andi	r27, 0x01	; 1
    1d44:	00 97       	sbiw	r24, 0x00	; 0
    1d46:	a1 05       	cpc	r26, r1
    1d48:	b1 05       	cpc	r27, r1
    1d4a:	81 f0       	breq	.+32     	; 0x1d6c <xEventGroupSetBits+0x1a2>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    1d4c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1d4e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1d50:	ae 85       	ldd	r26, Y+14	; 0x0e
    1d52:	bf 85       	ldd	r27, Y+15	; 0x0f
    1d54:	28 85       	ldd	r18, Y+8	; 0x08
    1d56:	39 85       	ldd	r19, Y+9	; 0x09
    1d58:	4a 85       	ldd	r20, Y+10	; 0x0a
    1d5a:	5b 85       	ldd	r21, Y+11	; 0x0b
    1d5c:	82 2b       	or	r24, r18
    1d5e:	93 2b       	or	r25, r19
    1d60:	a4 2b       	or	r26, r20
    1d62:	b5 2b       	or	r27, r21
    1d64:	8c 87       	std	Y+12, r24	; 0x0c
    1d66:	9d 87       	std	Y+13, r25	; 0x0d
    1d68:	ae 87       	std	Y+14, r26	; 0x0e
    1d6a:	bf 87       	std	Y+15, r27	; 0x0f
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1d6c:	ea 81       	ldd	r30, Y+2	; 0x02
    1d6e:	fb 81       	ldd	r31, Y+3	; 0x03
    1d70:	80 81       	ld	r24, Z
    1d72:	91 81       	ldd	r25, Z+1	; 0x01
    1d74:	a2 81       	ldd	r26, Z+2	; 0x02
    1d76:	b3 81       	ldd	r27, Z+3	; 0x03
    1d78:	9c 01       	movw	r18, r24
    1d7a:	ad 01       	movw	r20, r26
    1d7c:	52 60       	ori	r21, 0x02	; 2
    1d7e:	8e 89       	ldd	r24, Y+22	; 0x16
    1d80:	9f 89       	ldd	r25, Y+23	; 0x17
    1d82:	ba 01       	movw	r22, r20
    1d84:	a9 01       	movw	r20, r18
    1d86:	0e 94 39 23 	call	0x4672	; 0x4672 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    1d8a:	8c 89       	ldd	r24, Y+20	; 0x14
    1d8c:	9d 89       	ldd	r25, Y+21	; 0x15
    1d8e:	9f 8b       	std	Y+23, r25	; 0x17
    1d90:	8e 8b       	std	Y+22, r24	; 0x16

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    1d92:	2e 89       	ldd	r18, Y+22	; 0x16
    1d94:	3f 89       	ldd	r19, Y+23	; 0x17
    1d96:	8a 89       	ldd	r24, Y+18	; 0x12
    1d98:	9b 89       	ldd	r25, Y+19	; 0x13
    1d9a:	28 17       	cp	r18, r24
    1d9c:	39 07       	cpc	r19, r25
    1d9e:	09 f0       	breq	.+2      	; 0x1da2 <xEventGroupSetBits+0x1d8>
    1da0:	67 cf       	rjmp	.-306    	; 0x1c70 <xEventGroupSetBits+0xa6>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1da2:	ea 81       	ldd	r30, Y+2	; 0x02
    1da4:	fb 81       	ldd	r31, Y+3	; 0x03
    1da6:	20 81       	ld	r18, Z
    1da8:	31 81       	ldd	r19, Z+1	; 0x01
    1daa:	42 81       	ldd	r20, Z+2	; 0x02
    1dac:	53 81       	ldd	r21, Z+3	; 0x03
    1dae:	8c 85       	ldd	r24, Y+12	; 0x0c
    1db0:	9d 85       	ldd	r25, Y+13	; 0x0d
    1db2:	ae 85       	ldd	r26, Y+14	; 0x0e
    1db4:	bf 85       	ldd	r27, Y+15	; 0x0f
    1db6:	80 95       	com	r24
    1db8:	90 95       	com	r25
    1dba:	a0 95       	com	r26
    1dbc:	b0 95       	com	r27
    1dbe:	82 23       	and	r24, r18
    1dc0:	93 23       	and	r25, r19
    1dc2:	a4 23       	and	r26, r20
    1dc4:	b5 23       	and	r27, r21
    1dc6:	ea 81       	ldd	r30, Y+2	; 0x02
    1dc8:	fb 81       	ldd	r31, Y+3	; 0x03
    1dca:	80 83       	st	Z, r24
    1dcc:	91 83       	std	Z+1, r25	; 0x01
    1dce:	a2 83       	std	Z+2, r26	; 0x02
    1dd0:	b3 83       	std	Z+3, r27	; 0x03
    }
    ( void ) xTaskResumeAll();
    1dd2:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    1dd6:	ea 81       	ldd	r30, Y+2	; 0x02
    1dd8:	fb 81       	ldd	r31, Y+3	; 0x03
    1dda:	80 81       	ld	r24, Z
    1ddc:	91 81       	ldd	r25, Z+1	; 0x01
    1dde:	a2 81       	ldd	r26, Z+2	; 0x02
    1de0:	b3 81       	ldd	r27, Z+3	; 0x03
}
    1de2:	bc 01       	movw	r22, r24
    1de4:	cd 01       	movw	r24, r26
    1de6:	6d 96       	adiw	r28, 0x1d	; 29
    1de8:	0f b6       	in	r0, 0x3f	; 63
    1dea:	f8 94       	cli
    1dec:	de bf       	out	0x3e, r29	; 62
    1dee:	0f be       	out	0x3f, r0	; 63
    1df0:	cd bf       	out	0x3d, r28	; 61
    1df2:	cf 91       	pop	r28
    1df4:	df 91       	pop	r29
    1df6:	08 95       	ret

00001df8 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1df8:	df 93       	push	r29
    1dfa:	cf 93       	push	r28
    1dfc:	00 d0       	rcall	.+0      	; 0x1dfe <vEventGroupDelete+0x6>
    1dfe:	00 d0       	rcall	.+0      	; 0x1e00 <vEventGroupDelete+0x8>
    1e00:	00 d0       	rcall	.+0      	; 0x1e02 <vEventGroupDelete+0xa>
    1e02:	cd b7       	in	r28, 0x3d	; 61
    1e04:	de b7       	in	r29, 0x3e	; 62
    1e06:	9e 83       	std	Y+6, r25	; 0x06
    1e08:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    1e0a:	8d 81       	ldd	r24, Y+5	; 0x05
    1e0c:	9e 81       	ldd	r25, Y+6	; 0x06
    1e0e:	9c 83       	std	Y+4, r25	; 0x04
    1e10:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );
    1e12:	8b 81       	ldd	r24, Y+3	; 0x03
    1e14:	9c 81       	ldd	r25, Y+4	; 0x04
    1e16:	00 97       	sbiw	r24, 0x00	; 0
    1e18:	11 f4       	brne	.+4      	; 0x1e1e <vEventGroupDelete+0x26>
    1e1a:	f8 94       	cli
    1e1c:	ff cf       	rjmp	.-2      	; 0x1e1c <vEventGroupDelete+0x24>

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1e1e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e20:	9c 81       	ldd	r25, Y+4	; 0x04
    1e22:	04 96       	adiw	r24, 0x04	; 4
    1e24:	9a 83       	std	Y+2, r25	; 0x02
    1e26:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    1e28:	0e 94 9a 1c 	call	0x3934	; 0x3934 <vTaskSuspendAll>
    1e2c:	16 c0       	rjmp	.+44     	; 0x1e5a <vEventGroupDelete+0x62>

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
    1e2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e30:	fa 81       	ldd	r31, Y+2	; 0x02
    1e32:	27 81       	ldd	r18, Z+7	; 0x07
    1e34:	30 85       	ldd	r19, Z+8	; 0x08
    1e36:	89 81       	ldd	r24, Y+1	; 0x01
    1e38:	9a 81       	ldd	r25, Y+2	; 0x02
    1e3a:	03 96       	adiw	r24, 0x03	; 3
    1e3c:	28 17       	cp	r18, r24
    1e3e:	39 07       	cpc	r19, r25
    1e40:	11 f4       	brne	.+4      	; 0x1e46 <vEventGroupDelete+0x4e>
    1e42:	f8 94       	cli
    1e44:	ff cf       	rjmp	.-2      	; 0x1e44 <vEventGroupDelete+0x4c>
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1e46:	e9 81       	ldd	r30, Y+1	; 0x01
    1e48:	fa 81       	ldd	r31, Y+2	; 0x02
    1e4a:	87 81       	ldd	r24, Z+7	; 0x07
    1e4c:	90 85       	ldd	r25, Z+8	; 0x08
    1e4e:	40 e0       	ldi	r20, 0x00	; 0
    1e50:	50 e0       	ldi	r21, 0x00	; 0
    1e52:	60 e0       	ldi	r22, 0x00	; 0
    1e54:	72 e0       	ldi	r23, 0x02	; 2
    1e56:	0e 94 39 23 	call	0x4672	; 0x4672 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1e5a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e5c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e5e:	80 81       	ld	r24, Z
    1e60:	88 23       	and	r24, r24
    1e62:	29 f7       	brne	.-54     	; 0x1e2e <vEventGroupDelete+0x36>
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
        }
    }
    ( void ) xTaskResumeAll();
    1e64:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
    1e68:	8b 81       	ldd	r24, Y+3	; 0x03
    1e6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e6c:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1e70:	26 96       	adiw	r28, 0x06	; 6
    1e72:	0f b6       	in	r0, 0x3f	; 63
    1e74:	f8 94       	cli
    1e76:	de bf       	out	0x3e, r29	; 62
    1e78:	0f be       	out	0x3f, r0	; 63
    1e7a:	cd bf       	out	0x3d, r28	; 61
    1e7c:	cf 91       	pop	r28
    1e7e:	df 91       	pop	r29
    1e80:	08 95       	ret

00001e82 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    1e82:	df 93       	push	r29
    1e84:	cf 93       	push	r28
    1e86:	00 d0       	rcall	.+0      	; 0x1e88 <vEventGroupSetBitsCallback+0x6>
    1e88:	00 d0       	rcall	.+0      	; 0x1e8a <vEventGroupSetBitsCallback+0x8>
    1e8a:	00 d0       	rcall	.+0      	; 0x1e8c <vEventGroupSetBitsCallback+0xa>
    1e8c:	cd b7       	in	r28, 0x3d	; 61
    1e8e:	de b7       	in	r29, 0x3e	; 62
    1e90:	9a 83       	std	Y+2, r25	; 0x02
    1e92:	89 83       	std	Y+1, r24	; 0x01
    1e94:	4b 83       	std	Y+3, r20	; 0x03
    1e96:	5c 83       	std	Y+4, r21	; 0x04
    1e98:	6d 83       	std	Y+5, r22	; 0x05
    1e9a:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1e9c:	89 81       	ldd	r24, Y+1	; 0x01
    1e9e:	9a 81       	ldd	r25, Y+2	; 0x02
    1ea0:	2b 81       	ldd	r18, Y+3	; 0x03
    1ea2:	3c 81       	ldd	r19, Y+4	; 0x04
    1ea4:	4d 81       	ldd	r20, Y+5	; 0x05
    1ea6:	5e 81       	ldd	r21, Y+6	; 0x06
    1ea8:	ba 01       	movw	r22, r20
    1eaa:	a9 01       	movw	r20, r18
    1eac:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <xEventGroupSetBits>
}
    1eb0:	26 96       	adiw	r28, 0x06	; 6
    1eb2:	0f b6       	in	r0, 0x3f	; 63
    1eb4:	f8 94       	cli
    1eb6:	de bf       	out	0x3e, r29	; 62
    1eb8:	0f be       	out	0x3f, r0	; 63
    1eba:	cd bf       	out	0x3d, r28	; 61
    1ebc:	cf 91       	pop	r28
    1ebe:	df 91       	pop	r29
    1ec0:	08 95       	ret

00001ec2 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    1ec2:	df 93       	push	r29
    1ec4:	cf 93       	push	r28
    1ec6:	00 d0       	rcall	.+0      	; 0x1ec8 <vEventGroupClearBitsCallback+0x6>
    1ec8:	00 d0       	rcall	.+0      	; 0x1eca <vEventGroupClearBitsCallback+0x8>
    1eca:	00 d0       	rcall	.+0      	; 0x1ecc <vEventGroupClearBitsCallback+0xa>
    1ecc:	cd b7       	in	r28, 0x3d	; 61
    1ece:	de b7       	in	r29, 0x3e	; 62
    1ed0:	9a 83       	std	Y+2, r25	; 0x02
    1ed2:	89 83       	std	Y+1, r24	; 0x01
    1ed4:	4b 83       	std	Y+3, r20	; 0x03
    1ed6:	5c 83       	std	Y+4, r21	; 0x04
    1ed8:	6d 83       	std	Y+5, r22	; 0x05
    1eda:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1edc:	89 81       	ldd	r24, Y+1	; 0x01
    1ede:	9a 81       	ldd	r25, Y+2	; 0x02
    1ee0:	2b 81       	ldd	r18, Y+3	; 0x03
    1ee2:	3c 81       	ldd	r19, Y+4	; 0x04
    1ee4:	4d 81       	ldd	r20, Y+5	; 0x05
    1ee6:	5e 81       	ldd	r21, Y+6	; 0x06
    1ee8:	ba 01       	movw	r22, r20
    1eea:	a9 01       	movw	r20, r18
    1eec:	0e 94 5e 0d 	call	0x1abc	; 0x1abc <xEventGroupClearBits>
}
    1ef0:	26 96       	adiw	r28, 0x06	; 6
    1ef2:	0f b6       	in	r0, 0x3f	; 63
    1ef4:	f8 94       	cli
    1ef6:	de bf       	out	0x3e, r29	; 62
    1ef8:	0f be       	out	0x3f, r0	; 63
    1efa:	cd bf       	out	0x3d, r28	; 61
    1efc:	cf 91       	pop	r28
    1efe:	df 91       	pop	r29
    1f00:	08 95       	ret

00001f02 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    1f02:	0f 93       	push	r16
    1f04:	df 93       	push	r29
    1f06:	cf 93       	push	r28
    1f08:	cd b7       	in	r28, 0x3d	; 61
    1f0a:	de b7       	in	r29, 0x3e	; 62
    1f0c:	2a 97       	sbiw	r28, 0x0a	; 10
    1f0e:	0f b6       	in	r0, 0x3f	; 63
    1f10:	f8 94       	cli
    1f12:	de bf       	out	0x3e, r29	; 62
    1f14:	0f be       	out	0x3f, r0	; 63
    1f16:	cd bf       	out	0x3d, r28	; 61
    1f18:	6a 83       	std	Y+2, r22	; 0x02
    1f1a:	7b 83       	std	Y+3, r23	; 0x03
    1f1c:	8c 83       	std	Y+4, r24	; 0x04
    1f1e:	9d 83       	std	Y+5, r25	; 0x05
    1f20:	2e 83       	std	Y+6, r18	; 0x06
    1f22:	3f 83       	std	Y+7, r19	; 0x07
    1f24:	48 87       	std	Y+8, r20	; 0x08
    1f26:	59 87       	std	Y+9, r21	; 0x09
    1f28:	0a 87       	std	Y+10, r16	; 0x0a
    BaseType_t xWaitConditionMet = pdFALSE;
    1f2a:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    1f2c:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f2e:	88 23       	and	r24, r24
    1f30:	99 f4       	brne	.+38     	; 0x1f58 <prvTestWaitCondition+0x56>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1f32:	8a 81       	ldd	r24, Y+2	; 0x02
    1f34:	9b 81       	ldd	r25, Y+3	; 0x03
    1f36:	ac 81       	ldd	r26, Y+4	; 0x04
    1f38:	bd 81       	ldd	r27, Y+5	; 0x05
    1f3a:	2e 81       	ldd	r18, Y+6	; 0x06
    1f3c:	3f 81       	ldd	r19, Y+7	; 0x07
    1f3e:	48 85       	ldd	r20, Y+8	; 0x08
    1f40:	59 85       	ldd	r21, Y+9	; 0x09
    1f42:	82 23       	and	r24, r18
    1f44:	93 23       	and	r25, r19
    1f46:	a4 23       	and	r26, r20
    1f48:	b5 23       	and	r27, r21
    1f4a:	00 97       	sbiw	r24, 0x00	; 0
    1f4c:	a1 05       	cpc	r26, r1
    1f4e:	b1 05       	cpc	r27, r1
    1f50:	d1 f0       	breq	.+52     	; 0x1f86 <prvTestWaitCondition+0x84>
        {
            xWaitConditionMet = pdTRUE;
    1f52:	81 e0       	ldi	r24, 0x01	; 1
    1f54:	89 83       	std	Y+1, r24	; 0x01
    1f56:	17 c0       	rjmp	.+46     	; 0x1f86 <prvTestWaitCondition+0x84>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1f58:	2a 81       	ldd	r18, Y+2	; 0x02
    1f5a:	3b 81       	ldd	r19, Y+3	; 0x03
    1f5c:	4c 81       	ldd	r20, Y+4	; 0x04
    1f5e:	5d 81       	ldd	r21, Y+5	; 0x05
    1f60:	8e 81       	ldd	r24, Y+6	; 0x06
    1f62:	9f 81       	ldd	r25, Y+7	; 0x07
    1f64:	a8 85       	ldd	r26, Y+8	; 0x08
    1f66:	b9 85       	ldd	r27, Y+9	; 0x09
    1f68:	28 23       	and	r18, r24
    1f6a:	39 23       	and	r19, r25
    1f6c:	4a 23       	and	r20, r26
    1f6e:	5b 23       	and	r21, r27
    1f70:	8e 81       	ldd	r24, Y+6	; 0x06
    1f72:	9f 81       	ldd	r25, Y+7	; 0x07
    1f74:	a8 85       	ldd	r26, Y+8	; 0x08
    1f76:	b9 85       	ldd	r27, Y+9	; 0x09
    1f78:	28 17       	cp	r18, r24
    1f7a:	39 07       	cpc	r19, r25
    1f7c:	4a 07       	cpc	r20, r26
    1f7e:	5b 07       	cpc	r21, r27
    1f80:	11 f4       	brne	.+4      	; 0x1f86 <prvTestWaitCondition+0x84>
        {
            xWaitConditionMet = pdTRUE;
    1f82:	81 e0       	ldi	r24, 0x01	; 1
    1f84:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    1f86:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f88:	2a 96       	adiw	r28, 0x0a	; 10
    1f8a:	0f b6       	in	r0, 0x3f	; 63
    1f8c:	f8 94       	cli
    1f8e:	de bf       	out	0x3e, r29	; 62
    1f90:	0f be       	out	0x3f, r0	; 63
    1f92:	cd bf       	out	0x3d, r28	; 61
    1f94:	cf 91       	pop	r28
    1f96:	df 91       	pop	r29
    1f98:	0f 91       	pop	r16
    1f9a:	08 95       	ret

00001f9c <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1f9c:	df 93       	push	r29
    1f9e:	cf 93       	push	r28
    1fa0:	00 d0       	rcall	.+0      	; 0x1fa2 <vListInitialise+0x6>
    1fa2:	cd b7       	in	r28, 0x3d	; 61
    1fa4:	de b7       	in	r29, 0x3e	; 62
    1fa6:	9a 83       	std	Y+2, r25	; 0x02
    1fa8:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1faa:	89 81       	ldd	r24, Y+1	; 0x01
    1fac:	9a 81       	ldd	r25, Y+2	; 0x02
    1fae:	03 96       	adiw	r24, 0x03	; 3
    1fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    1fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    1fb4:	92 83       	std	Z+2, r25	; 0x02
    1fb6:	81 83       	std	Z+1, r24	; 0x01

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1fb8:	e9 81       	ldd	r30, Y+1	; 0x01
    1fba:	fa 81       	ldd	r31, Y+2	; 0x02
    1fbc:	8f ef       	ldi	r24, 0xFF	; 255
    1fbe:	9f ef       	ldi	r25, 0xFF	; 255
    1fc0:	af ef       	ldi	r26, 0xFF	; 255
    1fc2:	bf ef       	ldi	r27, 0xFF	; 255
    1fc4:	83 83       	std	Z+3, r24	; 0x03
    1fc6:	94 83       	std	Z+4, r25	; 0x04
    1fc8:	a5 83       	std	Z+5, r26	; 0x05
    1fca:	b6 83       	std	Z+6, r27	; 0x06

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1fcc:	89 81       	ldd	r24, Y+1	; 0x01
    1fce:	9a 81       	ldd	r25, Y+2	; 0x02
    1fd0:	03 96       	adiw	r24, 0x03	; 3
    1fd2:	e9 81       	ldd	r30, Y+1	; 0x01
    1fd4:	fa 81       	ldd	r31, Y+2	; 0x02
    1fd6:	90 87       	std	Z+8, r25	; 0x08
    1fd8:	87 83       	std	Z+7, r24	; 0x07
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1fda:	89 81       	ldd	r24, Y+1	; 0x01
    1fdc:	9a 81       	ldd	r25, Y+2	; 0x02
    1fde:	03 96       	adiw	r24, 0x03	; 3
    1fe0:	e9 81       	ldd	r30, Y+1	; 0x01
    1fe2:	fa 81       	ldd	r31, Y+2	; 0x02
    1fe4:	92 87       	std	Z+10, r25	; 0x0a
    1fe6:	81 87       	std	Z+9, r24	; 0x09
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1fe8:	e9 81       	ldd	r30, Y+1	; 0x01
    1fea:	fa 81       	ldd	r31, Y+2	; 0x02
    1fec:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1fee:	0f 90       	pop	r0
    1ff0:	0f 90       	pop	r0
    1ff2:	cf 91       	pop	r28
    1ff4:	df 91       	pop	r29
    1ff6:	08 95       	ret

00001ff8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1ff8:	df 93       	push	r29
    1ffa:	cf 93       	push	r28
    1ffc:	00 d0       	rcall	.+0      	; 0x1ffe <vListInitialiseItem+0x6>
    1ffe:	cd b7       	in	r28, 0x3d	; 61
    2000:	de b7       	in	r29, 0x3e	; 62
    2002:	9a 83       	std	Y+2, r25	; 0x02
    2004:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    2006:	e9 81       	ldd	r30, Y+1	; 0x01
    2008:	fa 81       	ldd	r31, Y+2	; 0x02
    200a:	13 86       	std	Z+11, r1	; 0x0b
    200c:	12 86       	std	Z+10, r1	; 0x0a

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    200e:	0f 90       	pop	r0
    2010:	0f 90       	pop	r0
    2012:	cf 91       	pop	r28
    2014:	df 91       	pop	r29
    2016:	08 95       	ret

00002018 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    2018:	df 93       	push	r29
    201a:	cf 93       	push	r28
    201c:	00 d0       	rcall	.+0      	; 0x201e <vListInsertEnd+0x6>
    201e:	00 d0       	rcall	.+0      	; 0x2020 <vListInsertEnd+0x8>
    2020:	00 d0       	rcall	.+0      	; 0x2022 <vListInsertEnd+0xa>
    2022:	cd b7       	in	r28, 0x3d	; 61
    2024:	de b7       	in	r29, 0x3e	; 62
    2026:	9c 83       	std	Y+4, r25	; 0x04
    2028:	8b 83       	std	Y+3, r24	; 0x03
    202a:	7e 83       	std	Y+6, r23	; 0x06
    202c:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    202e:	eb 81       	ldd	r30, Y+3	; 0x03
    2030:	fc 81       	ldd	r31, Y+4	; 0x04
    2032:	81 81       	ldd	r24, Z+1	; 0x01
    2034:	92 81       	ldd	r25, Z+2	; 0x02
    2036:	9a 83       	std	Y+2, r25	; 0x02
    2038:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    203a:	ed 81       	ldd	r30, Y+5	; 0x05
    203c:	fe 81       	ldd	r31, Y+6	; 0x06
    203e:	89 81       	ldd	r24, Y+1	; 0x01
    2040:	9a 81       	ldd	r25, Y+2	; 0x02
    2042:	95 83       	std	Z+5, r25	; 0x05
    2044:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2046:	e9 81       	ldd	r30, Y+1	; 0x01
    2048:	fa 81       	ldd	r31, Y+2	; 0x02
    204a:	86 81       	ldd	r24, Z+6	; 0x06
    204c:	97 81       	ldd	r25, Z+7	; 0x07
    204e:	ed 81       	ldd	r30, Y+5	; 0x05
    2050:	fe 81       	ldd	r31, Y+6	; 0x06
    2052:	97 83       	std	Z+7, r25	; 0x07
    2054:	86 83       	std	Z+6, r24	; 0x06

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    2056:	e9 81       	ldd	r30, Y+1	; 0x01
    2058:	fa 81       	ldd	r31, Y+2	; 0x02
    205a:	06 80       	ldd	r0, Z+6	; 0x06
    205c:	f7 81       	ldd	r31, Z+7	; 0x07
    205e:	e0 2d       	mov	r30, r0
    2060:	8d 81       	ldd	r24, Y+5	; 0x05
    2062:	9e 81       	ldd	r25, Y+6	; 0x06
    2064:	95 83       	std	Z+5, r25	; 0x05
    2066:	84 83       	std	Z+4, r24	; 0x04
    pxIndex->pxPrevious = pxNewListItem;
    2068:	e9 81       	ldd	r30, Y+1	; 0x01
    206a:	fa 81       	ldd	r31, Y+2	; 0x02
    206c:	8d 81       	ldd	r24, Y+5	; 0x05
    206e:	9e 81       	ldd	r25, Y+6	; 0x06
    2070:	97 83       	std	Z+7, r25	; 0x07
    2072:	86 83       	std	Z+6, r24	; 0x06

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    2074:	ed 81       	ldd	r30, Y+5	; 0x05
    2076:	fe 81       	ldd	r31, Y+6	; 0x06
    2078:	8b 81       	ldd	r24, Y+3	; 0x03
    207a:	9c 81       	ldd	r25, Y+4	; 0x04
    207c:	93 87       	std	Z+11, r25	; 0x0b
    207e:	82 87       	std	Z+10, r24	; 0x0a

    ( pxList->uxNumberOfItems )++;
    2080:	eb 81       	ldd	r30, Y+3	; 0x03
    2082:	fc 81       	ldd	r31, Y+4	; 0x04
    2084:	80 81       	ld	r24, Z
    2086:	8f 5f       	subi	r24, 0xFF	; 255
    2088:	eb 81       	ldd	r30, Y+3	; 0x03
    208a:	fc 81       	ldd	r31, Y+4	; 0x04
    208c:	80 83       	st	Z, r24
}
    208e:	26 96       	adiw	r28, 0x06	; 6
    2090:	0f b6       	in	r0, 0x3f	; 63
    2092:	f8 94       	cli
    2094:	de bf       	out	0x3e, r29	; 62
    2096:	0f be       	out	0x3f, r0	; 63
    2098:	cd bf       	out	0x3d, r28	; 61
    209a:	cf 91       	pop	r28
    209c:	df 91       	pop	r29
    209e:	08 95       	ret

000020a0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    20a0:	df 93       	push	r29
    20a2:	cf 93       	push	r28
    20a4:	cd b7       	in	r28, 0x3d	; 61
    20a6:	de b7       	in	r29, 0x3e	; 62
    20a8:	2a 97       	sbiw	r28, 0x0a	; 10
    20aa:	0f b6       	in	r0, 0x3f	; 63
    20ac:	f8 94       	cli
    20ae:	de bf       	out	0x3e, r29	; 62
    20b0:	0f be       	out	0x3f, r0	; 63
    20b2:	cd bf       	out	0x3d, r28	; 61
    20b4:	98 87       	std	Y+8, r25	; 0x08
    20b6:	8f 83       	std	Y+7, r24	; 0x07
    20b8:	7a 87       	std	Y+10, r23	; 0x0a
    20ba:	69 87       	std	Y+9, r22	; 0x09
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    20bc:	e9 85       	ldd	r30, Y+9	; 0x09
    20be:	fa 85       	ldd	r31, Y+10	; 0x0a
    20c0:	80 81       	ld	r24, Z
    20c2:	91 81       	ldd	r25, Z+1	; 0x01
    20c4:	a2 81       	ldd	r26, Z+2	; 0x02
    20c6:	b3 81       	ldd	r27, Z+3	; 0x03
    20c8:	89 83       	std	Y+1, r24	; 0x01
    20ca:	9a 83       	std	Y+2, r25	; 0x02
    20cc:	ab 83       	std	Y+3, r26	; 0x03
    20ce:	bc 83       	std	Y+4, r27	; 0x04
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    20d0:	89 81       	ldd	r24, Y+1	; 0x01
    20d2:	9a 81       	ldd	r25, Y+2	; 0x02
    20d4:	ab 81       	ldd	r26, Y+3	; 0x03
    20d6:	bc 81       	ldd	r27, Y+4	; 0x04
    20d8:	8f 3f       	cpi	r24, 0xFF	; 255
    20da:	2f ef       	ldi	r18, 0xFF	; 255
    20dc:	92 07       	cpc	r25, r18
    20de:	2f ef       	ldi	r18, 0xFF	; 255
    20e0:	a2 07       	cpc	r26, r18
    20e2:	2f ef       	ldi	r18, 0xFF	; 255
    20e4:	b2 07       	cpc	r27, r18
    20e6:	39 f4       	brne	.+14     	; 0x20f6 <vListInsert+0x56>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    20e8:	ef 81       	ldd	r30, Y+7	; 0x07
    20ea:	f8 85       	ldd	r31, Y+8	; 0x08
    20ec:	81 85       	ldd	r24, Z+9	; 0x09
    20ee:	92 85       	ldd	r25, Z+10	; 0x0a
    20f0:	9e 83       	std	Y+6, r25	; 0x06
    20f2:	8d 83       	std	Y+5, r24	; 0x05
    20f4:	1e c0       	rjmp	.+60     	; 0x2132 <vListInsert+0x92>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    20f6:	8f 81       	ldd	r24, Y+7	; 0x07
    20f8:	98 85       	ldd	r25, Y+8	; 0x08
    20fa:	03 96       	adiw	r24, 0x03	; 3
    20fc:	9e 83       	std	Y+6, r25	; 0x06
    20fe:	8d 83       	std	Y+5, r24	; 0x05
    2100:	06 c0       	rjmp	.+12     	; 0x210e <vListInsert+0x6e>
    2102:	ed 81       	ldd	r30, Y+5	; 0x05
    2104:	fe 81       	ldd	r31, Y+6	; 0x06
    2106:	84 81       	ldd	r24, Z+4	; 0x04
    2108:	95 81       	ldd	r25, Z+5	; 0x05
    210a:	9e 83       	std	Y+6, r25	; 0x06
    210c:	8d 83       	std	Y+5, r24	; 0x05
    210e:	ed 81       	ldd	r30, Y+5	; 0x05
    2110:	fe 81       	ldd	r31, Y+6	; 0x06
    2112:	04 80       	ldd	r0, Z+4	; 0x04
    2114:	f5 81       	ldd	r31, Z+5	; 0x05
    2116:	e0 2d       	mov	r30, r0
    2118:	20 81       	ld	r18, Z
    211a:	31 81       	ldd	r19, Z+1	; 0x01
    211c:	42 81       	ldd	r20, Z+2	; 0x02
    211e:	53 81       	ldd	r21, Z+3	; 0x03
    2120:	89 81       	ldd	r24, Y+1	; 0x01
    2122:	9a 81       	ldd	r25, Y+2	; 0x02
    2124:	ab 81       	ldd	r26, Y+3	; 0x03
    2126:	bc 81       	ldd	r27, Y+4	; 0x04
    2128:	82 17       	cp	r24, r18
    212a:	93 07       	cpc	r25, r19
    212c:	a4 07       	cpc	r26, r20
    212e:	b5 07       	cpc	r27, r21
    2130:	40 f7       	brcc	.-48     	; 0x2102 <vListInsert+0x62>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    2132:	ed 81       	ldd	r30, Y+5	; 0x05
    2134:	fe 81       	ldd	r31, Y+6	; 0x06
    2136:	84 81       	ldd	r24, Z+4	; 0x04
    2138:	95 81       	ldd	r25, Z+5	; 0x05
    213a:	e9 85       	ldd	r30, Y+9	; 0x09
    213c:	fa 85       	ldd	r31, Y+10	; 0x0a
    213e:	95 83       	std	Z+5, r25	; 0x05
    2140:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2142:	e9 85       	ldd	r30, Y+9	; 0x09
    2144:	fa 85       	ldd	r31, Y+10	; 0x0a
    2146:	04 80       	ldd	r0, Z+4	; 0x04
    2148:	f5 81       	ldd	r31, Z+5	; 0x05
    214a:	e0 2d       	mov	r30, r0
    214c:	89 85       	ldd	r24, Y+9	; 0x09
    214e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2150:	97 83       	std	Z+7, r25	; 0x07
    2152:	86 83       	std	Z+6, r24	; 0x06
    pxNewListItem->pxPrevious = pxIterator;
    2154:	e9 85       	ldd	r30, Y+9	; 0x09
    2156:	fa 85       	ldd	r31, Y+10	; 0x0a
    2158:	8d 81       	ldd	r24, Y+5	; 0x05
    215a:	9e 81       	ldd	r25, Y+6	; 0x06
    215c:	97 83       	std	Z+7, r25	; 0x07
    215e:	86 83       	std	Z+6, r24	; 0x06
    pxIterator->pxNext = pxNewListItem;
    2160:	ed 81       	ldd	r30, Y+5	; 0x05
    2162:	fe 81       	ldd	r31, Y+6	; 0x06
    2164:	89 85       	ldd	r24, Y+9	; 0x09
    2166:	9a 85       	ldd	r25, Y+10	; 0x0a
    2168:	95 83       	std	Z+5, r25	; 0x05
    216a:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    216c:	e9 85       	ldd	r30, Y+9	; 0x09
    216e:	fa 85       	ldd	r31, Y+10	; 0x0a
    2170:	8f 81       	ldd	r24, Y+7	; 0x07
    2172:	98 85       	ldd	r25, Y+8	; 0x08
    2174:	93 87       	std	Z+11, r25	; 0x0b
    2176:	82 87       	std	Z+10, r24	; 0x0a

    ( pxList->uxNumberOfItems )++;
    2178:	ef 81       	ldd	r30, Y+7	; 0x07
    217a:	f8 85       	ldd	r31, Y+8	; 0x08
    217c:	80 81       	ld	r24, Z
    217e:	8f 5f       	subi	r24, 0xFF	; 255
    2180:	ef 81       	ldd	r30, Y+7	; 0x07
    2182:	f8 85       	ldd	r31, Y+8	; 0x08
    2184:	80 83       	st	Z, r24
}
    2186:	2a 96       	adiw	r28, 0x0a	; 10
    2188:	0f b6       	in	r0, 0x3f	; 63
    218a:	f8 94       	cli
    218c:	de bf       	out	0x3e, r29	; 62
    218e:	0f be       	out	0x3f, r0	; 63
    2190:	cd bf       	out	0x3d, r28	; 61
    2192:	cf 91       	pop	r28
    2194:	df 91       	pop	r29
    2196:	08 95       	ret

00002198 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2198:	df 93       	push	r29
    219a:	cf 93       	push	r28
    219c:	00 d0       	rcall	.+0      	; 0x219e <uxListRemove+0x6>
    219e:	00 d0       	rcall	.+0      	; 0x21a0 <uxListRemove+0x8>
    21a0:	cd b7       	in	r28, 0x3d	; 61
    21a2:	de b7       	in	r29, 0x3e	; 62
    21a4:	9c 83       	std	Y+4, r25	; 0x04
    21a6:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    21a8:	eb 81       	ldd	r30, Y+3	; 0x03
    21aa:	fc 81       	ldd	r31, Y+4	; 0x04
    21ac:	82 85       	ldd	r24, Z+10	; 0x0a
    21ae:	93 85       	ldd	r25, Z+11	; 0x0b
    21b0:	9a 83       	std	Y+2, r25	; 0x02
    21b2:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    21b4:	eb 81       	ldd	r30, Y+3	; 0x03
    21b6:	fc 81       	ldd	r31, Y+4	; 0x04
    21b8:	a4 81       	ldd	r26, Z+4	; 0x04
    21ba:	b5 81       	ldd	r27, Z+5	; 0x05
    21bc:	eb 81       	ldd	r30, Y+3	; 0x03
    21be:	fc 81       	ldd	r31, Y+4	; 0x04
    21c0:	86 81       	ldd	r24, Z+6	; 0x06
    21c2:	97 81       	ldd	r25, Z+7	; 0x07
    21c4:	17 96       	adiw	r26, 0x07	; 7
    21c6:	9c 93       	st	X, r25
    21c8:	8e 93       	st	-X, r24
    21ca:	16 97       	sbiw	r26, 0x06	; 6
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    21cc:	eb 81       	ldd	r30, Y+3	; 0x03
    21ce:	fc 81       	ldd	r31, Y+4	; 0x04
    21d0:	a6 81       	ldd	r26, Z+6	; 0x06
    21d2:	b7 81       	ldd	r27, Z+7	; 0x07
    21d4:	eb 81       	ldd	r30, Y+3	; 0x03
    21d6:	fc 81       	ldd	r31, Y+4	; 0x04
    21d8:	84 81       	ldd	r24, Z+4	; 0x04
    21da:	95 81       	ldd	r25, Z+5	; 0x05
    21dc:	15 96       	adiw	r26, 0x05	; 5
    21de:	9c 93       	st	X, r25
    21e0:	8e 93       	st	-X, r24
    21e2:	14 97       	sbiw	r26, 0x04	; 4

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    21e4:	e9 81       	ldd	r30, Y+1	; 0x01
    21e6:	fa 81       	ldd	r31, Y+2	; 0x02
    21e8:	21 81       	ldd	r18, Z+1	; 0x01
    21ea:	32 81       	ldd	r19, Z+2	; 0x02
    21ec:	8b 81       	ldd	r24, Y+3	; 0x03
    21ee:	9c 81       	ldd	r25, Y+4	; 0x04
    21f0:	28 17       	cp	r18, r24
    21f2:	39 07       	cpc	r19, r25
    21f4:	41 f4       	brne	.+16     	; 0x2206 <__stack+0x7>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    21f6:	eb 81       	ldd	r30, Y+3	; 0x03
    21f8:	fc 81       	ldd	r31, Y+4	; 0x04
    21fa:	86 81       	ldd	r24, Z+6	; 0x06
    21fc:	97 81       	ldd	r25, Z+7	; 0x07
    21fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2200:	fa 81       	ldd	r31, Y+2	; 0x02
    2202:	92 83       	std	Z+2, r25	; 0x02
    2204:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2206:	eb 81       	ldd	r30, Y+3	; 0x03
    2208:	fc 81       	ldd	r31, Y+4	; 0x04
    220a:	13 86       	std	Z+11, r1	; 0x0b
    220c:	12 86       	std	Z+10, r1	; 0x0a
    ( pxList->uxNumberOfItems )--;
    220e:	e9 81       	ldd	r30, Y+1	; 0x01
    2210:	fa 81       	ldd	r31, Y+2	; 0x02
    2212:	80 81       	ld	r24, Z
    2214:	81 50       	subi	r24, 0x01	; 1
    2216:	e9 81       	ldd	r30, Y+1	; 0x01
    2218:	fa 81       	ldd	r31, Y+2	; 0x02
    221a:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    221c:	e9 81       	ldd	r30, Y+1	; 0x01
    221e:	fa 81       	ldd	r31, Y+2	; 0x02
    2220:	80 81       	ld	r24, Z
}
    2222:	0f 90       	pop	r0
    2224:	0f 90       	pop	r0
    2226:	0f 90       	pop	r0
    2228:	0f 90       	pop	r0
    222a:	cf 91       	pop	r28
    222c:	df 91       	pop	r29
    222e:	08 95       	ret

00002230 <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    2230:	df 93       	push	r29
    2232:	cf 93       	push	r28
    2234:	00 d0       	rcall	.+0      	; 0x2236 <xQueueGenericReset+0x6>
    2236:	00 d0       	rcall	.+0      	; 0x2238 <xQueueGenericReset+0x8>
    2238:	00 d0       	rcall	.+0      	; 0x223a <xQueueGenericReset+0xa>
    223a:	cd b7       	in	r28, 0x3d	; 61
    223c:	de b7       	in	r29, 0x3e	; 62
    223e:	9d 83       	std	Y+5, r25	; 0x05
    2240:	8c 83       	std	Y+4, r24	; 0x04
    2242:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    2244:	81 e0       	ldi	r24, 0x01	; 1
    2246:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    2248:	8c 81       	ldd	r24, Y+4	; 0x04
    224a:	9d 81       	ldd	r25, Y+5	; 0x05
    224c:	9a 83       	std	Y+2, r25	; 0x02
    224e:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    2250:	89 81       	ldd	r24, Y+1	; 0x01
    2252:	9a 81       	ldd	r25, Y+2	; 0x02
    2254:	00 97       	sbiw	r24, 0x00	; 0
    2256:	11 f4       	brne	.+4      	; 0x225c <xQueueGenericReset+0x2c>
    2258:	f8 94       	cli
    225a:	ff cf       	rjmp	.-2      	; 0x225a <xQueueGenericReset+0x2a>

    if( ( pxQueue != NULL ) &&
    225c:	89 81       	ldd	r24, Y+1	; 0x01
    225e:	9a 81       	ldd	r25, Y+2	; 0x02
    2260:	00 97       	sbiw	r24, 0x00	; 0
    2262:	09 f4       	brne	.+2      	; 0x2266 <xQueueGenericReset+0x36>
    2264:	8b c0       	rjmp	.+278    	; 0x237c <xQueueGenericReset+0x14c>
    2266:	e9 81       	ldd	r30, Y+1	; 0x01
    2268:	fa 81       	ldd	r31, Y+2	; 0x02
    226a:	87 8d       	ldd	r24, Z+31	; 0x1f
    226c:	88 23       	and	r24, r24
    226e:	09 f4       	brne	.+2      	; 0x2272 <xQueueGenericReset+0x42>
    2270:	85 c0       	rjmp	.+266    	; 0x237c <xQueueGenericReset+0x14c>
    2272:	e9 81       	ldd	r30, Y+1	; 0x01
    2274:	fa 81       	ldd	r31, Y+2	; 0x02
    2276:	87 8d       	ldd	r24, Z+31	; 0x1f
    2278:	28 2f       	mov	r18, r24
    227a:	30 e0       	ldi	r19, 0x00	; 0
    227c:	8f ef       	ldi	r24, 0xFF	; 255
    227e:	9f e7       	ldi	r25, 0x7F	; 127
    2280:	b9 01       	movw	r22, r18
    2282:	0e 94 aa 3f 	call	0x7f54	; 0x7f54 <__udivmodhi4>
    2286:	cb 01       	movw	r24, r22
    2288:	9c 01       	movw	r18, r24
    228a:	e9 81       	ldd	r30, Y+1	; 0x01
    228c:	fa 81       	ldd	r31, Y+2	; 0x02
    228e:	80 a1       	ldd	r24, Z+32	; 0x20
    2290:	88 2f       	mov	r24, r24
    2292:	90 e0       	ldi	r25, 0x00	; 0
    2294:	28 17       	cp	r18, r24
    2296:	39 07       	cpc	r19, r25
    2298:	08 f4       	brcc	.+2      	; 0x229c <xQueueGenericReset+0x6c>
    229a:	70 c0       	rjmp	.+224    	; 0x237c <xQueueGenericReset+0x14c>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    229c:	0f b6       	in	r0, 0x3f	; 63
    229e:	f8 94       	cli
    22a0:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    22a2:	e9 81       	ldd	r30, Y+1	; 0x01
    22a4:	fa 81       	ldd	r31, Y+2	; 0x02
    22a6:	40 81       	ld	r20, Z
    22a8:	51 81       	ldd	r21, Z+1	; 0x01
    22aa:	e9 81       	ldd	r30, Y+1	; 0x01
    22ac:	fa 81       	ldd	r31, Y+2	; 0x02
    22ae:	87 8d       	ldd	r24, Z+31	; 0x1f
    22b0:	28 2f       	mov	r18, r24
    22b2:	30 e0       	ldi	r19, 0x00	; 0
    22b4:	e9 81       	ldd	r30, Y+1	; 0x01
    22b6:	fa 81       	ldd	r31, Y+2	; 0x02
    22b8:	80 a1       	ldd	r24, Z+32	; 0x20
    22ba:	88 2f       	mov	r24, r24
    22bc:	90 e0       	ldi	r25, 0x00	; 0
    22be:	bc 01       	movw	r22, r24
    22c0:	26 9f       	mul	r18, r22
    22c2:	c0 01       	movw	r24, r0
    22c4:	27 9f       	mul	r18, r23
    22c6:	90 0d       	add	r25, r0
    22c8:	36 9f       	mul	r19, r22
    22ca:	90 0d       	add	r25, r0
    22cc:	11 24       	eor	r1, r1
    22ce:	84 0f       	add	r24, r20
    22d0:	95 1f       	adc	r25, r21
    22d2:	e9 81       	ldd	r30, Y+1	; 0x01
    22d4:	fa 81       	ldd	r31, Y+2	; 0x02
    22d6:	95 83       	std	Z+5, r25	; 0x05
    22d8:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    22da:	e9 81       	ldd	r30, Y+1	; 0x01
    22dc:	fa 81       	ldd	r31, Y+2	; 0x02
    22de:	16 8e       	std	Z+30, r1	; 0x1e
            pxQueue->pcWriteTo = pxQueue->pcHead;
    22e0:	e9 81       	ldd	r30, Y+1	; 0x01
    22e2:	fa 81       	ldd	r31, Y+2	; 0x02
    22e4:	80 81       	ld	r24, Z
    22e6:	91 81       	ldd	r25, Z+1	; 0x01
    22e8:	e9 81       	ldd	r30, Y+1	; 0x01
    22ea:	fa 81       	ldd	r31, Y+2	; 0x02
    22ec:	93 83       	std	Z+3, r25	; 0x03
    22ee:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    22f0:	e9 81       	ldd	r30, Y+1	; 0x01
    22f2:	fa 81       	ldd	r31, Y+2	; 0x02
    22f4:	40 81       	ld	r20, Z
    22f6:	51 81       	ldd	r21, Z+1	; 0x01
    22f8:	e9 81       	ldd	r30, Y+1	; 0x01
    22fa:	fa 81       	ldd	r31, Y+2	; 0x02
    22fc:	87 8d       	ldd	r24, Z+31	; 0x1f
    22fe:	88 2f       	mov	r24, r24
    2300:	90 e0       	ldi	r25, 0x00	; 0
    2302:	9c 01       	movw	r18, r24
    2304:	21 50       	subi	r18, 0x01	; 1
    2306:	30 40       	sbci	r19, 0x00	; 0
    2308:	e9 81       	ldd	r30, Y+1	; 0x01
    230a:	fa 81       	ldd	r31, Y+2	; 0x02
    230c:	80 a1       	ldd	r24, Z+32	; 0x20
    230e:	88 2f       	mov	r24, r24
    2310:	90 e0       	ldi	r25, 0x00	; 0
    2312:	bc 01       	movw	r22, r24
    2314:	26 9f       	mul	r18, r22
    2316:	c0 01       	movw	r24, r0
    2318:	27 9f       	mul	r18, r23
    231a:	90 0d       	add	r25, r0
    231c:	36 9f       	mul	r19, r22
    231e:	90 0d       	add	r25, r0
    2320:	11 24       	eor	r1, r1
    2322:	84 0f       	add	r24, r20
    2324:	95 1f       	adc	r25, r21
    2326:	e9 81       	ldd	r30, Y+1	; 0x01
    2328:	fa 81       	ldd	r31, Y+2	; 0x02
    232a:	97 83       	std	Z+7, r25	; 0x07
    232c:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    232e:	e9 81       	ldd	r30, Y+1	; 0x01
    2330:	fa 81       	ldd	r31, Y+2	; 0x02
    2332:	8f ef       	ldi	r24, 0xFF	; 255
    2334:	81 a3       	std	Z+33, r24	; 0x21
            pxQueue->cTxLock = queueUNLOCKED;
    2336:	e9 81       	ldd	r30, Y+1	; 0x01
    2338:	fa 81       	ldd	r31, Y+2	; 0x02
    233a:	8f ef       	ldi	r24, 0xFF	; 255
    233c:	82 a3       	std	Z+34, r24	; 0x22

            if( xNewQueue == pdFALSE )
    233e:	8e 81       	ldd	r24, Y+6	; 0x06
    2340:	88 23       	and	r24, r24
    2342:	79 f4       	brne	.+30     	; 0x2362 <xQueueGenericReset+0x132>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2344:	e9 81       	ldd	r30, Y+1	; 0x01
    2346:	fa 81       	ldd	r31, Y+2	; 0x02
    2348:	80 85       	ldd	r24, Z+8	; 0x08
    234a:	88 23       	and	r24, r24
    234c:	a1 f0       	breq	.+40     	; 0x2376 <xQueueGenericReset+0x146>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    234e:	89 81       	ldd	r24, Y+1	; 0x01
    2350:	9a 81       	ldd	r25, Y+2	; 0x02
    2352:	08 96       	adiw	r24, 0x08	; 8
    2354:	0e 94 e6 21 	call	0x43cc	; 0x43cc <xTaskRemoveFromEventList>
    2358:	88 23       	and	r24, r24
    235a:	69 f0       	breq	.+26     	; 0x2376 <xQueueGenericReset+0x146>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    235c:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
    2360:	0a c0       	rjmp	.+20     	; 0x2376 <xQueueGenericReset+0x146>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2362:	89 81       	ldd	r24, Y+1	; 0x01
    2364:	9a 81       	ldd	r25, Y+2	; 0x02
    2366:	08 96       	adiw	r24, 0x08	; 8
    2368:	0e 94 ce 0f 	call	0x1f9c	; 0x1f9c <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    236c:	89 81       	ldd	r24, Y+1	; 0x01
    236e:	9a 81       	ldd	r25, Y+2	; 0x02
    2370:	43 96       	adiw	r24, 0x13	; 19
    2372:	0e 94 ce 0f 	call	0x1f9c	; 0x1f9c <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    2376:	0f 90       	pop	r0
    2378:	0f be       	out	0x3f, r0	; 63
    237a:	01 c0       	rjmp	.+2      	; 0x237e <xQueueGenericReset+0x14e>
    }
    else
    {
        xReturn = pdFAIL;
    237c:	1b 82       	std	Y+3, r1	; 0x03
    }

    configASSERT( xReturn != pdFAIL );
    237e:	8b 81       	ldd	r24, Y+3	; 0x03
    2380:	88 23       	and	r24, r24
    2382:	11 f4       	brne	.+4      	; 0x2388 <xQueueGenericReset+0x158>
    2384:	f8 94       	cli
    2386:	ff cf       	rjmp	.-2      	; 0x2386 <xQueueGenericReset+0x156>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    2388:	8b 81       	ldd	r24, Y+3	; 0x03
}
    238a:	26 96       	adiw	r28, 0x06	; 6
    238c:	0f b6       	in	r0, 0x3f	; 63
    238e:	f8 94       	cli
    2390:	de bf       	out	0x3e, r29	; 62
    2392:	0f be       	out	0x3f, r0	; 63
    2394:	cd bf       	out	0x3d, r28	; 61
    2396:	cf 91       	pop	r28
    2398:	df 91       	pop	r29
    239a:	08 95       	ret

0000239c <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    239c:	0f 93       	push	r16
    239e:	1f 93       	push	r17
    23a0:	df 93       	push	r29
    23a2:	cf 93       	push	r28
    23a4:	cd b7       	in	r28, 0x3d	; 61
    23a6:	de b7       	in	r29, 0x3e	; 62
    23a8:	29 97       	sbiw	r28, 0x09	; 9
    23aa:	0f b6       	in	r0, 0x3f	; 63
    23ac:	f8 94       	cli
    23ae:	de bf       	out	0x3e, r29	; 62
    23b0:	0f be       	out	0x3f, r0	; 63
    23b2:	cd bf       	out	0x3d, r28	; 61
    23b4:	8f 83       	std	Y+7, r24	; 0x07
    23b6:	68 87       	std	Y+8, r22	; 0x08
    23b8:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    23ba:	1e 82       	std	Y+6, r1	; 0x06
    23bc:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    23be:	8f 81       	ldd	r24, Y+7	; 0x07
    23c0:	88 23       	and	r24, r24
    23c2:	09 f4       	brne	.+2      	; 0x23c6 <xQueueGenericCreate+0x2a>
    23c4:	53 c0       	rjmp	.+166    	; 0x246c <xQueueGenericCreate+0xd0>
    23c6:	8f 81       	ldd	r24, Y+7	; 0x07
    23c8:	28 2f       	mov	r18, r24
    23ca:	30 e0       	ldi	r19, 0x00	; 0
    23cc:	8f ef       	ldi	r24, 0xFF	; 255
    23ce:	9f e7       	ldi	r25, 0x7F	; 127
    23d0:	b9 01       	movw	r22, r18
    23d2:	0e 94 aa 3f 	call	0x7f54	; 0x7f54 <__udivmodhi4>
    23d6:	cb 01       	movw	r24, r22
    23d8:	9c 01       	movw	r18, r24
    23da:	88 85       	ldd	r24, Y+8	; 0x08
    23dc:	88 2f       	mov	r24, r24
    23de:	90 e0       	ldi	r25, 0x00	; 0
    23e0:	28 17       	cp	r18, r24
    23e2:	39 07       	cpc	r19, r25
    23e4:	08 f4       	brcc	.+2      	; 0x23e8 <xQueueGenericCreate+0x4c>
    23e6:	42 c0       	rjmp	.+132    	; 0x246c <xQueueGenericCreate+0xd0>
    23e8:	8f 81       	ldd	r24, Y+7	; 0x07
    23ea:	28 2f       	mov	r18, r24
    23ec:	30 e0       	ldi	r19, 0x00	; 0
    23ee:	88 85       	ldd	r24, Y+8	; 0x08
    23f0:	88 2f       	mov	r24, r24
    23f2:	90 e0       	ldi	r25, 0x00	; 0
    23f4:	ac 01       	movw	r20, r24
    23f6:	24 9f       	mul	r18, r20
    23f8:	c0 01       	movw	r24, r0
    23fa:	25 9f       	mul	r18, r21
    23fc:	90 0d       	add	r25, r0
    23fe:	34 9f       	mul	r19, r20
    2400:	90 0d       	add	r25, r0
    2402:	11 24       	eor	r1, r1
    2404:	5f e7       	ldi	r21, 0x7F	; 127
    2406:	8d 3d       	cpi	r24, 0xDD	; 221
    2408:	95 07       	cpc	r25, r21
    240a:	80 f5       	brcc	.+96     	; 0x246c <xQueueGenericCreate+0xd0>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    240c:	8f 81       	ldd	r24, Y+7	; 0x07
    240e:	28 2f       	mov	r18, r24
    2410:	30 e0       	ldi	r19, 0x00	; 0
    2412:	88 85       	ldd	r24, Y+8	; 0x08
    2414:	88 2f       	mov	r24, r24
    2416:	90 e0       	ldi	r25, 0x00	; 0
    2418:	ac 01       	movw	r20, r24
    241a:	24 9f       	mul	r18, r20
    241c:	c0 01       	movw	r24, r0
    241e:	25 9f       	mul	r18, r21
    2420:	90 0d       	add	r25, r0
    2422:	34 9f       	mul	r19, r20
    2424:	90 0d       	add	r25, r0
    2426:	11 24       	eor	r1, r1
    2428:	9c 83       	std	Y+4, r25	; 0x04
    242a:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    242c:	8b 81       	ldd	r24, Y+3	; 0x03
    242e:	9c 81       	ldd	r25, Y+4	; 0x04
    2430:	83 96       	adiw	r24, 0x23	; 35
    2432:	0e 94 19 0a 	call	0x1432	; 0x1432 <pvPortMalloc>
    2436:	9e 83       	std	Y+6, r25	; 0x06
    2438:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    243a:	8d 81       	ldd	r24, Y+5	; 0x05
    243c:	9e 81       	ldd	r25, Y+6	; 0x06
    243e:	00 97       	sbiw	r24, 0x00	; 0
    2440:	d9 f0       	breq	.+54     	; 0x2478 <xQueueGenericCreate+0xdc>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    2442:	8d 81       	ldd	r24, Y+5	; 0x05
    2444:	9e 81       	ldd	r25, Y+6	; 0x06
    2446:	9a 83       	std	Y+2, r25	; 0x02
    2448:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    244a:	89 81       	ldd	r24, Y+1	; 0x01
    244c:	9a 81       	ldd	r25, Y+2	; 0x02
    244e:	83 96       	adiw	r24, 0x23	; 35
    2450:	9a 83       	std	Y+2, r25	; 0x02
    2452:	89 83       	std	Y+1, r24	; 0x01
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    2454:	29 81       	ldd	r18, Y+1	; 0x01
    2456:	3a 81       	ldd	r19, Y+2	; 0x02
    2458:	ed 81       	ldd	r30, Y+5	; 0x05
    245a:	fe 81       	ldd	r31, Y+6	; 0x06
    245c:	8f 81       	ldd	r24, Y+7	; 0x07
    245e:	68 85       	ldd	r22, Y+8	; 0x08
    2460:	a9 01       	movw	r20, r18
    2462:	29 85       	ldd	r18, Y+9	; 0x09
    2464:	8f 01       	movw	r16, r30
    2466:	0e 94 49 12 	call	0x2492	; 0x2492 <prvInitialiseNewQueue>
    246a:	06 c0       	rjmp	.+12     	; 0x2478 <xQueueGenericCreate+0xdc>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            configASSERT( pxNewQueue );
    246c:	8d 81       	ldd	r24, Y+5	; 0x05
    246e:	9e 81       	ldd	r25, Y+6	; 0x06
    2470:	00 97       	sbiw	r24, 0x00	; 0
    2472:	11 f4       	brne	.+4      	; 0x2478 <xQueueGenericCreate+0xdc>
    2474:	f8 94       	cli
    2476:	ff cf       	rjmp	.-2      	; 0x2476 <xQueueGenericCreate+0xda>
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    2478:	8d 81       	ldd	r24, Y+5	; 0x05
    247a:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    247c:	29 96       	adiw	r28, 0x09	; 9
    247e:	0f b6       	in	r0, 0x3f	; 63
    2480:	f8 94       	cli
    2482:	de bf       	out	0x3e, r29	; 62
    2484:	0f be       	out	0x3f, r0	; 63
    2486:	cd bf       	out	0x3d, r28	; 61
    2488:	cf 91       	pop	r28
    248a:	df 91       	pop	r29
    248c:	1f 91       	pop	r17
    248e:	0f 91       	pop	r16
    2490:	08 95       	ret

00002492 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    2492:	0f 93       	push	r16
    2494:	1f 93       	push	r17
    2496:	df 93       	push	r29
    2498:	cf 93       	push	r28
    249a:	cd b7       	in	r28, 0x3d	; 61
    249c:	de b7       	in	r29, 0x3e	; 62
    249e:	27 97       	sbiw	r28, 0x07	; 7
    24a0:	0f b6       	in	r0, 0x3f	; 63
    24a2:	f8 94       	cli
    24a4:	de bf       	out	0x3e, r29	; 62
    24a6:	0f be       	out	0x3f, r0	; 63
    24a8:	cd bf       	out	0x3d, r28	; 61
    24aa:	89 83       	std	Y+1, r24	; 0x01
    24ac:	6a 83       	std	Y+2, r22	; 0x02
    24ae:	5c 83       	std	Y+4, r21	; 0x04
    24b0:	4b 83       	std	Y+3, r20	; 0x03
    24b2:	2d 83       	std	Y+5, r18	; 0x05
    24b4:	1f 83       	std	Y+7, r17	; 0x07
    24b6:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    24b8:	8a 81       	ldd	r24, Y+2	; 0x02
    24ba:	88 23       	and	r24, r24
    24bc:	39 f4       	brne	.+14     	; 0x24cc <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    24be:	8e 81       	ldd	r24, Y+6	; 0x06
    24c0:	9f 81       	ldd	r25, Y+7	; 0x07
    24c2:	ee 81       	ldd	r30, Y+6	; 0x06
    24c4:	ff 81       	ldd	r31, Y+7	; 0x07
    24c6:	91 83       	std	Z+1, r25	; 0x01
    24c8:	80 83       	st	Z, r24
    24ca:	06 c0       	rjmp	.+12     	; 0x24d8 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    24cc:	8b 81       	ldd	r24, Y+3	; 0x03
    24ce:	9c 81       	ldd	r25, Y+4	; 0x04
    24d0:	ee 81       	ldd	r30, Y+6	; 0x06
    24d2:	ff 81       	ldd	r31, Y+7	; 0x07
    24d4:	91 83       	std	Z+1, r25	; 0x01
    24d6:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    24d8:	ee 81       	ldd	r30, Y+6	; 0x06
    24da:	ff 81       	ldd	r31, Y+7	; 0x07
    24dc:	89 81       	ldd	r24, Y+1	; 0x01
    24de:	87 8f       	std	Z+31, r24	; 0x1f
    pxNewQueue->uxItemSize = uxItemSize;
    24e0:	ee 81       	ldd	r30, Y+6	; 0x06
    24e2:	ff 81       	ldd	r31, Y+7	; 0x07
    24e4:	8a 81       	ldd	r24, Y+2	; 0x02
    24e6:	80 a3       	std	Z+32, r24	; 0x20
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    24e8:	8e 81       	ldd	r24, Y+6	; 0x06
    24ea:	9f 81       	ldd	r25, Y+7	; 0x07
    24ec:	61 e0       	ldi	r22, 0x01	; 1
    24ee:	0e 94 18 11 	call	0x2230	; 0x2230 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
    }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    24f2:	27 96       	adiw	r28, 0x07	; 7
    24f4:	0f b6       	in	r0, 0x3f	; 63
    24f6:	f8 94       	cli
    24f8:	de bf       	out	0x3e, r29	; 62
    24fa:	0f be       	out	0x3f, r0	; 63
    24fc:	cd bf       	out	0x3d, r28	; 61
    24fe:	cf 91       	pop	r28
    2500:	df 91       	pop	r29
    2502:	1f 91       	pop	r17
    2504:	0f 91       	pop	r16
    2506:	08 95       	ret

00002508 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    2508:	0f 93       	push	r16
    250a:	df 93       	push	r29
    250c:	cf 93       	push	r28
    250e:	cd b7       	in	r28, 0x3d	; 61
    2510:	de b7       	in	r29, 0x3e	; 62
    2512:	67 97       	sbiw	r28, 0x17	; 23
    2514:	0f b6       	in	r0, 0x3f	; 63
    2516:	f8 94       	cli
    2518:	de bf       	out	0x3e, r29	; 62
    251a:	0f be       	out	0x3f, r0	; 63
    251c:	cd bf       	out	0x3d, r28	; 61
    251e:	9b 87       	std	Y+11, r25	; 0x0b
    2520:	8a 87       	std	Y+10, r24	; 0x0a
    2522:	7d 87       	std	Y+13, r23	; 0x0d
    2524:	6c 87       	std	Y+12, r22	; 0x0c
    2526:	2e 87       	std	Y+14, r18	; 0x0e
    2528:	3f 87       	std	Y+15, r19	; 0x0f
    252a:	48 8b       	std	Y+16, r20	; 0x10
    252c:	59 8b       	std	Y+17, r21	; 0x11
    252e:	0a 8b       	std	Y+18, r16	; 0x12
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2530:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2532:	8a 85       	ldd	r24, Y+10	; 0x0a
    2534:	9b 85       	ldd	r25, Y+11	; 0x0b
    2536:	9a 83       	std	Y+2, r25	; 0x02
    2538:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    253a:	89 81       	ldd	r24, Y+1	; 0x01
    253c:	9a 81       	ldd	r25, Y+2	; 0x02
    253e:	00 97       	sbiw	r24, 0x00	; 0
    2540:	11 f4       	brne	.+4      	; 0x2546 <xQueueGenericSend+0x3e>
    2542:	f8 94       	cli
    2544:	ff cf       	rjmp	.-2      	; 0x2544 <xQueueGenericSend+0x3c>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    2546:	8c 85       	ldd	r24, Y+12	; 0x0c
    2548:	9d 85       	ldd	r25, Y+13	; 0x0d
    254a:	00 97       	sbiw	r24, 0x00	; 0
    254c:	29 f4       	brne	.+10     	; 0x2558 <xQueueGenericSend+0x50>
    254e:	e9 81       	ldd	r30, Y+1	; 0x01
    2550:	fa 81       	ldd	r31, Y+2	; 0x02
    2552:	80 a1       	ldd	r24, Z+32	; 0x20
    2554:	88 23       	and	r24, r24
    2556:	29 f4       	brne	.+10     	; 0x2562 <xQueueGenericSend+0x5a>
    2558:	81 e0       	ldi	r24, 0x01	; 1
    255a:	90 e0       	ldi	r25, 0x00	; 0
    255c:	9f 8b       	std	Y+23, r25	; 0x17
    255e:	8e 8b       	std	Y+22, r24	; 0x16
    2560:	02 c0       	rjmp	.+4      	; 0x2566 <xQueueGenericSend+0x5e>
    2562:	1f 8a       	std	Y+23, r1	; 0x17
    2564:	1e 8a       	std	Y+22, r1	; 0x16
    2566:	8e 89       	ldd	r24, Y+22	; 0x16
    2568:	9f 89       	ldd	r25, Y+23	; 0x17
    256a:	00 97       	sbiw	r24, 0x00	; 0
    256c:	11 f4       	brne	.+4      	; 0x2572 <xQueueGenericSend+0x6a>
    256e:	f8 94       	cli
    2570:	ff cf       	rjmp	.-2      	; 0x2570 <xQueueGenericSend+0x68>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    2572:	8a 89       	ldd	r24, Y+18	; 0x12
    2574:	82 30       	cpi	r24, 0x02	; 2
    2576:	29 f4       	brne	.+10     	; 0x2582 <xQueueGenericSend+0x7a>
    2578:	e9 81       	ldd	r30, Y+1	; 0x01
    257a:	fa 81       	ldd	r31, Y+2	; 0x02
    257c:	87 8d       	ldd	r24, Z+31	; 0x1f
    257e:	81 30       	cpi	r24, 0x01	; 1
    2580:	29 f4       	brne	.+10     	; 0x258c <xQueueGenericSend+0x84>
    2582:	81 e0       	ldi	r24, 0x01	; 1
    2584:	90 e0       	ldi	r25, 0x00	; 0
    2586:	9d 8b       	std	Y+21, r25	; 0x15
    2588:	8c 8b       	std	Y+20, r24	; 0x14
    258a:	02 c0       	rjmp	.+4      	; 0x2590 <xQueueGenericSend+0x88>
    258c:	1d 8a       	std	Y+21, r1	; 0x15
    258e:	1c 8a       	std	Y+20, r1	; 0x14
    2590:	8c 89       	ldd	r24, Y+20	; 0x14
    2592:	9d 89       	ldd	r25, Y+21	; 0x15
    2594:	00 97       	sbiw	r24, 0x00	; 0
    2596:	11 f4       	brne	.+4      	; 0x259c <xQueueGenericSend+0x94>
    2598:	f8 94       	cli
    259a:	ff cf       	rjmp	.-2      	; 0x259a <xQueueGenericSend+0x92>
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    259c:	0f b6       	in	r0, 0x3f	; 63
    259e:	f8 94       	cli
    25a0:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    25a2:	e9 81       	ldd	r30, Y+1	; 0x01
    25a4:	fa 81       	ldd	r31, Y+2	; 0x02
    25a6:	96 8d       	ldd	r25, Z+30	; 0x1e
    25a8:	e9 81       	ldd	r30, Y+1	; 0x01
    25aa:	fa 81       	ldd	r31, Y+2	; 0x02
    25ac:	87 8d       	ldd	r24, Z+31	; 0x1f
    25ae:	98 17       	cp	r25, r24
    25b0:	18 f0       	brcs	.+6      	; 0x25b8 <xQueueGenericSend+0xb0>
    25b2:	8a 89       	ldd	r24, Y+18	; 0x12
    25b4:	82 30       	cpi	r24, 0x02	; 2
    25b6:	11 f5       	brne	.+68     	; 0x25fc <xQueueGenericSend+0xf4>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    25b8:	89 81       	ldd	r24, Y+1	; 0x01
    25ba:	9a 81       	ldd	r25, Y+2	; 0x02
    25bc:	2c 85       	ldd	r18, Y+12	; 0x0c
    25be:	3d 85       	ldd	r19, Y+13	; 0x0d
    25c0:	b9 01       	movw	r22, r18
    25c2:	4a 89       	ldd	r20, Y+18	; 0x12
    25c4:	0e 94 48 18 	call	0x3090	; 0x3090 <prvCopyDataToQueue>
    25c8:	8b 83       	std	Y+3, r24	; 0x03

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    25ca:	e9 81       	ldd	r30, Y+1	; 0x01
    25cc:	fa 81       	ldd	r31, Y+2	; 0x02
    25ce:	83 89       	ldd	r24, Z+19	; 0x13
    25d0:	88 23       	and	r24, r24
    25d2:	51 f0       	breq	.+20     	; 0x25e8 <xQueueGenericSend+0xe0>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    25d4:	89 81       	ldd	r24, Y+1	; 0x01
    25d6:	9a 81       	ldd	r25, Y+2	; 0x02
    25d8:	43 96       	adiw	r24, 0x13	; 19
    25da:	0e 94 e6 21 	call	0x43cc	; 0x43cc <xTaskRemoveFromEventList>
    25de:	88 23       	and	r24, r24
    25e0:	41 f0       	breq	.+16     	; 0x25f2 <xQueueGenericSend+0xea>
                        {
                            /* The unblocked task has a priority higher than
                             * our own so yield immediately.  Yes it is ok to do
                             * this from within the critical section - the kernel
                             * takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
    25e2:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
    25e6:	05 c0       	rjmp	.+10     	; 0x25f2 <xQueueGenericSend+0xea>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    25e8:	8b 81       	ldd	r24, Y+3	; 0x03
    25ea:	88 23       	and	r24, r24
    25ec:	11 f0       	breq	.+4      	; 0x25f2 <xQueueGenericSend+0xea>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    25ee:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    25f2:	0f 90       	pop	r0
    25f4:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    25f6:	91 e0       	ldi	r25, 0x01	; 1
    25f8:	9b 8b       	std	Y+19, r25	; 0x13
    25fa:	63 c0       	rjmp	.+198    	; 0x26c2 <xQueueGenericSend+0x1ba>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    25fc:	8e 85       	ldd	r24, Y+14	; 0x0e
    25fe:	9f 85       	ldd	r25, Y+15	; 0x0f
    2600:	a8 89       	ldd	r26, Y+16	; 0x10
    2602:	b9 89       	ldd	r27, Y+17	; 0x11
    2604:	00 97       	sbiw	r24, 0x00	; 0
    2606:	a1 05       	cpc	r26, r1
    2608:	b1 05       	cpc	r27, r1
    260a:	21 f4       	brne	.+8      	; 0x2614 <xQueueGenericSend+0x10c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    260c:	0f 90       	pop	r0
    260e:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    2610:	1b 8a       	std	Y+19, r1	; 0x13
    2612:	57 c0       	rjmp	.+174    	; 0x26c2 <xQueueGenericSend+0x1ba>
                }
                else if( xEntryTimeSet == pdFALSE )
    2614:	8c 81       	ldd	r24, Y+4	; 0x04
    2616:	88 23       	and	r24, r24
    2618:	31 f4       	brne	.+12     	; 0x2626 <xQueueGenericSend+0x11e>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    261a:	ce 01       	movw	r24, r28
    261c:	05 96       	adiw	r24, 0x05	; 5
    261e:	0e 94 8c 24 	call	0x4918	; 0x4918 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2622:	81 e0       	ldi	r24, 0x01	; 1
    2624:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2626:	0f 90       	pop	r0
    2628:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    262a:	0e 94 9a 1c 	call	0x3934	; 0x3934 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    262e:	0f b6       	in	r0, 0x3f	; 63
    2630:	f8 94       	cli
    2632:	0f 92       	push	r0
    2634:	e9 81       	ldd	r30, Y+1	; 0x01
    2636:	fa 81       	ldd	r31, Y+2	; 0x02
    2638:	81 a1       	ldd	r24, Z+33	; 0x21
    263a:	8f 3f       	cpi	r24, 0xFF	; 255
    263c:	19 f4       	brne	.+6      	; 0x2644 <xQueueGenericSend+0x13c>
    263e:	e9 81       	ldd	r30, Y+1	; 0x01
    2640:	fa 81       	ldd	r31, Y+2	; 0x02
    2642:	11 a2       	std	Z+33, r1	; 0x21
    2644:	e9 81       	ldd	r30, Y+1	; 0x01
    2646:	fa 81       	ldd	r31, Y+2	; 0x02
    2648:	82 a1       	ldd	r24, Z+34	; 0x22
    264a:	8f 3f       	cpi	r24, 0xFF	; 255
    264c:	19 f4       	brne	.+6      	; 0x2654 <xQueueGenericSend+0x14c>
    264e:	e9 81       	ldd	r30, Y+1	; 0x01
    2650:	fa 81       	ldd	r31, Y+2	; 0x02
    2652:	12 a2       	std	Z+34, r1	; 0x22
    2654:	0f 90       	pop	r0
    2656:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2658:	ce 01       	movw	r24, r28
    265a:	05 96       	adiw	r24, 0x05	; 5
    265c:	9e 01       	movw	r18, r28
    265e:	22 5f       	subi	r18, 0xF2	; 242
    2660:	3f 4f       	sbci	r19, 0xFF	; 255
    2662:	b9 01       	movw	r22, r18
    2664:	0e 94 ab 24 	call	0x4956	; 0x4956 <xTaskCheckForTimeOut>
    2668:	88 23       	and	r24, r24
    266a:	21 f5       	brne	.+72     	; 0x26b4 <xQueueGenericSend+0x1ac>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    266c:	89 81       	ldd	r24, Y+1	; 0x01
    266e:	9a 81       	ldd	r25, Y+2	; 0x02
    2670:	0e 94 ca 19 	call	0x3394	; 0x3394 <prvIsQueueFull>
    2674:	88 23       	and	r24, r24
    2676:	b9 f0       	breq	.+46     	; 0x26a6 <xQueueGenericSend+0x19e>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2678:	89 81       	ldd	r24, Y+1	; 0x01
    267a:	9a 81       	ldd	r25, Y+2	; 0x02
    267c:	08 96       	adiw	r24, 0x08	; 8
    267e:	2e 85       	ldd	r18, Y+14	; 0x0e
    2680:	3f 85       	ldd	r19, Y+15	; 0x0f
    2682:	48 89       	ldd	r20, Y+16	; 0x10
    2684:	59 89       	ldd	r21, Y+17	; 0x11
    2686:	ba 01       	movw	r22, r20
    2688:	a9 01       	movw	r20, r18
    268a:	0e 94 34 21 	call	0x4268	; 0x4268 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    268e:	89 81       	ldd	r24, Y+1	; 0x01
    2690:	9a 81       	ldd	r25, Y+2	; 0x02
    2692:	0e 94 35 19 	call	0x326a	; 0x326a <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    2696:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>
    269a:	88 23       	and	r24, r24
    269c:	09 f0       	breq	.+2      	; 0x26a0 <xQueueGenericSend+0x198>
    269e:	7e cf       	rjmp	.-260    	; 0x259c <xQueueGenericSend+0x94>
                {
                    portYIELD_WITHIN_API();
    26a0:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
    26a4:	7b cf       	rjmp	.-266    	; 0x259c <xQueueGenericSend+0x94>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    26a6:	89 81       	ldd	r24, Y+1	; 0x01
    26a8:	9a 81       	ldd	r25, Y+2	; 0x02
    26aa:	0e 94 35 19 	call	0x326a	; 0x326a <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    26ae:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>
    26b2:	74 cf       	rjmp	.-280    	; 0x259c <xQueueGenericSend+0x94>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    26b4:	89 81       	ldd	r24, Y+1	; 0x01
    26b6:	9a 81       	ldd	r25, Y+2	; 0x02
    26b8:	0e 94 35 19 	call	0x326a	; 0x326a <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    26bc:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    26c0:	1b 8a       	std	Y+19, r1	; 0x13
    26c2:	8b 89       	ldd	r24, Y+19	; 0x13
        }
    } /*lint -restore */
}
    26c4:	67 96       	adiw	r28, 0x17	; 23
    26c6:	0f b6       	in	r0, 0x3f	; 63
    26c8:	f8 94       	cli
    26ca:	de bf       	out	0x3e, r29	; 62
    26cc:	0f be       	out	0x3f, r0	; 63
    26ce:	cd bf       	out	0x3d, r28	; 61
    26d0:	cf 91       	pop	r28
    26d2:	df 91       	pop	r29
    26d4:	0f 91       	pop	r16
    26d6:	08 95       	ret

000026d8 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    26d8:	df 93       	push	r29
    26da:	cf 93       	push	r28
    26dc:	cd b7       	in	r28, 0x3d	; 61
    26de:	de b7       	in	r29, 0x3e	; 62
    26e0:	62 97       	sbiw	r28, 0x12	; 18
    26e2:	0f b6       	in	r0, 0x3f	; 63
    26e4:	f8 94       	cli
    26e6:	de bf       	out	0x3e, r29	; 62
    26e8:	0f be       	out	0x3f, r0	; 63
    26ea:	cd bf       	out	0x3d, r28	; 61
    26ec:	99 87       	std	Y+9, r25	; 0x09
    26ee:	88 87       	std	Y+8, r24	; 0x08
    26f0:	7b 87       	std	Y+11, r23	; 0x0b
    26f2:	6a 87       	std	Y+10, r22	; 0x0a
    26f4:	5d 87       	std	Y+13, r21	; 0x0d
    26f6:	4c 87       	std	Y+12, r20	; 0x0c
    26f8:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    26fa:	88 85       	ldd	r24, Y+8	; 0x08
    26fc:	99 85       	ldd	r25, Y+9	; 0x09
    26fe:	9d 83       	std	Y+5, r25	; 0x05
    2700:	8c 83       	std	Y+4, r24	; 0x04

    configASSERT( pxQueue );
    2702:	8c 81       	ldd	r24, Y+4	; 0x04
    2704:	9d 81       	ldd	r25, Y+5	; 0x05
    2706:	00 97       	sbiw	r24, 0x00	; 0
    2708:	11 f4       	brne	.+4      	; 0x270e <xQueueGenericSendFromISR+0x36>
    270a:	f8 94       	cli
    270c:	ff cf       	rjmp	.-2      	; 0x270c <xQueueGenericSendFromISR+0x34>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    270e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2710:	9b 85       	ldd	r25, Y+11	; 0x0b
    2712:	00 97       	sbiw	r24, 0x00	; 0
    2714:	29 f4       	brne	.+10     	; 0x2720 <xQueueGenericSendFromISR+0x48>
    2716:	ec 81       	ldd	r30, Y+4	; 0x04
    2718:	fd 81       	ldd	r31, Y+5	; 0x05
    271a:	80 a1       	ldd	r24, Z+32	; 0x20
    271c:	88 23       	and	r24, r24
    271e:	29 f4       	brne	.+10     	; 0x272a <xQueueGenericSendFromISR+0x52>
    2720:	81 e0       	ldi	r24, 0x01	; 1
    2722:	90 e0       	ldi	r25, 0x00	; 0
    2724:	9a 8b       	std	Y+18, r25	; 0x12
    2726:	89 8b       	std	Y+17, r24	; 0x11
    2728:	02 c0       	rjmp	.+4      	; 0x272e <xQueueGenericSendFromISR+0x56>
    272a:	1a 8a       	std	Y+18, r1	; 0x12
    272c:	19 8a       	std	Y+17, r1	; 0x11
    272e:	89 89       	ldd	r24, Y+17	; 0x11
    2730:	9a 89       	ldd	r25, Y+18	; 0x12
    2732:	00 97       	sbiw	r24, 0x00	; 0
    2734:	11 f4       	brne	.+4      	; 0x273a <xQueueGenericSendFromISR+0x62>
    2736:	f8 94       	cli
    2738:	ff cf       	rjmp	.-2      	; 0x2738 <xQueueGenericSendFromISR+0x60>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    273a:	8e 85       	ldd	r24, Y+14	; 0x0e
    273c:	82 30       	cpi	r24, 0x02	; 2
    273e:	29 f4       	brne	.+10     	; 0x274a <xQueueGenericSendFromISR+0x72>
    2740:	ec 81       	ldd	r30, Y+4	; 0x04
    2742:	fd 81       	ldd	r31, Y+5	; 0x05
    2744:	87 8d       	ldd	r24, Z+31	; 0x1f
    2746:	81 30       	cpi	r24, 0x01	; 1
    2748:	29 f4       	brne	.+10     	; 0x2754 <xQueueGenericSendFromISR+0x7c>
    274a:	81 e0       	ldi	r24, 0x01	; 1
    274c:	90 e0       	ldi	r25, 0x00	; 0
    274e:	98 8b       	std	Y+16, r25	; 0x10
    2750:	8f 87       	std	Y+15, r24	; 0x0f
    2752:	02 c0       	rjmp	.+4      	; 0x2758 <xQueueGenericSendFromISR+0x80>
    2754:	18 8a       	std	Y+16, r1	; 0x10
    2756:	1f 86       	std	Y+15, r1	; 0x0f
    2758:	8f 85       	ldd	r24, Y+15	; 0x0f
    275a:	98 89       	ldd	r25, Y+16	; 0x10
    275c:	00 97       	sbiw	r24, 0x00	; 0
    275e:	11 f4       	brne	.+4      	; 0x2764 <xQueueGenericSendFromISR+0x8c>
    2760:	f8 94       	cli
    2762:	ff cf       	rjmp	.-2      	; 0x2762 <xQueueGenericSendFromISR+0x8a>
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2764:	1e 82       	std	Y+6, r1	; 0x06
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2766:	ec 81       	ldd	r30, Y+4	; 0x04
    2768:	fd 81       	ldd	r31, Y+5	; 0x05
    276a:	96 8d       	ldd	r25, Z+30	; 0x1e
    276c:	ec 81       	ldd	r30, Y+4	; 0x04
    276e:	fd 81       	ldd	r31, Y+5	; 0x05
    2770:	87 8d       	ldd	r24, Z+31	; 0x1f
    2772:	98 17       	cp	r25, r24
    2774:	18 f0       	brcs	.+6      	; 0x277c <xQueueGenericSendFromISR+0xa4>
    2776:	8e 85       	ldd	r24, Y+14	; 0x0e
    2778:	82 30       	cpi	r24, 0x02	; 2
    277a:	e1 f5       	brne	.+120    	; 0x27f4 <xQueueGenericSendFromISR+0x11c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    277c:	ec 81       	ldd	r30, Y+4	; 0x04
    277e:	fd 81       	ldd	r31, Y+5	; 0x05
    2780:	82 a1       	ldd	r24, Z+34	; 0x22
    2782:	8b 83       	std	Y+3, r24	; 0x03
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    2784:	ec 81       	ldd	r30, Y+4	; 0x04
    2786:	fd 81       	ldd	r31, Y+5	; 0x05
    2788:	86 8d       	ldd	r24, Z+30	; 0x1e
    278a:	8a 83       	std	Y+2, r24	; 0x02
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    278c:	8c 81       	ldd	r24, Y+4	; 0x04
    278e:	9d 81       	ldd	r25, Y+5	; 0x05
    2790:	2a 85       	ldd	r18, Y+10	; 0x0a
    2792:	3b 85       	ldd	r19, Y+11	; 0x0b
    2794:	b9 01       	movw	r22, r18
    2796:	4e 85       	ldd	r20, Y+14	; 0x0e
    2798:	0e 94 48 18 	call	0x3090	; 0x3090 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    279c:	8b 81       	ldd	r24, Y+3	; 0x03
    279e:	8f 3f       	cpi	r24, 0xFF	; 255
    27a0:	a9 f4       	brne	.+42     	; 0x27cc <xQueueGenericSendFromISR+0xf4>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    27a2:	ec 81       	ldd	r30, Y+4	; 0x04
    27a4:	fd 81       	ldd	r31, Y+5	; 0x05
    27a6:	83 89       	ldd	r24, Z+19	; 0x13
    27a8:	88 23       	and	r24, r24
    27aa:	09 f1       	breq	.+66     	; 0x27ee <xQueueGenericSendFromISR+0x116>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    27ac:	8c 81       	ldd	r24, Y+4	; 0x04
    27ae:	9d 81       	ldd	r25, Y+5	; 0x05
    27b0:	43 96       	adiw	r24, 0x13	; 19
    27b2:	0e 94 e6 21 	call	0x43cc	; 0x43cc <xTaskRemoveFromEventList>
    27b6:	88 23       	and	r24, r24
    27b8:	d1 f0       	breq	.+52     	; 0x27ee <xQueueGenericSendFromISR+0x116>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    27ba:	8c 85       	ldd	r24, Y+12	; 0x0c
    27bc:	9d 85       	ldd	r25, Y+13	; 0x0d
    27be:	00 97       	sbiw	r24, 0x00	; 0
    27c0:	b1 f0       	breq	.+44     	; 0x27ee <xQueueGenericSendFromISR+0x116>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    27c2:	ec 85       	ldd	r30, Y+12	; 0x0c
    27c4:	fd 85       	ldd	r31, Y+13	; 0x0d
    27c6:	81 e0       	ldi	r24, 0x01	; 1
    27c8:	80 83       	st	Z, r24
    27ca:	11 c0       	rjmp	.+34     	; 0x27ee <xQueueGenericSendFromISR+0x116>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    27cc:	0e 94 63 1e 	call	0x3cc6	; 0x3cc6 <uxTaskGetNumberOfTasks>
    27d0:	89 83       	std	Y+1, r24	; 0x01
    27d2:	9b 81       	ldd	r25, Y+3	; 0x03
    27d4:	89 81       	ldd	r24, Y+1	; 0x01
    27d6:	98 17       	cp	r25, r24
    27d8:	50 f4       	brcc	.+20     	; 0x27ee <xQueueGenericSendFromISR+0x116>
    27da:	8b 81       	ldd	r24, Y+3	; 0x03
    27dc:	8f 37       	cpi	r24, 0x7F	; 127
    27de:	11 f4       	brne	.+4      	; 0x27e4 <xQueueGenericSendFromISR+0x10c>
    27e0:	f8 94       	cli
    27e2:	ff cf       	rjmp	.-2      	; 0x27e2 <xQueueGenericSendFromISR+0x10a>
    27e4:	8b 81       	ldd	r24, Y+3	; 0x03
    27e6:	8f 5f       	subi	r24, 0xFF	; 255
    27e8:	ec 81       	ldd	r30, Y+4	; 0x04
    27ea:	fd 81       	ldd	r31, Y+5	; 0x05
    27ec:	82 a3       	std	Z+34, r24	; 0x22
            }

            xReturn = pdPASS;
    27ee:	81 e0       	ldi	r24, 0x01	; 1
    27f0:	8f 83       	std	Y+7, r24	; 0x07
    27f2:	01 c0       	rjmp	.+2      	; 0x27f6 <xQueueGenericSendFromISR+0x11e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    27f4:	1f 82       	std	Y+7, r1	; 0x07
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    27f6:	8f 81       	ldd	r24, Y+7	; 0x07
}
    27f8:	62 96       	adiw	r28, 0x12	; 18
    27fa:	0f b6       	in	r0, 0x3f	; 63
    27fc:	f8 94       	cli
    27fe:	de bf       	out	0x3e, r29	; 62
    2800:	0f be       	out	0x3f, r0	; 63
    2802:	cd bf       	out	0x3d, r28	; 61
    2804:	cf 91       	pop	r28
    2806:	df 91       	pop	r29
    2808:	08 95       	ret

0000280a <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    280a:	df 93       	push	r29
    280c:	cf 93       	push	r28
    280e:	cd b7       	in	r28, 0x3d	; 61
    2810:	de b7       	in	r29, 0x3e	; 62
    2812:	2d 97       	sbiw	r28, 0x0d	; 13
    2814:	0f b6       	in	r0, 0x3f	; 63
    2816:	f8 94       	cli
    2818:	de bf       	out	0x3e, r29	; 62
    281a:	0f be       	out	0x3f, r0	; 63
    281c:	cd bf       	out	0x3d, r28	; 61
    281e:	99 87       	std	Y+9, r25	; 0x09
    2820:	88 87       	std	Y+8, r24	; 0x08
    2822:	7b 87       	std	Y+11, r23	; 0x0b
    2824:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2826:	88 85       	ldd	r24, Y+8	; 0x08
    2828:	99 85       	ldd	r25, Y+9	; 0x09
    282a:	9d 83       	std	Y+5, r25	; 0x05
    282c:	8c 83       	std	Y+4, r24	; 0x04
     * item size is 0.  Don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */

    configASSERT( pxQueue );
    282e:	8c 81       	ldd	r24, Y+4	; 0x04
    2830:	9d 81       	ldd	r25, Y+5	; 0x05
    2832:	00 97       	sbiw	r24, 0x00	; 0
    2834:	11 f4       	brne	.+4      	; 0x283a <xQueueGiveFromISR+0x30>
    2836:	f8 94       	cli
    2838:	ff cf       	rjmp	.-2      	; 0x2838 <xQueueGiveFromISR+0x2e>

    /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
     * if the item size is not 0. */
    configASSERT( pxQueue->uxItemSize == 0 );
    283a:	ec 81       	ldd	r30, Y+4	; 0x04
    283c:	fd 81       	ldd	r31, Y+5	; 0x05
    283e:	80 a1       	ldd	r24, Z+32	; 0x20
    2840:	88 23       	and	r24, r24
    2842:	11 f0       	breq	.+4      	; 0x2848 <xQueueGiveFromISR+0x3e>
    2844:	f8 94       	cli
    2846:	ff cf       	rjmp	.-2      	; 0x2846 <xQueueGiveFromISR+0x3c>

    /* Normally a mutex would not be given from an interrupt, especially if
     * there is a mutex holder, as priority inheritance makes no sense for an
     * interrupts, only tasks. */
    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
    2848:	ec 81       	ldd	r30, Y+4	; 0x04
    284a:	fd 81       	ldd	r31, Y+5	; 0x05
    284c:	80 81       	ld	r24, Z
    284e:	91 81       	ldd	r25, Z+1	; 0x01
    2850:	00 97       	sbiw	r24, 0x00	; 0
    2852:	31 f4       	brne	.+12     	; 0x2860 <xQueueGiveFromISR+0x56>
    2854:	ec 81       	ldd	r30, Y+4	; 0x04
    2856:	fd 81       	ldd	r31, Y+5	; 0x05
    2858:	84 81       	ldd	r24, Z+4	; 0x04
    285a:	95 81       	ldd	r25, Z+5	; 0x05
    285c:	00 97       	sbiw	r24, 0x00	; 0
    285e:	29 f4       	brne	.+10     	; 0x286a <xQueueGiveFromISR+0x60>
    2860:	81 e0       	ldi	r24, 0x01	; 1
    2862:	90 e0       	ldi	r25, 0x00	; 0
    2864:	9d 87       	std	Y+13, r25	; 0x0d
    2866:	8c 87       	std	Y+12, r24	; 0x0c
    2868:	02 c0       	rjmp	.+4      	; 0x286e <xQueueGiveFromISR+0x64>
    286a:	1d 86       	std	Y+13, r1	; 0x0d
    286c:	1c 86       	std	Y+12, r1	; 0x0c
    286e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2870:	9d 85       	ldd	r25, Y+13	; 0x0d
    2872:	00 97       	sbiw	r24, 0x00	; 0
    2874:	11 f4       	brne	.+4      	; 0x287a <xQueueGiveFromISR+0x70>
    2876:	f8 94       	cli
    2878:	ff cf       	rjmp	.-2      	; 0x2878 <xQueueGiveFromISR+0x6e>
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    287a:	1e 82       	std	Y+6, r1	; 0x06
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    287c:	ec 81       	ldd	r30, Y+4	; 0x04
    287e:	fd 81       	ldd	r31, Y+5	; 0x05
    2880:	86 8d       	ldd	r24, Z+30	; 0x1e
    2882:	8b 83       	std	Y+3, r24	; 0x03

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    2884:	ec 81       	ldd	r30, Y+4	; 0x04
    2886:	fd 81       	ldd	r31, Y+5	; 0x05
    2888:	97 8d       	ldd	r25, Z+31	; 0x1f
    288a:	8b 81       	ldd	r24, Y+3	; 0x03
    288c:	89 17       	cp	r24, r25
    288e:	a8 f5       	brcc	.+106    	; 0x28fa <xQueueGiveFromISR+0xf0>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2890:	ec 81       	ldd	r30, Y+4	; 0x04
    2892:	fd 81       	ldd	r31, Y+5	; 0x05
    2894:	82 a1       	ldd	r24, Z+34	; 0x22
    2896:	8a 83       	std	Y+2, r24	; 0x02
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2898:	8b 81       	ldd	r24, Y+3	; 0x03
    289a:	8f 5f       	subi	r24, 0xFF	; 255
    289c:	ec 81       	ldd	r30, Y+4	; 0x04
    289e:	fd 81       	ldd	r31, Y+5	; 0x05
    28a0:	86 8f       	std	Z+30, r24	; 0x1e

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    28a2:	8a 81       	ldd	r24, Y+2	; 0x02
    28a4:	8f 3f       	cpi	r24, 0xFF	; 255
    28a6:	a9 f4       	brne	.+42     	; 0x28d2 <xQueueGiveFromISR+0xc8>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    28a8:	ec 81       	ldd	r30, Y+4	; 0x04
    28aa:	fd 81       	ldd	r31, Y+5	; 0x05
    28ac:	83 89       	ldd	r24, Z+19	; 0x13
    28ae:	88 23       	and	r24, r24
    28b0:	09 f1       	breq	.+66     	; 0x28f4 <xQueueGiveFromISR+0xea>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    28b2:	8c 81       	ldd	r24, Y+4	; 0x04
    28b4:	9d 81       	ldd	r25, Y+5	; 0x05
    28b6:	43 96       	adiw	r24, 0x13	; 19
    28b8:	0e 94 e6 21 	call	0x43cc	; 0x43cc <xTaskRemoveFromEventList>
    28bc:	88 23       	and	r24, r24
    28be:	d1 f0       	breq	.+52     	; 0x28f4 <xQueueGiveFromISR+0xea>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    28c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    28c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    28c4:	00 97       	sbiw	r24, 0x00	; 0
    28c6:	b1 f0       	breq	.+44     	; 0x28f4 <xQueueGiveFromISR+0xea>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    28c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    28ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    28cc:	81 e0       	ldi	r24, 0x01	; 1
    28ce:	80 83       	st	Z, r24
    28d0:	11 c0       	rjmp	.+34     	; 0x28f4 <xQueueGiveFromISR+0xea>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    28d2:	0e 94 63 1e 	call	0x3cc6	; 0x3cc6 <uxTaskGetNumberOfTasks>
    28d6:	89 83       	std	Y+1, r24	; 0x01
    28d8:	9a 81       	ldd	r25, Y+2	; 0x02
    28da:	89 81       	ldd	r24, Y+1	; 0x01
    28dc:	98 17       	cp	r25, r24
    28de:	50 f4       	brcc	.+20     	; 0x28f4 <xQueueGiveFromISR+0xea>
    28e0:	8a 81       	ldd	r24, Y+2	; 0x02
    28e2:	8f 37       	cpi	r24, 0x7F	; 127
    28e4:	11 f4       	brne	.+4      	; 0x28ea <xQueueGiveFromISR+0xe0>
    28e6:	f8 94       	cli
    28e8:	ff cf       	rjmp	.-2      	; 0x28e8 <xQueueGiveFromISR+0xde>
    28ea:	8a 81       	ldd	r24, Y+2	; 0x02
    28ec:	8f 5f       	subi	r24, 0xFF	; 255
    28ee:	ec 81       	ldd	r30, Y+4	; 0x04
    28f0:	fd 81       	ldd	r31, Y+5	; 0x05
    28f2:	82 a3       	std	Z+34, r24	; 0x22
            }

            xReturn = pdPASS;
    28f4:	81 e0       	ldi	r24, 0x01	; 1
    28f6:	8f 83       	std	Y+7, r24	; 0x07
    28f8:	01 c0       	rjmp	.+2      	; 0x28fc <xQueueGiveFromISR+0xf2>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    28fa:	1f 82       	std	Y+7, r1	; 0x07
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    28fc:	8f 81       	ldd	r24, Y+7	; 0x07
}
    28fe:	2d 96       	adiw	r28, 0x0d	; 13
    2900:	0f b6       	in	r0, 0x3f	; 63
    2902:	f8 94       	cli
    2904:	de bf       	out	0x3e, r29	; 62
    2906:	0f be       	out	0x3f, r0	; 63
    2908:	cd bf       	out	0x3d, r28	; 61
    290a:	cf 91       	pop	r28
    290c:	df 91       	pop	r29
    290e:	08 95       	ret

00002910 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    2910:	df 93       	push	r29
    2912:	cf 93       	push	r28
    2914:	cd b7       	in	r28, 0x3d	; 61
    2916:	de b7       	in	r29, 0x3e	; 62
    2918:	64 97       	sbiw	r28, 0x14	; 20
    291a:	0f b6       	in	r0, 0x3f	; 63
    291c:	f8 94       	cli
    291e:	de bf       	out	0x3e, r29	; 62
    2920:	0f be       	out	0x3f, r0	; 63
    2922:	cd bf       	out	0x3d, r28	; 61
    2924:	9b 87       	std	Y+11, r25	; 0x0b
    2926:	8a 87       	std	Y+10, r24	; 0x0a
    2928:	7d 87       	std	Y+13, r23	; 0x0d
    292a:	6c 87       	std	Y+12, r22	; 0x0c
    292c:	2e 87       	std	Y+14, r18	; 0x0e
    292e:	3f 87       	std	Y+15, r19	; 0x0f
    2930:	48 8b       	std	Y+16, r20	; 0x10
    2932:	59 8b       	std	Y+17, r21	; 0x11
    BaseType_t xEntryTimeSet = pdFALSE;
    2934:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2936:	8a 85       	ldd	r24, Y+10	; 0x0a
    2938:	9b 85       	ldd	r25, Y+11	; 0x0b
    293a:	9b 83       	std	Y+3, r25	; 0x03
    293c:	8a 83       	std	Y+2, r24	; 0x02

    /* Check the pointer is not NULL. */
    configASSERT( ( pxQueue ) );
    293e:	8a 81       	ldd	r24, Y+2	; 0x02
    2940:	9b 81       	ldd	r25, Y+3	; 0x03
    2942:	00 97       	sbiw	r24, 0x00	; 0
    2944:	11 f4       	brne	.+4      	; 0x294a <xQueueReceive+0x3a>
    2946:	f8 94       	cli
    2948:	ff cf       	rjmp	.-2      	; 0x2948 <xQueueReceive+0x38>

    /* The buffer into which data is received can only be NULL if the data size
     * is zero (so no data is copied into the buffer). */
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    294a:	8c 85       	ldd	r24, Y+12	; 0x0c
    294c:	9d 85       	ldd	r25, Y+13	; 0x0d
    294e:	00 97       	sbiw	r24, 0x00	; 0
    2950:	29 f4       	brne	.+10     	; 0x295c <xQueueReceive+0x4c>
    2952:	ea 81       	ldd	r30, Y+2	; 0x02
    2954:	fb 81       	ldd	r31, Y+3	; 0x03
    2956:	80 a1       	ldd	r24, Z+32	; 0x20
    2958:	88 23       	and	r24, r24
    295a:	29 f4       	brne	.+10     	; 0x2966 <xQueueReceive+0x56>
    295c:	81 e0       	ldi	r24, 0x01	; 1
    295e:	90 e0       	ldi	r25, 0x00	; 0
    2960:	9c 8b       	std	Y+20, r25	; 0x14
    2962:	8b 8b       	std	Y+19, r24	; 0x13
    2964:	02 c0       	rjmp	.+4      	; 0x296a <xQueueReceive+0x5a>
    2966:	1c 8a       	std	Y+20, r1	; 0x14
    2968:	1b 8a       	std	Y+19, r1	; 0x13
    296a:	8b 89       	ldd	r24, Y+19	; 0x13
    296c:	9c 89       	ldd	r25, Y+20	; 0x14
    296e:	00 97       	sbiw	r24, 0x00	; 0
    2970:	11 f4       	brne	.+4      	; 0x2976 <xQueueReceive+0x66>
    2972:	f8 94       	cli
    2974:	ff cf       	rjmp	.-2      	; 0x2974 <xQueueReceive+0x64>
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2976:	0f b6       	in	r0, 0x3f	; 63
    2978:	f8 94       	cli
    297a:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    297c:	ea 81       	ldd	r30, Y+2	; 0x02
    297e:	fb 81       	ldd	r31, Y+3	; 0x03
    2980:	86 8d       	ldd	r24, Z+30	; 0x1e
    2982:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2984:	89 81       	ldd	r24, Y+1	; 0x01
    2986:	88 23       	and	r24, r24
    2988:	f9 f0       	breq	.+62     	; 0x29c8 <xQueueReceive+0xb8>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    298a:	8a 81       	ldd	r24, Y+2	; 0x02
    298c:	9b 81       	ldd	r25, Y+3	; 0x03
    298e:	2c 85       	ldd	r18, Y+12	; 0x0c
    2990:	3d 85       	ldd	r19, Y+13	; 0x0d
    2992:	b9 01       	movw	r22, r18
    2994:	0e 94 ee 18 	call	0x31dc	; 0x31dc <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2998:	89 81       	ldd	r24, Y+1	; 0x01
    299a:	81 50       	subi	r24, 0x01	; 1
    299c:	ea 81       	ldd	r30, Y+2	; 0x02
    299e:	fb 81       	ldd	r31, Y+3	; 0x03
    29a0:	86 8f       	std	Z+30, r24	; 0x1e

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    29a2:	ea 81       	ldd	r30, Y+2	; 0x02
    29a4:	fb 81       	ldd	r31, Y+3	; 0x03
    29a6:	80 85       	ldd	r24, Z+8	; 0x08
    29a8:	88 23       	and	r24, r24
    29aa:	49 f0       	breq	.+18     	; 0x29be <xQueueReceive+0xae>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    29ac:	8a 81       	ldd	r24, Y+2	; 0x02
    29ae:	9b 81       	ldd	r25, Y+3	; 0x03
    29b0:	08 96       	adiw	r24, 0x08	; 8
    29b2:	0e 94 e6 21 	call	0x43cc	; 0x43cc <xTaskRemoveFromEventList>
    29b6:	88 23       	and	r24, r24
    29b8:	11 f0       	breq	.+4      	; 0x29be <xQueueReceive+0xae>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    29ba:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    29be:	0f 90       	pop	r0
    29c0:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    29c2:	91 e0       	ldi	r25, 0x01	; 1
    29c4:	9a 8b       	std	Y+18, r25	; 0x12
    29c6:	6a c0       	rjmp	.+212    	; 0x2a9c <xQueueReceive+0x18c>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    29c8:	8e 85       	ldd	r24, Y+14	; 0x0e
    29ca:	9f 85       	ldd	r25, Y+15	; 0x0f
    29cc:	a8 89       	ldd	r26, Y+16	; 0x10
    29ce:	b9 89       	ldd	r27, Y+17	; 0x11
    29d0:	00 97       	sbiw	r24, 0x00	; 0
    29d2:	a1 05       	cpc	r26, r1
    29d4:	b1 05       	cpc	r27, r1
    29d6:	21 f4       	brne	.+8      	; 0x29e0 <xQueueReceive+0xd0>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    29d8:	0f 90       	pop	r0
    29da:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    29dc:	1a 8a       	std	Y+18, r1	; 0x12
    29de:	5e c0       	rjmp	.+188    	; 0x2a9c <xQueueReceive+0x18c>
                }
                else if( xEntryTimeSet == pdFALSE )
    29e0:	8c 81       	ldd	r24, Y+4	; 0x04
    29e2:	88 23       	and	r24, r24
    29e4:	31 f4       	brne	.+12     	; 0x29f2 <xQueueReceive+0xe2>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    29e6:	ce 01       	movw	r24, r28
    29e8:	05 96       	adiw	r24, 0x05	; 5
    29ea:	0e 94 8c 24 	call	0x4918	; 0x4918 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    29ee:	81 e0       	ldi	r24, 0x01	; 1
    29f0:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    29f2:	0f 90       	pop	r0
    29f4:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    29f6:	0e 94 9a 1c 	call	0x3934	; 0x3934 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    29fa:	0f b6       	in	r0, 0x3f	; 63
    29fc:	f8 94       	cli
    29fe:	0f 92       	push	r0
    2a00:	ea 81       	ldd	r30, Y+2	; 0x02
    2a02:	fb 81       	ldd	r31, Y+3	; 0x03
    2a04:	81 a1       	ldd	r24, Z+33	; 0x21
    2a06:	8f 3f       	cpi	r24, 0xFF	; 255
    2a08:	19 f4       	brne	.+6      	; 0x2a10 <xQueueReceive+0x100>
    2a0a:	ea 81       	ldd	r30, Y+2	; 0x02
    2a0c:	fb 81       	ldd	r31, Y+3	; 0x03
    2a0e:	11 a2       	std	Z+33, r1	; 0x21
    2a10:	ea 81       	ldd	r30, Y+2	; 0x02
    2a12:	fb 81       	ldd	r31, Y+3	; 0x03
    2a14:	82 a1       	ldd	r24, Z+34	; 0x22
    2a16:	8f 3f       	cpi	r24, 0xFF	; 255
    2a18:	19 f4       	brne	.+6      	; 0x2a20 <xQueueReceive+0x110>
    2a1a:	ea 81       	ldd	r30, Y+2	; 0x02
    2a1c:	fb 81       	ldd	r31, Y+3	; 0x03
    2a1e:	12 a2       	std	Z+34, r1	; 0x22
    2a20:	0f 90       	pop	r0
    2a22:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2a24:	ce 01       	movw	r24, r28
    2a26:	05 96       	adiw	r24, 0x05	; 5
    2a28:	9e 01       	movw	r18, r28
    2a2a:	22 5f       	subi	r18, 0xF2	; 242
    2a2c:	3f 4f       	sbci	r19, 0xFF	; 255
    2a2e:	b9 01       	movw	r22, r18
    2a30:	0e 94 ab 24 	call	0x4956	; 0x4956 <xTaskCheckForTimeOut>
    2a34:	88 23       	and	r24, r24
    2a36:	21 f5       	brne	.+72     	; 0x2a80 <xQueueReceive+0x170>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2a38:	8a 81       	ldd	r24, Y+2	; 0x02
    2a3a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a3c:	0e 94 88 19 	call	0x3310	; 0x3310 <prvIsQueueEmpty>
    2a40:	88 23       	and	r24, r24
    2a42:	b9 f0       	breq	.+46     	; 0x2a72 <xQueueReceive+0x162>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2a44:	8a 81       	ldd	r24, Y+2	; 0x02
    2a46:	9b 81       	ldd	r25, Y+3	; 0x03
    2a48:	43 96       	adiw	r24, 0x13	; 19
    2a4a:	2e 85       	ldd	r18, Y+14	; 0x0e
    2a4c:	3f 85       	ldd	r19, Y+15	; 0x0f
    2a4e:	48 89       	ldd	r20, Y+16	; 0x10
    2a50:	59 89       	ldd	r21, Y+17	; 0x11
    2a52:	ba 01       	movw	r22, r20
    2a54:	a9 01       	movw	r20, r18
    2a56:	0e 94 34 21 	call	0x4268	; 0x4268 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    2a5c:	9b 81       	ldd	r25, Y+3	; 0x03
    2a5e:	0e 94 35 19 	call	0x326a	; 0x326a <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2a62:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>
    2a66:	88 23       	and	r24, r24
    2a68:	09 f0       	breq	.+2      	; 0x2a6c <xQueueReceive+0x15c>
    2a6a:	85 cf       	rjmp	.-246    	; 0x2976 <xQueueReceive+0x66>
                {
                    portYIELD_WITHIN_API();
    2a6c:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
    2a70:	82 cf       	rjmp	.-252    	; 0x2976 <xQueueReceive+0x66>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    2a72:	8a 81       	ldd	r24, Y+2	; 0x02
    2a74:	9b 81       	ldd	r25, Y+3	; 0x03
    2a76:	0e 94 35 19 	call	0x326a	; 0x326a <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2a7a:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>
    2a7e:	7b cf       	rjmp	.-266    	; 0x2976 <xQueueReceive+0x66>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    2a80:	8a 81       	ldd	r24, Y+2	; 0x02
    2a82:	9b 81       	ldd	r25, Y+3	; 0x03
    2a84:	0e 94 35 19 	call	0x326a	; 0x326a <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2a88:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2a8c:	8a 81       	ldd	r24, Y+2	; 0x02
    2a8e:	9b 81       	ldd	r25, Y+3	; 0x03
    2a90:	0e 94 88 19 	call	0x3310	; 0x3310 <prvIsQueueEmpty>
    2a94:	88 23       	and	r24, r24
    2a96:	09 f4       	brne	.+2      	; 0x2a9a <xQueueReceive+0x18a>
    2a98:	6e cf       	rjmp	.-292    	; 0x2976 <xQueueReceive+0x66>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2a9a:	1a 8a       	std	Y+18, r1	; 0x12
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2a9c:	8a 89       	ldd	r24, Y+18	; 0x12
}
    2a9e:	64 96       	adiw	r28, 0x14	; 20
    2aa0:	0f b6       	in	r0, 0x3f	; 63
    2aa2:	f8 94       	cli
    2aa4:	de bf       	out	0x3e, r29	; 62
    2aa6:	0f be       	out	0x3f, r0	; 63
    2aa8:	cd bf       	out	0x3d, r28	; 61
    2aaa:	cf 91       	pop	r28
    2aac:	df 91       	pop	r29
    2aae:	08 95       	ret

00002ab0 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    2ab0:	df 93       	push	r29
    2ab2:	cf 93       	push	r28
    2ab4:	cd b7       	in	r28, 0x3d	; 61
    2ab6:	de b7       	in	r29, 0x3e	; 62
    2ab8:	60 97       	sbiw	r28, 0x10	; 16
    2aba:	0f b6       	in	r0, 0x3f	; 63
    2abc:	f8 94       	cli
    2abe:	de bf       	out	0x3e, r29	; 62
    2ac0:	0f be       	out	0x3f, r0	; 63
    2ac2:	cd bf       	out	0x3d, r28	; 61
    2ac4:	9b 87       	std	Y+11, r25	; 0x0b
    2ac6:	8a 87       	std	Y+10, r24	; 0x0a
    2ac8:	4c 87       	std	Y+12, r20	; 0x0c
    2aca:	5d 87       	std	Y+13, r21	; 0x0d
    2acc:	6e 87       	std	Y+14, r22	; 0x0e
    2ace:	7f 87       	std	Y+15, r23	; 0x0f
    BaseType_t xEntryTimeSet = pdFALSE;
    2ad0:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2ad2:	8a 85       	ldd	r24, Y+10	; 0x0a
    2ad4:	9b 85       	ldd	r25, Y+11	; 0x0b
    2ad6:	9b 83       	std	Y+3, r25	; 0x03
    2ad8:	8a 83       	std	Y+2, r24	; 0x02
    #if ( configUSE_MUTEXES == 1 )
        BaseType_t xInheritanceOccurred = pdFALSE;
    #endif

    /* Check the queue pointer is not NULL. */
    configASSERT( ( pxQueue ) );
    2ada:	8a 81       	ldd	r24, Y+2	; 0x02
    2adc:	9b 81       	ldd	r25, Y+3	; 0x03
    2ade:	00 97       	sbiw	r24, 0x00	; 0
    2ae0:	11 f4       	brne	.+4      	; 0x2ae6 <xQueueSemaphoreTake+0x36>
    2ae2:	f8 94       	cli
    2ae4:	ff cf       	rjmp	.-2      	; 0x2ae4 <xQueueSemaphoreTake+0x34>

    /* Check this really is a semaphore, in which case the item size will be
     * 0. */
    configASSERT( pxQueue->uxItemSize == 0 );
    2ae6:	ea 81       	ldd	r30, Y+2	; 0x02
    2ae8:	fb 81       	ldd	r31, Y+3	; 0x03
    2aea:	80 a1       	ldd	r24, Z+32	; 0x20
    2aec:	88 23       	and	r24, r24
    2aee:	11 f0       	breq	.+4      	; 0x2af4 <xQueueSemaphoreTake+0x44>
    2af0:	f8 94       	cli
    2af2:	ff cf       	rjmp	.-2      	; 0x2af2 <xQueueSemaphoreTake+0x42>
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2af4:	0f b6       	in	r0, 0x3f	; 63
    2af6:	f8 94       	cli
    2af8:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2afa:	ea 81       	ldd	r30, Y+2	; 0x02
    2afc:	fb 81       	ldd	r31, Y+3	; 0x03
    2afe:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b00:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2b02:	89 81       	ldd	r24, Y+1	; 0x01
    2b04:	88 23       	and	r24, r24
    2b06:	c1 f0       	breq	.+48     	; 0x2b38 <xQueueSemaphoreTake+0x88>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2b08:	89 81       	ldd	r24, Y+1	; 0x01
    2b0a:	81 50       	subi	r24, 0x01	; 1
    2b0c:	ea 81       	ldd	r30, Y+2	; 0x02
    2b0e:	fb 81       	ldd	r31, Y+3	; 0x03
    2b10:	86 8f       	std	Z+30, r24	; 0x1e
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2b12:	ea 81       	ldd	r30, Y+2	; 0x02
    2b14:	fb 81       	ldd	r31, Y+3	; 0x03
    2b16:	80 85       	ldd	r24, Z+8	; 0x08
    2b18:	88 23       	and	r24, r24
    2b1a:	49 f0       	breq	.+18     	; 0x2b2e <xQueueSemaphoreTake+0x7e>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2b1c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b1e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b20:	08 96       	adiw	r24, 0x08	; 8
    2b22:	0e 94 e6 21 	call	0x43cc	; 0x43cc <xTaskRemoveFromEventList>
    2b26:	88 23       	and	r24, r24
    2b28:	11 f0       	breq	.+4      	; 0x2b2e <xQueueSemaphoreTake+0x7e>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2b2a:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2b2e:	0f 90       	pop	r0
    2b30:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2b32:	81 e0       	ldi	r24, 0x01	; 1
    2b34:	88 8b       	std	Y+16, r24	; 0x10
    2b36:	6a c0       	rjmp	.+212    	; 0x2c0c <xQueueSemaphoreTake+0x15c>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2b38:	8c 85       	ldd	r24, Y+12	; 0x0c
    2b3a:	9d 85       	ldd	r25, Y+13	; 0x0d
    2b3c:	ae 85       	ldd	r26, Y+14	; 0x0e
    2b3e:	bf 85       	ldd	r27, Y+15	; 0x0f
    2b40:	00 97       	sbiw	r24, 0x00	; 0
    2b42:	a1 05       	cpc	r26, r1
    2b44:	b1 05       	cpc	r27, r1
    2b46:	21 f4       	brne	.+8      	; 0x2b50 <xQueueSemaphoreTake+0xa0>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    2b48:	0f 90       	pop	r0
    2b4a:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2b4c:	18 8a       	std	Y+16, r1	; 0x10
    2b4e:	5e c0       	rjmp	.+188    	; 0x2c0c <xQueueSemaphoreTake+0x15c>
                }
                else if( xEntryTimeSet == pdFALSE )
    2b50:	8c 81       	ldd	r24, Y+4	; 0x04
    2b52:	88 23       	and	r24, r24
    2b54:	31 f4       	brne	.+12     	; 0x2b62 <xQueueSemaphoreTake+0xb2>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2b56:	ce 01       	movw	r24, r28
    2b58:	05 96       	adiw	r24, 0x05	; 5
    2b5a:	0e 94 8c 24 	call	0x4918	; 0x4918 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2b5e:	81 e0       	ldi	r24, 0x01	; 1
    2b60:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2b62:	0f 90       	pop	r0
    2b64:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2b66:	0e 94 9a 1c 	call	0x3934	; 0x3934 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2b6a:	0f b6       	in	r0, 0x3f	; 63
    2b6c:	f8 94       	cli
    2b6e:	0f 92       	push	r0
    2b70:	ea 81       	ldd	r30, Y+2	; 0x02
    2b72:	fb 81       	ldd	r31, Y+3	; 0x03
    2b74:	81 a1       	ldd	r24, Z+33	; 0x21
    2b76:	8f 3f       	cpi	r24, 0xFF	; 255
    2b78:	19 f4       	brne	.+6      	; 0x2b80 <xQueueSemaphoreTake+0xd0>
    2b7a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b7c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b7e:	11 a2       	std	Z+33, r1	; 0x21
    2b80:	ea 81       	ldd	r30, Y+2	; 0x02
    2b82:	fb 81       	ldd	r31, Y+3	; 0x03
    2b84:	82 a1       	ldd	r24, Z+34	; 0x22
    2b86:	8f 3f       	cpi	r24, 0xFF	; 255
    2b88:	19 f4       	brne	.+6      	; 0x2b90 <xQueueSemaphoreTake+0xe0>
    2b8a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b8c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b8e:	12 a2       	std	Z+34, r1	; 0x22
    2b90:	0f 90       	pop	r0
    2b92:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2b94:	ce 01       	movw	r24, r28
    2b96:	05 96       	adiw	r24, 0x05	; 5
    2b98:	9e 01       	movw	r18, r28
    2b9a:	24 5f       	subi	r18, 0xF4	; 244
    2b9c:	3f 4f       	sbci	r19, 0xFF	; 255
    2b9e:	b9 01       	movw	r22, r18
    2ba0:	0e 94 ab 24 	call	0x4956	; 0x4956 <xTaskCheckForTimeOut>
    2ba4:	88 23       	and	r24, r24
    2ba6:	21 f5       	brne	.+72     	; 0x2bf0 <xQueueSemaphoreTake+0x140>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2ba8:	8a 81       	ldd	r24, Y+2	; 0x02
    2baa:	9b 81       	ldd	r25, Y+3	; 0x03
    2bac:	0e 94 88 19 	call	0x3310	; 0x3310 <prvIsQueueEmpty>
    2bb0:	88 23       	and	r24, r24
    2bb2:	b9 f0       	breq	.+46     	; 0x2be2 <xQueueSemaphoreTake+0x132>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2bb4:	8a 81       	ldd	r24, Y+2	; 0x02
    2bb6:	9b 81       	ldd	r25, Y+3	; 0x03
    2bb8:	43 96       	adiw	r24, 0x13	; 19
    2bba:	2c 85       	ldd	r18, Y+12	; 0x0c
    2bbc:	3d 85       	ldd	r19, Y+13	; 0x0d
    2bbe:	4e 85       	ldd	r20, Y+14	; 0x0e
    2bc0:	5f 85       	ldd	r21, Y+15	; 0x0f
    2bc2:	ba 01       	movw	r22, r20
    2bc4:	a9 01       	movw	r20, r18
    2bc6:	0e 94 34 21 	call	0x4268	; 0x4268 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2bca:	8a 81       	ldd	r24, Y+2	; 0x02
    2bcc:	9b 81       	ldd	r25, Y+3	; 0x03
    2bce:	0e 94 35 19 	call	0x326a	; 0x326a <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2bd2:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>
    2bd6:	88 23       	and	r24, r24
    2bd8:	09 f0       	breq	.+2      	; 0x2bdc <xQueueSemaphoreTake+0x12c>
    2bda:	8c cf       	rjmp	.-232    	; 0x2af4 <xQueueSemaphoreTake+0x44>
                {
                    portYIELD_WITHIN_API();
    2bdc:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
    2be0:	89 cf       	rjmp	.-238    	; 0x2af4 <xQueueSemaphoreTake+0x44>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    2be2:	8a 81       	ldd	r24, Y+2	; 0x02
    2be4:	9b 81       	ldd	r25, Y+3	; 0x03
    2be6:	0e 94 35 19 	call	0x326a	; 0x326a <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2bea:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>
    2bee:	82 cf       	rjmp	.-252    	; 0x2af4 <xQueueSemaphoreTake+0x44>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    2bf0:	8a 81       	ldd	r24, Y+2	; 0x02
    2bf2:	9b 81       	ldd	r25, Y+3	; 0x03
    2bf4:	0e 94 35 19 	call	0x326a	; 0x326a <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2bf8:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2bfc:	8a 81       	ldd	r24, Y+2	; 0x02
    2bfe:	9b 81       	ldd	r25, Y+3	; 0x03
    2c00:	0e 94 88 19 	call	0x3310	; 0x3310 <prvIsQueueEmpty>
    2c04:	88 23       	and	r24, r24
    2c06:	09 f4       	brne	.+2      	; 0x2c0a <xQueueSemaphoreTake+0x15a>
    2c08:	75 cf       	rjmp	.-278    	; 0x2af4 <xQueueSemaphoreTake+0x44>
                    }
                }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2c0a:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2c0c:	88 89       	ldd	r24, Y+16	; 0x10
}
    2c0e:	60 96       	adiw	r28, 0x10	; 16
    2c10:	0f b6       	in	r0, 0x3f	; 63
    2c12:	f8 94       	cli
    2c14:	de bf       	out	0x3e, r29	; 62
    2c16:	0f be       	out	0x3f, r0	; 63
    2c18:	cd bf       	out	0x3d, r28	; 61
    2c1a:	cf 91       	pop	r28
    2c1c:	df 91       	pop	r29
    2c1e:	08 95       	ret

00002c20 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    2c20:	df 93       	push	r29
    2c22:	cf 93       	push	r28
    2c24:	cd b7       	in	r28, 0x3d	; 61
    2c26:	de b7       	in	r29, 0x3e	; 62
    2c28:	66 97       	sbiw	r28, 0x16	; 22
    2c2a:	0f b6       	in	r0, 0x3f	; 63
    2c2c:	f8 94       	cli
    2c2e:	de bf       	out	0x3e, r29	; 62
    2c30:	0f be       	out	0x3f, r0	; 63
    2c32:	cd bf       	out	0x3d, r28	; 61
    2c34:	9d 87       	std	Y+13, r25	; 0x0d
    2c36:	8c 87       	std	Y+12, r24	; 0x0c
    2c38:	7f 87       	std	Y+15, r23	; 0x0f
    2c3a:	6e 87       	std	Y+14, r22	; 0x0e
    2c3c:	28 8b       	std	Y+16, r18	; 0x10
    2c3e:	39 8b       	std	Y+17, r19	; 0x11
    2c40:	4a 8b       	std	Y+18, r20	; 0x12
    2c42:	5b 8b       	std	Y+19, r21	; 0x13
    BaseType_t xEntryTimeSet = pdFALSE;
    2c44:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2c46:	8c 85       	ldd	r24, Y+12	; 0x0c
    2c48:	9d 85       	ldd	r25, Y+13	; 0x0d
    2c4a:	9b 83       	std	Y+3, r25	; 0x03
    2c4c:	8a 83       	std	Y+2, r24	; 0x02

    /* Check the pointer is not NULL. */
    configASSERT( ( pxQueue ) );
    2c4e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c50:	9b 81       	ldd	r25, Y+3	; 0x03
    2c52:	00 97       	sbiw	r24, 0x00	; 0
    2c54:	11 f4       	brne	.+4      	; 0x2c5a <xQueuePeek+0x3a>
    2c56:	f8 94       	cli
    2c58:	ff cf       	rjmp	.-2      	; 0x2c58 <xQueuePeek+0x38>

    /* The buffer into which data is received can only be NULL if the data size
     * is zero (so no data is copied into the buffer. */
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    2c5a:	8e 85       	ldd	r24, Y+14	; 0x0e
    2c5c:	9f 85       	ldd	r25, Y+15	; 0x0f
    2c5e:	00 97       	sbiw	r24, 0x00	; 0
    2c60:	29 f4       	brne	.+10     	; 0x2c6c <xQueuePeek+0x4c>
    2c62:	ea 81       	ldd	r30, Y+2	; 0x02
    2c64:	fb 81       	ldd	r31, Y+3	; 0x03
    2c66:	80 a1       	ldd	r24, Z+32	; 0x20
    2c68:	88 23       	and	r24, r24
    2c6a:	29 f4       	brne	.+10     	; 0x2c76 <xQueuePeek+0x56>
    2c6c:	81 e0       	ldi	r24, 0x01	; 1
    2c6e:	90 e0       	ldi	r25, 0x00	; 0
    2c70:	9e 8b       	std	Y+22, r25	; 0x16
    2c72:	8d 8b       	std	Y+21, r24	; 0x15
    2c74:	02 c0       	rjmp	.+4      	; 0x2c7a <xQueuePeek+0x5a>
    2c76:	1e 8a       	std	Y+22, r1	; 0x16
    2c78:	1d 8a       	std	Y+21, r1	; 0x15
    2c7a:	8d 89       	ldd	r24, Y+21	; 0x15
    2c7c:	9e 89       	ldd	r25, Y+22	; 0x16
    2c7e:	00 97       	sbiw	r24, 0x00	; 0
    2c80:	11 f4       	brne	.+4      	; 0x2c86 <xQueuePeek+0x66>
    2c82:	f8 94       	cli
    2c84:	ff cf       	rjmp	.-2      	; 0x2c84 <xQueuePeek+0x64>
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2c86:	0f b6       	in	r0, 0x3f	; 63
    2c88:	f8 94       	cli
    2c8a:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2c8c:	ea 81       	ldd	r30, Y+2	; 0x02
    2c8e:	fb 81       	ldd	r31, Y+3	; 0x03
    2c90:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c92:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2c94:	89 81       	ldd	r24, Y+1	; 0x01
    2c96:	88 23       	and	r24, r24
    2c98:	31 f1       	breq	.+76     	; 0x2ce6 <xQueuePeek+0xc6>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2c9a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c9c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c9e:	86 81       	ldd	r24, Z+6	; 0x06
    2ca0:	97 81       	ldd	r25, Z+7	; 0x07
    2ca2:	9d 83       	std	Y+5, r25	; 0x05
    2ca4:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2ca6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ca8:	9b 81       	ldd	r25, Y+3	; 0x03
    2caa:	2e 85       	ldd	r18, Y+14	; 0x0e
    2cac:	3f 85       	ldd	r19, Y+15	; 0x0f
    2cae:	b9 01       	movw	r22, r18
    2cb0:	0e 94 ee 18 	call	0x31dc	; 0x31dc <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2cb4:	ea 81       	ldd	r30, Y+2	; 0x02
    2cb6:	fb 81       	ldd	r31, Y+3	; 0x03
    2cb8:	8c 81       	ldd	r24, Y+4	; 0x04
    2cba:	9d 81       	ldd	r25, Y+5	; 0x05
    2cbc:	97 83       	std	Z+7, r25	; 0x07
    2cbe:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2cc0:	ea 81       	ldd	r30, Y+2	; 0x02
    2cc2:	fb 81       	ldd	r31, Y+3	; 0x03
    2cc4:	83 89       	ldd	r24, Z+19	; 0x13
    2cc6:	88 23       	and	r24, r24
    2cc8:	49 f0       	breq	.+18     	; 0x2cdc <xQueuePeek+0xbc>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2cca:	8a 81       	ldd	r24, Y+2	; 0x02
    2ccc:	9b 81       	ldd	r25, Y+3	; 0x03
    2cce:	43 96       	adiw	r24, 0x13	; 19
    2cd0:	0e 94 e6 21 	call	0x43cc	; 0x43cc <xTaskRemoveFromEventList>
    2cd4:	88 23       	and	r24, r24
    2cd6:	11 f0       	breq	.+4      	; 0x2cdc <xQueuePeek+0xbc>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    2cd8:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2cdc:	0f 90       	pop	r0
    2cde:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2ce0:	91 e0       	ldi	r25, 0x01	; 1
    2ce2:	9c 8b       	std	Y+20, r25	; 0x14
    2ce4:	6a c0       	rjmp	.+212    	; 0x2dba <xQueuePeek+0x19a>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2ce6:	88 89       	ldd	r24, Y+16	; 0x10
    2ce8:	99 89       	ldd	r25, Y+17	; 0x11
    2cea:	aa 89       	ldd	r26, Y+18	; 0x12
    2cec:	bb 89       	ldd	r27, Y+19	; 0x13
    2cee:	00 97       	sbiw	r24, 0x00	; 0
    2cf0:	a1 05       	cpc	r26, r1
    2cf2:	b1 05       	cpc	r27, r1
    2cf4:	21 f4       	brne	.+8      	; 0x2cfe <xQueuePeek+0xde>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2cf6:	0f 90       	pop	r0
    2cf8:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2cfa:	1c 8a       	std	Y+20, r1	; 0x14
    2cfc:	5e c0       	rjmp	.+188    	; 0x2dba <xQueuePeek+0x19a>
                }
                else if( xEntryTimeSet == pdFALSE )
    2cfe:	8e 81       	ldd	r24, Y+6	; 0x06
    2d00:	88 23       	and	r24, r24
    2d02:	31 f4       	brne	.+12     	; 0x2d10 <xQueuePeek+0xf0>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2d04:	ce 01       	movw	r24, r28
    2d06:	07 96       	adiw	r24, 0x07	; 7
    2d08:	0e 94 8c 24 	call	0x4918	; 0x4918 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2d0c:	81 e0       	ldi	r24, 0x01	; 1
    2d0e:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2d10:	0f 90       	pop	r0
    2d12:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    2d14:	0e 94 9a 1c 	call	0x3934	; 0x3934 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2d18:	0f b6       	in	r0, 0x3f	; 63
    2d1a:	f8 94       	cli
    2d1c:	0f 92       	push	r0
    2d1e:	ea 81       	ldd	r30, Y+2	; 0x02
    2d20:	fb 81       	ldd	r31, Y+3	; 0x03
    2d22:	81 a1       	ldd	r24, Z+33	; 0x21
    2d24:	8f 3f       	cpi	r24, 0xFF	; 255
    2d26:	19 f4       	brne	.+6      	; 0x2d2e <xQueuePeek+0x10e>
    2d28:	ea 81       	ldd	r30, Y+2	; 0x02
    2d2a:	fb 81       	ldd	r31, Y+3	; 0x03
    2d2c:	11 a2       	std	Z+33, r1	; 0x21
    2d2e:	ea 81       	ldd	r30, Y+2	; 0x02
    2d30:	fb 81       	ldd	r31, Y+3	; 0x03
    2d32:	82 a1       	ldd	r24, Z+34	; 0x22
    2d34:	8f 3f       	cpi	r24, 0xFF	; 255
    2d36:	19 f4       	brne	.+6      	; 0x2d3e <xQueuePeek+0x11e>
    2d38:	ea 81       	ldd	r30, Y+2	; 0x02
    2d3a:	fb 81       	ldd	r31, Y+3	; 0x03
    2d3c:	12 a2       	std	Z+34, r1	; 0x22
    2d3e:	0f 90       	pop	r0
    2d40:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2d42:	ce 01       	movw	r24, r28
    2d44:	07 96       	adiw	r24, 0x07	; 7
    2d46:	9e 01       	movw	r18, r28
    2d48:	20 5f       	subi	r18, 0xF0	; 240
    2d4a:	3f 4f       	sbci	r19, 0xFF	; 255
    2d4c:	b9 01       	movw	r22, r18
    2d4e:	0e 94 ab 24 	call	0x4956	; 0x4956 <xTaskCheckForTimeOut>
    2d52:	88 23       	and	r24, r24
    2d54:	21 f5       	brne	.+72     	; 0x2d9e <xQueuePeek+0x17e>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2d56:	8a 81       	ldd	r24, Y+2	; 0x02
    2d58:	9b 81       	ldd	r25, Y+3	; 0x03
    2d5a:	0e 94 88 19 	call	0x3310	; 0x3310 <prvIsQueueEmpty>
    2d5e:	88 23       	and	r24, r24
    2d60:	b9 f0       	breq	.+46     	; 0x2d90 <xQueuePeek+0x170>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2d62:	8a 81       	ldd	r24, Y+2	; 0x02
    2d64:	9b 81       	ldd	r25, Y+3	; 0x03
    2d66:	43 96       	adiw	r24, 0x13	; 19
    2d68:	28 89       	ldd	r18, Y+16	; 0x10
    2d6a:	39 89       	ldd	r19, Y+17	; 0x11
    2d6c:	4a 89       	ldd	r20, Y+18	; 0x12
    2d6e:	5b 89       	ldd	r21, Y+19	; 0x13
    2d70:	ba 01       	movw	r22, r20
    2d72:	a9 01       	movw	r20, r18
    2d74:	0e 94 34 21 	call	0x4268	; 0x4268 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2d78:	8a 81       	ldd	r24, Y+2	; 0x02
    2d7a:	9b 81       	ldd	r25, Y+3	; 0x03
    2d7c:	0e 94 35 19 	call	0x326a	; 0x326a <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2d80:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>
    2d84:	88 23       	and	r24, r24
    2d86:	09 f0       	breq	.+2      	; 0x2d8a <xQueuePeek+0x16a>
    2d88:	7e cf       	rjmp	.-260    	; 0x2c86 <xQueuePeek+0x66>
                {
                    portYIELD_WITHIN_API();
    2d8a:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
    2d8e:	7b cf       	rjmp	.-266    	; 0x2c86 <xQueuePeek+0x66>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    2d90:	8a 81       	ldd	r24, Y+2	; 0x02
    2d92:	9b 81       	ldd	r25, Y+3	; 0x03
    2d94:	0e 94 35 19 	call	0x326a	; 0x326a <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2d98:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>
    2d9c:	74 cf       	rjmp	.-280    	; 0x2c86 <xQueuePeek+0x66>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    2d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    2da0:	9b 81       	ldd	r25, Y+3	; 0x03
    2da2:	0e 94 35 19 	call	0x326a	; 0x326a <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2da6:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2daa:	8a 81       	ldd	r24, Y+2	; 0x02
    2dac:	9b 81       	ldd	r25, Y+3	; 0x03
    2dae:	0e 94 88 19 	call	0x3310	; 0x3310 <prvIsQueueEmpty>
    2db2:	88 23       	and	r24, r24
    2db4:	09 f4       	brne	.+2      	; 0x2db8 <xQueuePeek+0x198>
    2db6:	67 cf       	rjmp	.-306    	; 0x2c86 <xQueuePeek+0x66>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2db8:	1c 8a       	std	Y+20, r1	; 0x14
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2dba:	8c 89       	ldd	r24, Y+20	; 0x14
}
    2dbc:	66 96       	adiw	r28, 0x16	; 22
    2dbe:	0f b6       	in	r0, 0x3f	; 63
    2dc0:	f8 94       	cli
    2dc2:	de bf       	out	0x3e, r29	; 62
    2dc4:	0f be       	out	0x3f, r0	; 63
    2dc6:	cd bf       	out	0x3d, r28	; 61
    2dc8:	cf 91       	pop	r28
    2dca:	df 91       	pop	r29
    2dcc:	08 95       	ret

00002dce <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2dce:	df 93       	push	r29
    2dd0:	cf 93       	push	r28
    2dd2:	cd b7       	in	r28, 0x3d	; 61
    2dd4:	de b7       	in	r29, 0x3e	; 62
    2dd6:	2f 97       	sbiw	r28, 0x0f	; 15
    2dd8:	0f b6       	in	r0, 0x3f	; 63
    2dda:	f8 94       	cli
    2ddc:	de bf       	out	0x3e, r29	; 62
    2dde:	0f be       	out	0x3f, r0	; 63
    2de0:	cd bf       	out	0x3d, r28	; 61
    2de2:	99 87       	std	Y+9, r25	; 0x09
    2de4:	88 87       	std	Y+8, r24	; 0x08
    2de6:	7b 87       	std	Y+11, r23	; 0x0b
    2de8:	6a 87       	std	Y+10, r22	; 0x0a
    2dea:	5d 87       	std	Y+13, r21	; 0x0d
    2dec:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2dee:	88 85       	ldd	r24, Y+8	; 0x08
    2df0:	99 85       	ldd	r25, Y+9	; 0x09
    2df2:	9d 83       	std	Y+5, r25	; 0x05
    2df4:	8c 83       	std	Y+4, r24	; 0x04

    configASSERT( pxQueue );
    2df6:	8c 81       	ldd	r24, Y+4	; 0x04
    2df8:	9d 81       	ldd	r25, Y+5	; 0x05
    2dfa:	00 97       	sbiw	r24, 0x00	; 0
    2dfc:	11 f4       	brne	.+4      	; 0x2e02 <xQueueReceiveFromISR+0x34>
    2dfe:	f8 94       	cli
    2e00:	ff cf       	rjmp	.-2      	; 0x2e00 <xQueueReceiveFromISR+0x32>
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    2e02:	8a 85       	ldd	r24, Y+10	; 0x0a
    2e04:	9b 85       	ldd	r25, Y+11	; 0x0b
    2e06:	00 97       	sbiw	r24, 0x00	; 0
    2e08:	29 f4       	brne	.+10     	; 0x2e14 <xQueueReceiveFromISR+0x46>
    2e0a:	ec 81       	ldd	r30, Y+4	; 0x04
    2e0c:	fd 81       	ldd	r31, Y+5	; 0x05
    2e0e:	80 a1       	ldd	r24, Z+32	; 0x20
    2e10:	88 23       	and	r24, r24
    2e12:	29 f4       	brne	.+10     	; 0x2e1e <xQueueReceiveFromISR+0x50>
    2e14:	81 e0       	ldi	r24, 0x01	; 1
    2e16:	90 e0       	ldi	r25, 0x00	; 0
    2e18:	9f 87       	std	Y+15, r25	; 0x0f
    2e1a:	8e 87       	std	Y+14, r24	; 0x0e
    2e1c:	02 c0       	rjmp	.+4      	; 0x2e22 <xQueueReceiveFromISR+0x54>
    2e1e:	1f 86       	std	Y+15, r1	; 0x0f
    2e20:	1e 86       	std	Y+14, r1	; 0x0e
    2e22:	8e 85       	ldd	r24, Y+14	; 0x0e
    2e24:	9f 85       	ldd	r25, Y+15	; 0x0f
    2e26:	00 97       	sbiw	r24, 0x00	; 0
    2e28:	11 f4       	brne	.+4      	; 0x2e2e <xQueueReceiveFromISR+0x60>
    2e2a:	f8 94       	cli
    2e2c:	ff cf       	rjmp	.-2      	; 0x2e2c <xQueueReceiveFromISR+0x5e>
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2e2e:	1e 82       	std	Y+6, r1	; 0x06
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2e30:	ec 81       	ldd	r30, Y+4	; 0x04
    2e32:	fd 81       	ldd	r31, Y+5	; 0x05
    2e34:	86 8d       	ldd	r24, Z+30	; 0x1e
    2e36:	8b 83       	std	Y+3, r24	; 0x03

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2e38:	8b 81       	ldd	r24, Y+3	; 0x03
    2e3a:	88 23       	and	r24, r24
    2e3c:	e1 f1       	breq	.+120    	; 0x2eb6 <xQueueReceiveFromISR+0xe8>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    2e3e:	ec 81       	ldd	r30, Y+4	; 0x04
    2e40:	fd 81       	ldd	r31, Y+5	; 0x05
    2e42:	81 a1       	ldd	r24, Z+33	; 0x21
    2e44:	8a 83       	std	Y+2, r24	; 0x02

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2e46:	8c 81       	ldd	r24, Y+4	; 0x04
    2e48:	9d 81       	ldd	r25, Y+5	; 0x05
    2e4a:	2a 85       	ldd	r18, Y+10	; 0x0a
    2e4c:	3b 85       	ldd	r19, Y+11	; 0x0b
    2e4e:	b9 01       	movw	r22, r18
    2e50:	0e 94 ee 18 	call	0x31dc	; 0x31dc <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2e54:	8b 81       	ldd	r24, Y+3	; 0x03
    2e56:	81 50       	subi	r24, 0x01	; 1
    2e58:	ec 81       	ldd	r30, Y+4	; 0x04
    2e5a:	fd 81       	ldd	r31, Y+5	; 0x05
    2e5c:	86 8f       	std	Z+30, r24	; 0x1e

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    2e5e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e60:	8f 3f       	cpi	r24, 0xFF	; 255
    2e62:	a9 f4       	brne	.+42     	; 0x2e8e <xQueueReceiveFromISR+0xc0>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2e64:	ec 81       	ldd	r30, Y+4	; 0x04
    2e66:	fd 81       	ldd	r31, Y+5	; 0x05
    2e68:	80 85       	ldd	r24, Z+8	; 0x08
    2e6a:	88 23       	and	r24, r24
    2e6c:	09 f1       	breq	.+66     	; 0x2eb0 <xQueueReceiveFromISR+0xe2>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2e6e:	8c 81       	ldd	r24, Y+4	; 0x04
    2e70:	9d 81       	ldd	r25, Y+5	; 0x05
    2e72:	08 96       	adiw	r24, 0x08	; 8
    2e74:	0e 94 e6 21 	call	0x43cc	; 0x43cc <xTaskRemoveFromEventList>
    2e78:	88 23       	and	r24, r24
    2e7a:	d1 f0       	breq	.+52     	; 0x2eb0 <xQueueReceiveFromISR+0xe2>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    2e7c:	8c 85       	ldd	r24, Y+12	; 0x0c
    2e7e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2e80:	00 97       	sbiw	r24, 0x00	; 0
    2e82:	b1 f0       	breq	.+44     	; 0x2eb0 <xQueueReceiveFromISR+0xe2>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    2e84:	ec 85       	ldd	r30, Y+12	; 0x0c
    2e86:	fd 85       	ldd	r31, Y+13	; 0x0d
    2e88:	81 e0       	ldi	r24, 0x01	; 1
    2e8a:	80 83       	st	Z, r24
    2e8c:	11 c0       	rjmp	.+34     	; 0x2eb0 <xQueueReceiveFromISR+0xe2>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
    2e8e:	0e 94 63 1e 	call	0x3cc6	; 0x3cc6 <uxTaskGetNumberOfTasks>
    2e92:	89 83       	std	Y+1, r24	; 0x01
    2e94:	9a 81       	ldd	r25, Y+2	; 0x02
    2e96:	89 81       	ldd	r24, Y+1	; 0x01
    2e98:	98 17       	cp	r25, r24
    2e9a:	50 f4       	brcc	.+20     	; 0x2eb0 <xQueueReceiveFromISR+0xe2>
    2e9c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e9e:	8f 37       	cpi	r24, 0x7F	; 127
    2ea0:	11 f4       	brne	.+4      	; 0x2ea6 <xQueueReceiveFromISR+0xd8>
    2ea2:	f8 94       	cli
    2ea4:	ff cf       	rjmp	.-2      	; 0x2ea4 <xQueueReceiveFromISR+0xd6>
    2ea6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea8:	8f 5f       	subi	r24, 0xFF	; 255
    2eaa:	ec 81       	ldd	r30, Y+4	; 0x04
    2eac:	fd 81       	ldd	r31, Y+5	; 0x05
    2eae:	81 a3       	std	Z+33, r24	; 0x21
            }

            xReturn = pdPASS;
    2eb0:	81 e0       	ldi	r24, 0x01	; 1
    2eb2:	8f 83       	std	Y+7, r24	; 0x07
    2eb4:	01 c0       	rjmp	.+2      	; 0x2eb8 <xQueueReceiveFromISR+0xea>
        }
        else
        {
            xReturn = pdFAIL;
    2eb6:	1f 82       	std	Y+7, r1	; 0x07
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2eb8:	8f 81       	ldd	r24, Y+7	; 0x07
}
    2eba:	2f 96       	adiw	r28, 0x0f	; 15
    2ebc:	0f b6       	in	r0, 0x3f	; 63
    2ebe:	f8 94       	cli
    2ec0:	de bf       	out	0x3e, r29	; 62
    2ec2:	0f be       	out	0x3f, r0	; 63
    2ec4:	cd bf       	out	0x3d, r28	; 61
    2ec6:	cf 91       	pop	r28
    2ec8:	df 91       	pop	r29
    2eca:	08 95       	ret

00002ecc <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    2ecc:	df 93       	push	r29
    2ece:	cf 93       	push	r28
    2ed0:	cd b7       	in	r28, 0x3d	; 61
    2ed2:	de b7       	in	r29, 0x3e	; 62
    2ed4:	2c 97       	sbiw	r28, 0x0c	; 12
    2ed6:	0f b6       	in	r0, 0x3f	; 63
    2ed8:	f8 94       	cli
    2eda:	de bf       	out	0x3e, r29	; 62
    2edc:	0f be       	out	0x3f, r0	; 63
    2ede:	cd bf       	out	0x3d, r28	; 61
    2ee0:	98 87       	std	Y+8, r25	; 0x08
    2ee2:	8f 83       	std	Y+7, r24	; 0x07
    2ee4:	7a 87       	std	Y+10, r23	; 0x0a
    2ee6:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2ee8:	8f 81       	ldd	r24, Y+7	; 0x07
    2eea:	98 85       	ldd	r25, Y+8	; 0x08
    2eec:	9a 83       	std	Y+2, r25	; 0x02
    2eee:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    2ef0:	89 81       	ldd	r24, Y+1	; 0x01
    2ef2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ef4:	00 97       	sbiw	r24, 0x00	; 0
    2ef6:	11 f4       	brne	.+4      	; 0x2efc <xQueuePeekFromISR+0x30>
    2ef8:	f8 94       	cli
    2efa:	ff cf       	rjmp	.-2      	; 0x2efa <xQueuePeekFromISR+0x2e>
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    2efc:	89 85       	ldd	r24, Y+9	; 0x09
    2efe:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f00:	00 97       	sbiw	r24, 0x00	; 0
    2f02:	29 f4       	brne	.+10     	; 0x2f0e <xQueuePeekFromISR+0x42>
    2f04:	e9 81       	ldd	r30, Y+1	; 0x01
    2f06:	fa 81       	ldd	r31, Y+2	; 0x02
    2f08:	80 a1       	ldd	r24, Z+32	; 0x20
    2f0a:	88 23       	and	r24, r24
    2f0c:	29 f4       	brne	.+10     	; 0x2f18 <xQueuePeekFromISR+0x4c>
    2f0e:	81 e0       	ldi	r24, 0x01	; 1
    2f10:	90 e0       	ldi	r25, 0x00	; 0
    2f12:	9c 87       	std	Y+12, r25	; 0x0c
    2f14:	8b 87       	std	Y+11, r24	; 0x0b
    2f16:	02 c0       	rjmp	.+4      	; 0x2f1c <xQueuePeekFromISR+0x50>
    2f18:	1c 86       	std	Y+12, r1	; 0x0c
    2f1a:	1b 86       	std	Y+11, r1	; 0x0b
    2f1c:	8b 85       	ldd	r24, Y+11	; 0x0b
    2f1e:	9c 85       	ldd	r25, Y+12	; 0x0c
    2f20:	00 97       	sbiw	r24, 0x00	; 0
    2f22:	11 f4       	brne	.+4      	; 0x2f28 <xQueuePeekFromISR+0x5c>
    2f24:	f8 94       	cli
    2f26:	ff cf       	rjmp	.-2      	; 0x2f26 <xQueuePeekFromISR+0x5a>
    configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
    2f28:	e9 81       	ldd	r30, Y+1	; 0x01
    2f2a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f2c:	80 a1       	ldd	r24, Z+32	; 0x20
    2f2e:	88 23       	and	r24, r24
    2f30:	11 f4       	brne	.+4      	; 0x2f36 <xQueuePeekFromISR+0x6a>
    2f32:	f8 94       	cli
    2f34:	ff cf       	rjmp	.-2      	; 0x2f34 <xQueuePeekFromISR+0x68>
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2f36:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2f38:	e9 81       	ldd	r30, Y+1	; 0x01
    2f3a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f3c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f3e:	88 23       	and	r24, r24
    2f40:	b1 f0       	breq	.+44     	; 0x2f6e <xQueuePeekFromISR+0xa2>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2f42:	e9 81       	ldd	r30, Y+1	; 0x01
    2f44:	fa 81       	ldd	r31, Y+2	; 0x02
    2f46:	86 81       	ldd	r24, Z+6	; 0x06
    2f48:	97 81       	ldd	r25, Z+7	; 0x07
    2f4a:	9c 83       	std	Y+4, r25	; 0x04
    2f4c:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2f4e:	89 81       	ldd	r24, Y+1	; 0x01
    2f50:	9a 81       	ldd	r25, Y+2	; 0x02
    2f52:	29 85       	ldd	r18, Y+9	; 0x09
    2f54:	3a 85       	ldd	r19, Y+10	; 0x0a
    2f56:	b9 01       	movw	r22, r18
    2f58:	0e 94 ee 18 	call	0x31dc	; 0x31dc <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2f5c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f5e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f60:	8b 81       	ldd	r24, Y+3	; 0x03
    2f62:	9c 81       	ldd	r25, Y+4	; 0x04
    2f64:	97 83       	std	Z+7, r25	; 0x07
    2f66:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    2f68:	81 e0       	ldi	r24, 0x01	; 1
    2f6a:	8e 83       	std	Y+6, r24	; 0x06
    2f6c:	01 c0       	rjmp	.+2      	; 0x2f70 <xQueuePeekFromISR+0xa4>
        }
        else
        {
            xReturn = pdFAIL;
    2f6e:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2f70:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2f72:	2c 96       	adiw	r28, 0x0c	; 12
    2f74:	0f b6       	in	r0, 0x3f	; 63
    2f76:	f8 94       	cli
    2f78:	de bf       	out	0x3e, r29	; 62
    2f7a:	0f be       	out	0x3f, r0	; 63
    2f7c:	cd bf       	out	0x3d, r28	; 61
    2f7e:	cf 91       	pop	r28
    2f80:	df 91       	pop	r29
    2f82:	08 95       	ret

00002f84 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2f84:	df 93       	push	r29
    2f86:	cf 93       	push	r28
    2f88:	00 d0       	rcall	.+0      	; 0x2f8a <uxQueueMessagesWaiting+0x6>
    2f8a:	0f 92       	push	r0
    2f8c:	cd b7       	in	r28, 0x3d	; 61
    2f8e:	de b7       	in	r29, 0x3e	; 62
    2f90:	9b 83       	std	Y+3, r25	; 0x03
    2f92:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );
    2f94:	8a 81       	ldd	r24, Y+2	; 0x02
    2f96:	9b 81       	ldd	r25, Y+3	; 0x03
    2f98:	00 97       	sbiw	r24, 0x00	; 0
    2f9a:	11 f4       	brne	.+4      	; 0x2fa0 <uxQueueMessagesWaiting+0x1c>
    2f9c:	f8 94       	cli
    2f9e:	ff cf       	rjmp	.-2      	; 0x2f9e <uxQueueMessagesWaiting+0x1a>

    taskENTER_CRITICAL();
    2fa0:	0f b6       	in	r0, 0x3f	; 63
    2fa2:	f8 94       	cli
    2fa4:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2fa6:	ea 81       	ldd	r30, Y+2	; 0x02
    2fa8:	fb 81       	ldd	r31, Y+3	; 0x03
    2faa:	86 8d       	ldd	r24, Z+30	; 0x1e
    2fac:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    2fae:	0f 90       	pop	r0
    2fb0:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2fb2:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2fb4:	0f 90       	pop	r0
    2fb6:	0f 90       	pop	r0
    2fb8:	0f 90       	pop	r0
    2fba:	cf 91       	pop	r28
    2fbc:	df 91       	pop	r29
    2fbe:	08 95       	ret

00002fc0 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2fc0:	df 93       	push	r29
    2fc2:	cf 93       	push	r28
    2fc4:	00 d0       	rcall	.+0      	; 0x2fc6 <uxQueueSpacesAvailable+0x6>
    2fc6:	00 d0       	rcall	.+0      	; 0x2fc8 <uxQueueSpacesAvailable+0x8>
    2fc8:	0f 92       	push	r0
    2fca:	cd b7       	in	r28, 0x3d	; 61
    2fcc:	de b7       	in	r29, 0x3e	; 62
    2fce:	9d 83       	std	Y+5, r25	; 0x05
    2fd0:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2fd2:	8c 81       	ldd	r24, Y+4	; 0x04
    2fd4:	9d 81       	ldd	r25, Y+5	; 0x05
    2fd6:	9a 83       	std	Y+2, r25	; 0x02
    2fd8:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    2fda:	89 81       	ldd	r24, Y+1	; 0x01
    2fdc:	9a 81       	ldd	r25, Y+2	; 0x02
    2fde:	00 97       	sbiw	r24, 0x00	; 0
    2fe0:	11 f4       	brne	.+4      	; 0x2fe6 <uxQueueSpacesAvailable+0x26>
    2fe2:	f8 94       	cli
    2fe4:	ff cf       	rjmp	.-2      	; 0x2fe4 <uxQueueSpacesAvailable+0x24>

    taskENTER_CRITICAL();
    2fe6:	0f b6       	in	r0, 0x3f	; 63
    2fe8:	f8 94       	cli
    2fea:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2fec:	e9 81       	ldd	r30, Y+1	; 0x01
    2fee:	fa 81       	ldd	r31, Y+2	; 0x02
    2ff0:	97 8d       	ldd	r25, Z+31	; 0x1f
    2ff2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ff4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ff6:	86 8d       	ldd	r24, Z+30	; 0x1e
    2ff8:	29 2f       	mov	r18, r25
    2ffa:	28 1b       	sub	r18, r24
    2ffc:	82 2f       	mov	r24, r18
    2ffe:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    3000:	0f 90       	pop	r0
    3002:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    3004:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3006:	0f 90       	pop	r0
    3008:	0f 90       	pop	r0
    300a:	0f 90       	pop	r0
    300c:	0f 90       	pop	r0
    300e:	0f 90       	pop	r0
    3010:	cf 91       	pop	r28
    3012:	df 91       	pop	r29
    3014:	08 95       	ret

00003016 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3016:	df 93       	push	r29
    3018:	cf 93       	push	r28
    301a:	00 d0       	rcall	.+0      	; 0x301c <uxQueueMessagesWaitingFromISR+0x6>
    301c:	00 d0       	rcall	.+0      	; 0x301e <uxQueueMessagesWaitingFromISR+0x8>
    301e:	0f 92       	push	r0
    3020:	cd b7       	in	r28, 0x3d	; 61
    3022:	de b7       	in	r29, 0x3e	; 62
    3024:	9d 83       	std	Y+5, r25	; 0x05
    3026:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    3028:	8c 81       	ldd	r24, Y+4	; 0x04
    302a:	9d 81       	ldd	r25, Y+5	; 0x05
    302c:	9a 83       	std	Y+2, r25	; 0x02
    302e:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    3030:	89 81       	ldd	r24, Y+1	; 0x01
    3032:	9a 81       	ldd	r25, Y+2	; 0x02
    3034:	00 97       	sbiw	r24, 0x00	; 0
    3036:	11 f4       	brne	.+4      	; 0x303c <uxQueueMessagesWaitingFromISR+0x26>
    3038:	f8 94       	cli
    303a:	ff cf       	rjmp	.-2      	; 0x303a <uxQueueMessagesWaitingFromISR+0x24>
    uxReturn = pxQueue->uxMessagesWaiting;
    303c:	e9 81       	ldd	r30, Y+1	; 0x01
    303e:	fa 81       	ldd	r31, Y+2	; 0x02
    3040:	86 8d       	ldd	r24, Z+30	; 0x1e
    3042:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    3044:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3046:	0f 90       	pop	r0
    3048:	0f 90       	pop	r0
    304a:	0f 90       	pop	r0
    304c:	0f 90       	pop	r0
    304e:	0f 90       	pop	r0
    3050:	cf 91       	pop	r28
    3052:	df 91       	pop	r29
    3054:	08 95       	ret

00003056 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3056:	df 93       	push	r29
    3058:	cf 93       	push	r28
    305a:	00 d0       	rcall	.+0      	; 0x305c <vQueueDelete+0x6>
    305c:	00 d0       	rcall	.+0      	; 0x305e <vQueueDelete+0x8>
    305e:	cd b7       	in	r28, 0x3d	; 61
    3060:	de b7       	in	r29, 0x3e	; 62
    3062:	9c 83       	std	Y+4, r25	; 0x04
    3064:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    3066:	8b 81       	ldd	r24, Y+3	; 0x03
    3068:	9c 81       	ldd	r25, Y+4	; 0x04
    306a:	9a 83       	std	Y+2, r25	; 0x02
    306c:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    306e:	89 81       	ldd	r24, Y+1	; 0x01
    3070:	9a 81       	ldd	r25, Y+2	; 0x02
    3072:	00 97       	sbiw	r24, 0x00	; 0
    3074:	11 f4       	brne	.+4      	; 0x307a <vQueueDelete+0x24>
    3076:	f8 94       	cli
    3078:	ff cf       	rjmp	.-2      	; 0x3078 <vQueueDelete+0x22>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
    307a:	89 81       	ldd	r24, Y+1	; 0x01
    307c:	9a 81       	ldd	r25, Y+2	; 0x02
    307e:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3082:	0f 90       	pop	r0
    3084:	0f 90       	pop	r0
    3086:	0f 90       	pop	r0
    3088:	0f 90       	pop	r0
    308a:	cf 91       	pop	r28
    308c:	df 91       	pop	r29
    308e:	08 95       	ret

00003090 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    3090:	df 93       	push	r29
    3092:	cf 93       	push	r28
    3094:	cd b7       	in	r28, 0x3d	; 61
    3096:	de b7       	in	r29, 0x3e	; 62
    3098:	27 97       	sbiw	r28, 0x07	; 7
    309a:	0f b6       	in	r0, 0x3f	; 63
    309c:	f8 94       	cli
    309e:	de bf       	out	0x3e, r29	; 62
    30a0:	0f be       	out	0x3f, r0	; 63
    30a2:	cd bf       	out	0x3d, r28	; 61
    30a4:	9c 83       	std	Y+4, r25	; 0x04
    30a6:	8b 83       	std	Y+3, r24	; 0x03
    30a8:	7e 83       	std	Y+6, r23	; 0x06
    30aa:	6d 83       	std	Y+5, r22	; 0x05
    30ac:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    30ae:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    30b0:	eb 81       	ldd	r30, Y+3	; 0x03
    30b2:	fc 81       	ldd	r31, Y+4	; 0x04
    30b4:	86 8d       	ldd	r24, Z+30	; 0x1e
    30b6:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    30b8:	eb 81       	ldd	r30, Y+3	; 0x03
    30ba:	fc 81       	ldd	r31, Y+4	; 0x04
    30bc:	80 a1       	ldd	r24, Z+32	; 0x20
    30be:	88 23       	and	r24, r24
    30c0:	09 f4       	brne	.+2      	; 0x30c4 <prvCopyDataToQueue+0x34>
    30c2:	7d c0       	rjmp	.+250    	; 0x31be <prvCopyDataToQueue+0x12e>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    30c4:	8f 81       	ldd	r24, Y+7	; 0x07
    30c6:	88 23       	and	r24, r24
    30c8:	99 f5       	brne	.+102    	; 0x3130 <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    30ca:	eb 81       	ldd	r30, Y+3	; 0x03
    30cc:	fc 81       	ldd	r31, Y+4	; 0x04
    30ce:	62 81       	ldd	r22, Z+2	; 0x02
    30d0:	73 81       	ldd	r23, Z+3	; 0x03
    30d2:	eb 81       	ldd	r30, Y+3	; 0x03
    30d4:	fc 81       	ldd	r31, Y+4	; 0x04
    30d6:	80 a1       	ldd	r24, Z+32	; 0x20
    30d8:	48 2f       	mov	r20, r24
    30da:	50 e0       	ldi	r21, 0x00	; 0
    30dc:	2d 81       	ldd	r18, Y+5	; 0x05
    30de:	3e 81       	ldd	r19, Y+6	; 0x06
    30e0:	cb 01       	movw	r24, r22
    30e2:	b9 01       	movw	r22, r18
    30e4:	0e 94 17 40 	call	0x802e	; 0x802e <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    30e8:	eb 81       	ldd	r30, Y+3	; 0x03
    30ea:	fc 81       	ldd	r31, Y+4	; 0x04
    30ec:	22 81       	ldd	r18, Z+2	; 0x02
    30ee:	33 81       	ldd	r19, Z+3	; 0x03
    30f0:	eb 81       	ldd	r30, Y+3	; 0x03
    30f2:	fc 81       	ldd	r31, Y+4	; 0x04
    30f4:	80 a1       	ldd	r24, Z+32	; 0x20
    30f6:	88 2f       	mov	r24, r24
    30f8:	90 e0       	ldi	r25, 0x00	; 0
    30fa:	82 0f       	add	r24, r18
    30fc:	93 1f       	adc	r25, r19
    30fe:	eb 81       	ldd	r30, Y+3	; 0x03
    3100:	fc 81       	ldd	r31, Y+4	; 0x04
    3102:	93 83       	std	Z+3, r25	; 0x03
    3104:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3106:	eb 81       	ldd	r30, Y+3	; 0x03
    3108:	fc 81       	ldd	r31, Y+4	; 0x04
    310a:	22 81       	ldd	r18, Z+2	; 0x02
    310c:	33 81       	ldd	r19, Z+3	; 0x03
    310e:	eb 81       	ldd	r30, Y+3	; 0x03
    3110:	fc 81       	ldd	r31, Y+4	; 0x04
    3112:	84 81       	ldd	r24, Z+4	; 0x04
    3114:	95 81       	ldd	r25, Z+5	; 0x05
    3116:	28 17       	cp	r18, r24
    3118:	39 07       	cpc	r19, r25
    311a:	08 f4       	brcc	.+2      	; 0x311e <prvCopyDataToQueue+0x8e>
    311c:	50 c0       	rjmp	.+160    	; 0x31be <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    311e:	eb 81       	ldd	r30, Y+3	; 0x03
    3120:	fc 81       	ldd	r31, Y+4	; 0x04
    3122:	80 81       	ld	r24, Z
    3124:	91 81       	ldd	r25, Z+1	; 0x01
    3126:	eb 81       	ldd	r30, Y+3	; 0x03
    3128:	fc 81       	ldd	r31, Y+4	; 0x04
    312a:	93 83       	std	Z+3, r25	; 0x03
    312c:	82 83       	std	Z+2, r24	; 0x02
    312e:	47 c0       	rjmp	.+142    	; 0x31be <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3130:	eb 81       	ldd	r30, Y+3	; 0x03
    3132:	fc 81       	ldd	r31, Y+4	; 0x04
    3134:	66 81       	ldd	r22, Z+6	; 0x06
    3136:	77 81       	ldd	r23, Z+7	; 0x07
    3138:	eb 81       	ldd	r30, Y+3	; 0x03
    313a:	fc 81       	ldd	r31, Y+4	; 0x04
    313c:	80 a1       	ldd	r24, Z+32	; 0x20
    313e:	48 2f       	mov	r20, r24
    3140:	50 e0       	ldi	r21, 0x00	; 0
    3142:	2d 81       	ldd	r18, Y+5	; 0x05
    3144:	3e 81       	ldd	r19, Y+6	; 0x06
    3146:	cb 01       	movw	r24, r22
    3148:	b9 01       	movw	r22, r18
    314a:	0e 94 17 40 	call	0x802e	; 0x802e <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    314e:	eb 81       	ldd	r30, Y+3	; 0x03
    3150:	fc 81       	ldd	r31, Y+4	; 0x04
    3152:	26 81       	ldd	r18, Z+6	; 0x06
    3154:	37 81       	ldd	r19, Z+7	; 0x07
    3156:	eb 81       	ldd	r30, Y+3	; 0x03
    3158:	fc 81       	ldd	r31, Y+4	; 0x04
    315a:	80 a1       	ldd	r24, Z+32	; 0x20
    315c:	88 2f       	mov	r24, r24
    315e:	90 e0       	ldi	r25, 0x00	; 0
    3160:	90 95       	com	r25
    3162:	81 95       	neg	r24
    3164:	9f 4f       	sbci	r25, 0xFF	; 255
    3166:	82 0f       	add	r24, r18
    3168:	93 1f       	adc	r25, r19
    316a:	eb 81       	ldd	r30, Y+3	; 0x03
    316c:	fc 81       	ldd	r31, Y+4	; 0x04
    316e:	97 83       	std	Z+7, r25	; 0x07
    3170:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3172:	eb 81       	ldd	r30, Y+3	; 0x03
    3174:	fc 81       	ldd	r31, Y+4	; 0x04
    3176:	26 81       	ldd	r18, Z+6	; 0x06
    3178:	37 81       	ldd	r19, Z+7	; 0x07
    317a:	eb 81       	ldd	r30, Y+3	; 0x03
    317c:	fc 81       	ldd	r31, Y+4	; 0x04
    317e:	80 81       	ld	r24, Z
    3180:	91 81       	ldd	r25, Z+1	; 0x01
    3182:	28 17       	cp	r18, r24
    3184:	39 07       	cpc	r19, r25
    3186:	90 f4       	brcc	.+36     	; 0x31ac <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3188:	eb 81       	ldd	r30, Y+3	; 0x03
    318a:	fc 81       	ldd	r31, Y+4	; 0x04
    318c:	24 81       	ldd	r18, Z+4	; 0x04
    318e:	35 81       	ldd	r19, Z+5	; 0x05
    3190:	eb 81       	ldd	r30, Y+3	; 0x03
    3192:	fc 81       	ldd	r31, Y+4	; 0x04
    3194:	80 a1       	ldd	r24, Z+32	; 0x20
    3196:	88 2f       	mov	r24, r24
    3198:	90 e0       	ldi	r25, 0x00	; 0
    319a:	90 95       	com	r25
    319c:	81 95       	neg	r24
    319e:	9f 4f       	sbci	r25, 0xFF	; 255
    31a0:	82 0f       	add	r24, r18
    31a2:	93 1f       	adc	r25, r19
    31a4:	eb 81       	ldd	r30, Y+3	; 0x03
    31a6:	fc 81       	ldd	r31, Y+4	; 0x04
    31a8:	97 83       	std	Z+7, r25	; 0x07
    31aa:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    31ac:	8f 81       	ldd	r24, Y+7	; 0x07
    31ae:	82 30       	cpi	r24, 0x02	; 2
    31b0:	31 f4       	brne	.+12     	; 0x31be <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    31b2:	89 81       	ldd	r24, Y+1	; 0x01
    31b4:	88 23       	and	r24, r24
    31b6:	19 f0       	breq	.+6      	; 0x31be <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    31b8:	89 81       	ldd	r24, Y+1	; 0x01
    31ba:	81 50       	subi	r24, 0x01	; 1
    31bc:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    31be:	89 81       	ldd	r24, Y+1	; 0x01
    31c0:	8f 5f       	subi	r24, 0xFF	; 255
    31c2:	eb 81       	ldd	r30, Y+3	; 0x03
    31c4:	fc 81       	ldd	r31, Y+4	; 0x04
    31c6:	86 8f       	std	Z+30, r24	; 0x1e

    return xReturn;
    31c8:	8a 81       	ldd	r24, Y+2	; 0x02
}
    31ca:	27 96       	adiw	r28, 0x07	; 7
    31cc:	0f b6       	in	r0, 0x3f	; 63
    31ce:	f8 94       	cli
    31d0:	de bf       	out	0x3e, r29	; 62
    31d2:	0f be       	out	0x3f, r0	; 63
    31d4:	cd bf       	out	0x3d, r28	; 61
    31d6:	cf 91       	pop	r28
    31d8:	df 91       	pop	r29
    31da:	08 95       	ret

000031dc <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    31dc:	df 93       	push	r29
    31de:	cf 93       	push	r28
    31e0:	00 d0       	rcall	.+0      	; 0x31e2 <prvCopyDataFromQueue+0x6>
    31e2:	00 d0       	rcall	.+0      	; 0x31e4 <prvCopyDataFromQueue+0x8>
    31e4:	cd b7       	in	r28, 0x3d	; 61
    31e6:	de b7       	in	r29, 0x3e	; 62
    31e8:	9a 83       	std	Y+2, r25	; 0x02
    31ea:	89 83       	std	Y+1, r24	; 0x01
    31ec:	7c 83       	std	Y+4, r23	; 0x04
    31ee:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    31f0:	e9 81       	ldd	r30, Y+1	; 0x01
    31f2:	fa 81       	ldd	r31, Y+2	; 0x02
    31f4:	80 a1       	ldd	r24, Z+32	; 0x20
    31f6:	88 23       	and	r24, r24
    31f8:	89 f1       	breq	.+98     	; 0x325c <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    31fa:	e9 81       	ldd	r30, Y+1	; 0x01
    31fc:	fa 81       	ldd	r31, Y+2	; 0x02
    31fe:	26 81       	ldd	r18, Z+6	; 0x06
    3200:	37 81       	ldd	r19, Z+7	; 0x07
    3202:	e9 81       	ldd	r30, Y+1	; 0x01
    3204:	fa 81       	ldd	r31, Y+2	; 0x02
    3206:	80 a1       	ldd	r24, Z+32	; 0x20
    3208:	88 2f       	mov	r24, r24
    320a:	90 e0       	ldi	r25, 0x00	; 0
    320c:	82 0f       	add	r24, r18
    320e:	93 1f       	adc	r25, r19
    3210:	e9 81       	ldd	r30, Y+1	; 0x01
    3212:	fa 81       	ldd	r31, Y+2	; 0x02
    3214:	97 83       	std	Z+7, r25	; 0x07
    3216:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3218:	e9 81       	ldd	r30, Y+1	; 0x01
    321a:	fa 81       	ldd	r31, Y+2	; 0x02
    321c:	26 81       	ldd	r18, Z+6	; 0x06
    321e:	37 81       	ldd	r19, Z+7	; 0x07
    3220:	e9 81       	ldd	r30, Y+1	; 0x01
    3222:	fa 81       	ldd	r31, Y+2	; 0x02
    3224:	84 81       	ldd	r24, Z+4	; 0x04
    3226:	95 81       	ldd	r25, Z+5	; 0x05
    3228:	28 17       	cp	r18, r24
    322a:	39 07       	cpc	r19, r25
    322c:	40 f0       	brcs	.+16     	; 0x323e <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    322e:	e9 81       	ldd	r30, Y+1	; 0x01
    3230:	fa 81       	ldd	r31, Y+2	; 0x02
    3232:	80 81       	ld	r24, Z
    3234:	91 81       	ldd	r25, Z+1	; 0x01
    3236:	e9 81       	ldd	r30, Y+1	; 0x01
    3238:	fa 81       	ldd	r31, Y+2	; 0x02
    323a:	97 83       	std	Z+7, r25	; 0x07
    323c:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    323e:	e9 81       	ldd	r30, Y+1	; 0x01
    3240:	fa 81       	ldd	r31, Y+2	; 0x02
    3242:	46 81       	ldd	r20, Z+6	; 0x06
    3244:	57 81       	ldd	r21, Z+7	; 0x07
    3246:	e9 81       	ldd	r30, Y+1	; 0x01
    3248:	fa 81       	ldd	r31, Y+2	; 0x02
    324a:	80 a1       	ldd	r24, Z+32	; 0x20
    324c:	28 2f       	mov	r18, r24
    324e:	30 e0       	ldi	r19, 0x00	; 0
    3250:	8b 81       	ldd	r24, Y+3	; 0x03
    3252:	9c 81       	ldd	r25, Y+4	; 0x04
    3254:	ba 01       	movw	r22, r20
    3256:	a9 01       	movw	r20, r18
    3258:	0e 94 17 40 	call	0x802e	; 0x802e <memcpy>
    }
}
    325c:	0f 90       	pop	r0
    325e:	0f 90       	pop	r0
    3260:	0f 90       	pop	r0
    3262:	0f 90       	pop	r0
    3264:	cf 91       	pop	r28
    3266:	df 91       	pop	r29
    3268:	08 95       	ret

0000326a <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    326a:	df 93       	push	r29
    326c:	cf 93       	push	r28
    326e:	00 d0       	rcall	.+0      	; 0x3270 <prvUnlockQueue+0x6>
    3270:	00 d0       	rcall	.+0      	; 0x3272 <prvUnlockQueue+0x8>
    3272:	cd b7       	in	r28, 0x3d	; 61
    3274:	de b7       	in	r29, 0x3e	; 62
    3276:	9c 83       	std	Y+4, r25	; 0x04
    3278:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    327a:	0f b6       	in	r0, 0x3f	; 63
    327c:	f8 94       	cli
    327e:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    3280:	eb 81       	ldd	r30, Y+3	; 0x03
    3282:	fc 81       	ldd	r31, Y+4	; 0x04
    3284:	82 a1       	ldd	r24, Z+34	; 0x22
    3286:	8a 83       	std	Y+2, r24	; 0x02
    3288:	11 c0       	rjmp	.+34     	; 0x32ac <prvUnlockQueue+0x42>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    328a:	eb 81       	ldd	r30, Y+3	; 0x03
    328c:	fc 81       	ldd	r31, Y+4	; 0x04
    328e:	83 89       	ldd	r24, Z+19	; 0x13
    3290:	88 23       	and	r24, r24
    3292:	79 f0       	breq	.+30     	; 0x32b2 <prvUnlockQueue+0x48>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3294:	8b 81       	ldd	r24, Y+3	; 0x03
    3296:	9c 81       	ldd	r25, Y+4	; 0x04
    3298:	43 96       	adiw	r24, 0x13	; 19
    329a:	0e 94 e6 21 	call	0x43cc	; 0x43cc <xTaskRemoveFromEventList>
    329e:	88 23       	and	r24, r24
    32a0:	11 f0       	breq	.+4      	; 0x32a6 <prvUnlockQueue+0x3c>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
    32a2:	0e 94 4e 25 	call	0x4a9c	; 0x4a9c <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    32a6:	8a 81       	ldd	r24, Y+2	; 0x02
    32a8:	81 50       	subi	r24, 0x01	; 1
    32aa:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    32ac:	8a 81       	ldd	r24, Y+2	; 0x02
    32ae:	18 16       	cp	r1, r24
    32b0:	64 f3       	brlt	.-40     	; 0x328a <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    32b2:	eb 81       	ldd	r30, Y+3	; 0x03
    32b4:	fc 81       	ldd	r31, Y+4	; 0x04
    32b6:	8f ef       	ldi	r24, 0xFF	; 255
    32b8:	82 a3       	std	Z+34, r24	; 0x22
    }
    taskEXIT_CRITICAL();
    32ba:	0f 90       	pop	r0
    32bc:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    32be:	0f b6       	in	r0, 0x3f	; 63
    32c0:	f8 94       	cli
    32c2:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    32c4:	eb 81       	ldd	r30, Y+3	; 0x03
    32c6:	fc 81       	ldd	r31, Y+4	; 0x04
    32c8:	81 a1       	ldd	r24, Z+33	; 0x21
    32ca:	89 83       	std	Y+1, r24	; 0x01
    32cc:	11 c0       	rjmp	.+34     	; 0x32f0 <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    32ce:	eb 81       	ldd	r30, Y+3	; 0x03
    32d0:	fc 81       	ldd	r31, Y+4	; 0x04
    32d2:	80 85       	ldd	r24, Z+8	; 0x08
    32d4:	88 23       	and	r24, r24
    32d6:	79 f0       	breq	.+30     	; 0x32f6 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    32d8:	8b 81       	ldd	r24, Y+3	; 0x03
    32da:	9c 81       	ldd	r25, Y+4	; 0x04
    32dc:	08 96       	adiw	r24, 0x08	; 8
    32de:	0e 94 e6 21 	call	0x43cc	; 0x43cc <xTaskRemoveFromEventList>
    32e2:	88 23       	and	r24, r24
    32e4:	11 f0       	breq	.+4      	; 0x32ea <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    32e6:	0e 94 4e 25 	call	0x4a9c	; 0x4a9c <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    32ea:	89 81       	ldd	r24, Y+1	; 0x01
    32ec:	81 50       	subi	r24, 0x01	; 1
    32ee:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    32f0:	89 81       	ldd	r24, Y+1	; 0x01
    32f2:	18 16       	cp	r1, r24
    32f4:	64 f3       	brlt	.-40     	; 0x32ce <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    32f6:	eb 81       	ldd	r30, Y+3	; 0x03
    32f8:	fc 81       	ldd	r31, Y+4	; 0x04
    32fa:	8f ef       	ldi	r24, 0xFF	; 255
    32fc:	81 a3       	std	Z+33, r24	; 0x21
    }
    taskEXIT_CRITICAL();
    32fe:	0f 90       	pop	r0
    3300:	0f be       	out	0x3f, r0	; 63
}
    3302:	0f 90       	pop	r0
    3304:	0f 90       	pop	r0
    3306:	0f 90       	pop	r0
    3308:	0f 90       	pop	r0
    330a:	cf 91       	pop	r28
    330c:	df 91       	pop	r29
    330e:	08 95       	ret

00003310 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    3310:	df 93       	push	r29
    3312:	cf 93       	push	r28
    3314:	00 d0       	rcall	.+0      	; 0x3316 <prvIsQueueEmpty+0x6>
    3316:	0f 92       	push	r0
    3318:	cd b7       	in	r28, 0x3d	; 61
    331a:	de b7       	in	r29, 0x3e	; 62
    331c:	9b 83       	std	Y+3, r25	; 0x03
    331e:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    3320:	0f b6       	in	r0, 0x3f	; 63
    3322:	f8 94       	cli
    3324:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3326:	ea 81       	ldd	r30, Y+2	; 0x02
    3328:	fb 81       	ldd	r31, Y+3	; 0x03
    332a:	86 8d       	ldd	r24, Z+30	; 0x1e
    332c:	88 23       	and	r24, r24
    332e:	19 f4       	brne	.+6      	; 0x3336 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    3330:	81 e0       	ldi	r24, 0x01	; 1
    3332:	89 83       	std	Y+1, r24	; 0x01
    3334:	01 c0       	rjmp	.+2      	; 0x3338 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    3336:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    3338:	0f 90       	pop	r0
    333a:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    333c:	89 81       	ldd	r24, Y+1	; 0x01
}
    333e:	0f 90       	pop	r0
    3340:	0f 90       	pop	r0
    3342:	0f 90       	pop	r0
    3344:	cf 91       	pop	r28
    3346:	df 91       	pop	r29
    3348:	08 95       	ret

0000334a <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    334a:	df 93       	push	r29
    334c:	cf 93       	push	r28
    334e:	00 d0       	rcall	.+0      	; 0x3350 <xQueueIsQueueEmptyFromISR+0x6>
    3350:	00 d0       	rcall	.+0      	; 0x3352 <xQueueIsQueueEmptyFromISR+0x8>
    3352:	0f 92       	push	r0
    3354:	cd b7       	in	r28, 0x3d	; 61
    3356:	de b7       	in	r29, 0x3e	; 62
    3358:	9d 83       	std	Y+5, r25	; 0x05
    335a:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    335c:	8c 81       	ldd	r24, Y+4	; 0x04
    335e:	9d 81       	ldd	r25, Y+5	; 0x05
    3360:	9a 83       	std	Y+2, r25	; 0x02
    3362:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    3364:	89 81       	ldd	r24, Y+1	; 0x01
    3366:	9a 81       	ldd	r25, Y+2	; 0x02
    3368:	00 97       	sbiw	r24, 0x00	; 0
    336a:	11 f4       	brne	.+4      	; 0x3370 <xQueueIsQueueEmptyFromISR+0x26>
    336c:	f8 94       	cli
    336e:	ff cf       	rjmp	.-2      	; 0x336e <xQueueIsQueueEmptyFromISR+0x24>

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3370:	e9 81       	ldd	r30, Y+1	; 0x01
    3372:	fa 81       	ldd	r31, Y+2	; 0x02
    3374:	86 8d       	ldd	r24, Z+30	; 0x1e
    3376:	88 23       	and	r24, r24
    3378:	19 f4       	brne	.+6      	; 0x3380 <xQueueIsQueueEmptyFromISR+0x36>
    {
        xReturn = pdTRUE;
    337a:	81 e0       	ldi	r24, 0x01	; 1
    337c:	8b 83       	std	Y+3, r24	; 0x03
    337e:	01 c0       	rjmp	.+2      	; 0x3382 <xQueueIsQueueEmptyFromISR+0x38>
    }
    else
    {
        xReturn = pdFALSE;
    3380:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    3382:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3384:	0f 90       	pop	r0
    3386:	0f 90       	pop	r0
    3388:	0f 90       	pop	r0
    338a:	0f 90       	pop	r0
    338c:	0f 90       	pop	r0
    338e:	cf 91       	pop	r28
    3390:	df 91       	pop	r29
    3392:	08 95       	ret

00003394 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    3394:	df 93       	push	r29
    3396:	cf 93       	push	r28
    3398:	00 d0       	rcall	.+0      	; 0x339a <prvIsQueueFull+0x6>
    339a:	0f 92       	push	r0
    339c:	cd b7       	in	r28, 0x3d	; 61
    339e:	de b7       	in	r29, 0x3e	; 62
    33a0:	9b 83       	std	Y+3, r25	; 0x03
    33a2:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    33a4:	0f b6       	in	r0, 0x3f	; 63
    33a6:	f8 94       	cli
    33a8:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    33aa:	ea 81       	ldd	r30, Y+2	; 0x02
    33ac:	fb 81       	ldd	r31, Y+3	; 0x03
    33ae:	96 8d       	ldd	r25, Z+30	; 0x1e
    33b0:	ea 81       	ldd	r30, Y+2	; 0x02
    33b2:	fb 81       	ldd	r31, Y+3	; 0x03
    33b4:	87 8d       	ldd	r24, Z+31	; 0x1f
    33b6:	98 17       	cp	r25, r24
    33b8:	19 f4       	brne	.+6      	; 0x33c0 <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    33ba:	81 e0       	ldi	r24, 0x01	; 1
    33bc:	89 83       	std	Y+1, r24	; 0x01
    33be:	01 c0       	rjmp	.+2      	; 0x33c2 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    33c0:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    33c2:	0f 90       	pop	r0
    33c4:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    33c6:	89 81       	ldd	r24, Y+1	; 0x01
}
    33c8:	0f 90       	pop	r0
    33ca:	0f 90       	pop	r0
    33cc:	0f 90       	pop	r0
    33ce:	cf 91       	pop	r28
    33d0:	df 91       	pop	r29
    33d2:	08 95       	ret

000033d4 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    33d4:	df 93       	push	r29
    33d6:	cf 93       	push	r28
    33d8:	00 d0       	rcall	.+0      	; 0x33da <xQueueIsQueueFullFromISR+0x6>
    33da:	00 d0       	rcall	.+0      	; 0x33dc <xQueueIsQueueFullFromISR+0x8>
    33dc:	0f 92       	push	r0
    33de:	cd b7       	in	r28, 0x3d	; 61
    33e0:	de b7       	in	r29, 0x3e	; 62
    33e2:	9d 83       	std	Y+5, r25	; 0x05
    33e4:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    33e6:	8c 81       	ldd	r24, Y+4	; 0x04
    33e8:	9d 81       	ldd	r25, Y+5	; 0x05
    33ea:	9a 83       	std	Y+2, r25	; 0x02
    33ec:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    33ee:	89 81       	ldd	r24, Y+1	; 0x01
    33f0:	9a 81       	ldd	r25, Y+2	; 0x02
    33f2:	00 97       	sbiw	r24, 0x00	; 0
    33f4:	11 f4       	brne	.+4      	; 0x33fa <xQueueIsQueueFullFromISR+0x26>
    33f6:	f8 94       	cli
    33f8:	ff cf       	rjmp	.-2      	; 0x33f8 <xQueueIsQueueFullFromISR+0x24>

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    33fa:	e9 81       	ldd	r30, Y+1	; 0x01
    33fc:	fa 81       	ldd	r31, Y+2	; 0x02
    33fe:	96 8d       	ldd	r25, Z+30	; 0x1e
    3400:	e9 81       	ldd	r30, Y+1	; 0x01
    3402:	fa 81       	ldd	r31, Y+2	; 0x02
    3404:	87 8d       	ldd	r24, Z+31	; 0x1f
    3406:	98 17       	cp	r25, r24
    3408:	19 f4       	brne	.+6      	; 0x3410 <xQueueIsQueueFullFromISR+0x3c>
    {
        xReturn = pdTRUE;
    340a:	81 e0       	ldi	r24, 0x01	; 1
    340c:	8b 83       	std	Y+3, r24	; 0x03
    340e:	01 c0       	rjmp	.+2      	; 0x3412 <xQueueIsQueueFullFromISR+0x3e>
    }
    else
    {
        xReturn = pdFALSE;
    3410:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    3412:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3414:	0f 90       	pop	r0
    3416:	0f 90       	pop	r0
    3418:	0f 90       	pop	r0
    341a:	0f 90       	pop	r0
    341c:	0f 90       	pop	r0
    341e:	cf 91       	pop	r28
    3420:	df 91       	pop	r29
    3422:	08 95       	ret

00003424 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    3424:	8f 92       	push	r8
    3426:	9f 92       	push	r9
    3428:	af 92       	push	r10
    342a:	bf 92       	push	r11
    342c:	cf 92       	push	r12
    342e:	df 92       	push	r13
    3430:	ef 92       	push	r14
    3432:	ff 92       	push	r15
    3434:	0f 93       	push	r16
    3436:	1f 93       	push	r17
    3438:	df 93       	push	r29
    343a:	cf 93       	push	r28
    343c:	cd b7       	in	r28, 0x3d	; 61
    343e:	de b7       	in	r29, 0x3e	; 62
    3440:	60 97       	sbiw	r28, 0x10	; 16
    3442:	0f b6       	in	r0, 0x3f	; 63
    3444:	f8 94       	cli
    3446:	de bf       	out	0x3e, r29	; 62
    3448:	0f be       	out	0x3f, r0	; 63
    344a:	cd bf       	out	0x3d, r28	; 61
    344c:	9f 83       	std	Y+7, r25	; 0x07
    344e:	8e 83       	std	Y+6, r24	; 0x06
    3450:	79 87       	std	Y+9, r23	; 0x09
    3452:	68 87       	std	Y+8, r22	; 0x08
    3454:	5b 87       	std	Y+11, r21	; 0x0b
    3456:	4a 87       	std	Y+10, r20	; 0x0a
    3458:	3d 87       	std	Y+13, r19	; 0x0d
    345a:	2c 87       	std	Y+12, r18	; 0x0c
    345c:	0e 87       	std	Y+14, r16	; 0x0e
    345e:	f8 8a       	std	Y+16, r15	; 0x10
    3460:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3462:	8a 85       	ldd	r24, Y+10	; 0x0a
    3464:	9b 85       	ldd	r25, Y+11	; 0x0b
    3466:	0e 94 19 0a 	call	0x1432	; 0x1432 <pvPortMalloc>
    346a:	9a 83       	std	Y+2, r25	; 0x02
    346c:	89 83       	std	Y+1, r24	; 0x01

            if( pxStack != NULL )
    346e:	89 81       	ldd	r24, Y+1	; 0x01
    3470:	9a 81       	ldd	r25, Y+2	; 0x02
    3472:	00 97       	sbiw	r24, 0x00	; 0
    3474:	f1 f0       	breq	.+60     	; 0x34b2 <xTaskCreate+0x8e>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3476:	82 e3       	ldi	r24, 0x32	; 50
    3478:	90 e0       	ldi	r25, 0x00	; 0
    347a:	0e 94 19 0a 	call	0x1432	; 0x1432 <pvPortMalloc>
    347e:	9d 83       	std	Y+5, r25	; 0x05
    3480:	8c 83       	std	Y+4, r24	; 0x04

                if( pxNewTCB != NULL )
    3482:	8c 81       	ldd	r24, Y+4	; 0x04
    3484:	9d 81       	ldd	r25, Y+5	; 0x05
    3486:	00 97       	sbiw	r24, 0x00	; 0
    3488:	79 f0       	breq	.+30     	; 0x34a8 <xTaskCreate+0x84>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
    348a:	8c 81       	ldd	r24, Y+4	; 0x04
    348c:	9d 81       	ldd	r25, Y+5	; 0x05
    348e:	60 e0       	ldi	r22, 0x00	; 0
    3490:	70 e0       	ldi	r23, 0x00	; 0
    3492:	42 e3       	ldi	r20, 0x32	; 50
    3494:	50 e0       	ldi	r21, 0x00	; 0
    3496:	0e 94 20 40 	call	0x8040	; 0x8040 <memset>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
    349a:	ec 81       	ldd	r30, Y+4	; 0x04
    349c:	fd 81       	ldd	r31, Y+5	; 0x05
    349e:	89 81       	ldd	r24, Y+1	; 0x01
    34a0:	9a 81       	ldd	r25, Y+2	; 0x02
    34a2:	94 8f       	std	Z+28, r25	; 0x1c
    34a4:	83 8f       	std	Z+27, r24	; 0x1b
    34a6:	07 c0       	rjmp	.+14     	; 0x34b6 <xTaskCreate+0x92>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
    34a8:	89 81       	ldd	r24, Y+1	; 0x01
    34aa:	9a 81       	ldd	r25, Y+2	; 0x02
    34ac:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vPortFree>
    34b0:	02 c0       	rjmp	.+4      	; 0x34b6 <xTaskCreate+0x92>
                }
            }
            else
            {
                pxNewTCB = NULL;
    34b2:	1d 82       	std	Y+5, r1	; 0x05
    34b4:	1c 82       	std	Y+4, r1	; 0x04
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    34b6:	8c 81       	ldd	r24, Y+4	; 0x04
    34b8:	9d 81       	ldd	r25, Y+5	; 0x05
    34ba:	00 97       	sbiw	r24, 0x00	; 0
    34bc:	e9 f0       	breq	.+58     	; 0x34f8 <xTaskCreate+0xd4>
                 * task was created dynamically in case it is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    34be:	8a 85       	ldd	r24, Y+10	; 0x0a
    34c0:	9b 85       	ldd	r25, Y+11	; 0x0b
    34c2:	9c 01       	movw	r18, r24
    34c4:	40 e0       	ldi	r20, 0x00	; 0
    34c6:	50 e0       	ldi	r21, 0x00	; 0
    34c8:	8e 81       	ldd	r24, Y+6	; 0x06
    34ca:	9f 81       	ldd	r25, Y+7	; 0x07
    34cc:	68 85       	ldd	r22, Y+8	; 0x08
    34ce:	79 85       	ldd	r23, Y+9	; 0x09
    34d0:	ec 85       	ldd	r30, Y+12	; 0x0c
    34d2:	fd 85       	ldd	r31, Y+13	; 0x0d
    34d4:	af 85       	ldd	r26, Y+15	; 0x0f
    34d6:	b8 89       	ldd	r27, Y+16	; 0x10
    34d8:	ac 80       	ldd	r10, Y+4	; 0x04
    34da:	bd 80       	ldd	r11, Y+5	; 0x05
    34dc:	8f 01       	movw	r16, r30
    34de:	ee 84       	ldd	r14, Y+14	; 0x0e
    34e0:	6d 01       	movw	r12, r26
    34e2:	88 24       	eor	r8, r8
    34e4:	99 24       	eor	r9, r9
    34e6:	0e 94 92 1a 	call	0x3524	; 0x3524 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    34ea:	8c 81       	ldd	r24, Y+4	; 0x04
    34ec:	9d 81       	ldd	r25, Y+5	; 0x05
    34ee:	0e 94 4e 1b 	call	0x369c	; 0x369c <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    34f2:	81 e0       	ldi	r24, 0x01	; 1
    34f4:	8b 83       	std	Y+3, r24	; 0x03
    34f6:	02 c0       	rjmp	.+4      	; 0x34fc <xTaskCreate+0xd8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    34f8:	8f ef       	ldi	r24, 0xFF	; 255
    34fa:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    34fc:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    34fe:	60 96       	adiw	r28, 0x10	; 16
    3500:	0f b6       	in	r0, 0x3f	; 63
    3502:	f8 94       	cli
    3504:	de bf       	out	0x3e, r29	; 62
    3506:	0f be       	out	0x3f, r0	; 63
    3508:	cd bf       	out	0x3d, r28	; 61
    350a:	cf 91       	pop	r28
    350c:	df 91       	pop	r29
    350e:	1f 91       	pop	r17
    3510:	0f 91       	pop	r16
    3512:	ff 90       	pop	r15
    3514:	ef 90       	pop	r14
    3516:	df 90       	pop	r13
    3518:	cf 90       	pop	r12
    351a:	bf 90       	pop	r11
    351c:	af 90       	pop	r10
    351e:	9f 90       	pop	r9
    3520:	8f 90       	pop	r8
    3522:	08 95       	ret

00003524 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    3524:	8f 92       	push	r8
    3526:	9f 92       	push	r9
    3528:	af 92       	push	r10
    352a:	bf 92       	push	r11
    352c:	cf 92       	push	r12
    352e:	df 92       	push	r13
    3530:	ef 92       	push	r14
    3532:	0f 93       	push	r16
    3534:	1f 93       	push	r17
    3536:	df 93       	push	r29
    3538:	cf 93       	push	r28
    353a:	cd b7       	in	r28, 0x3d	; 61
    353c:	de b7       	in	r29, 0x3e	; 62
    353e:	64 97       	sbiw	r28, 0x14	; 20
    3540:	0f b6       	in	r0, 0x3f	; 63
    3542:	f8 94       	cli
    3544:	de bf       	out	0x3e, r29	; 62
    3546:	0f be       	out	0x3f, r0	; 63
    3548:	cd bf       	out	0x3d, r28	; 61
    354a:	9d 83       	std	Y+5, r25	; 0x05
    354c:	8c 83       	std	Y+4, r24	; 0x04
    354e:	7f 83       	std	Y+7, r23	; 0x07
    3550:	6e 83       	std	Y+6, r22	; 0x06
    3552:	28 87       	std	Y+8, r18	; 0x08
    3554:	39 87       	std	Y+9, r19	; 0x09
    3556:	4a 87       	std	Y+10, r20	; 0x0a
    3558:	5b 87       	std	Y+11, r21	; 0x0b
    355a:	1d 87       	std	Y+13, r17	; 0x0d
    355c:	0c 87       	std	Y+12, r16	; 0x0c
    355e:	ee 86       	std	Y+14, r14	; 0x0e
    3560:	d8 8a       	std	Y+16, r13	; 0x10
    3562:	cf 86       	std	Y+15, r12	; 0x0f
    3564:	ba 8a       	std	Y+18, r11	; 0x12
    3566:	a9 8a       	std	Y+17, r10	; 0x11
    3568:	9c 8a       	std	Y+20, r9	; 0x14
    356a:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
    {
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    356c:	e9 89       	ldd	r30, Y+17	; 0x11
    356e:	fa 89       	ldd	r31, Y+18	; 0x12
    3570:	23 8d       	ldd	r18, Z+27	; 0x1b
    3572:	34 8d       	ldd	r19, Z+28	; 0x1c
    3574:	88 85       	ldd	r24, Y+8	; 0x08
    3576:	99 85       	ldd	r25, Y+9	; 0x09
    3578:	01 97       	sbiw	r24, 0x01	; 1
    357a:	82 0f       	add	r24, r18
    357c:	93 1f       	adc	r25, r19
    357e:	9b 83       	std	Y+3, r25	; 0x03
    3580:	8a 83       	std	Y+2, r24	; 0x02
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    3582:	8e 81       	ldd	r24, Y+6	; 0x06
    3584:	9f 81       	ldd	r25, Y+7	; 0x07
    3586:	00 97       	sbiw	r24, 0x00	; 0
    3588:	49 f1       	breq	.+82     	; 0x35dc <prvInitialiseNewTask+0xb8>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    358a:	19 82       	std	Y+1, r1	; 0x01
    358c:	21 c0       	rjmp	.+66     	; 0x35d0 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    358e:	89 81       	ldd	r24, Y+1	; 0x01
    3590:	48 2f       	mov	r20, r24
    3592:	50 e0       	ldi	r21, 0x00	; 0
    3594:	89 81       	ldd	r24, Y+1	; 0x01
    3596:	28 2f       	mov	r18, r24
    3598:	30 e0       	ldi	r19, 0x00	; 0
    359a:	8e 81       	ldd	r24, Y+6	; 0x06
    359c:	9f 81       	ldd	r25, Y+7	; 0x07
    359e:	fc 01       	movw	r30, r24
    35a0:	e2 0f       	add	r30, r18
    35a2:	f3 1f       	adc	r31, r19
    35a4:	20 81       	ld	r18, Z
    35a6:	89 89       	ldd	r24, Y+17	; 0x11
    35a8:	9a 89       	ldd	r25, Y+18	; 0x12
    35aa:	84 0f       	add	r24, r20
    35ac:	95 1f       	adc	r25, r21
    35ae:	fc 01       	movw	r30, r24
    35b0:	7d 96       	adiw	r30, 0x1d	; 29
    35b2:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    35b4:	89 81       	ldd	r24, Y+1	; 0x01
    35b6:	28 2f       	mov	r18, r24
    35b8:	30 e0       	ldi	r19, 0x00	; 0
    35ba:	8e 81       	ldd	r24, Y+6	; 0x06
    35bc:	9f 81       	ldd	r25, Y+7	; 0x07
    35be:	fc 01       	movw	r30, r24
    35c0:	e2 0f       	add	r30, r18
    35c2:	f3 1f       	adc	r31, r19
    35c4:	80 81       	ld	r24, Z
    35c6:	88 23       	and	r24, r24
    35c8:	31 f0       	breq	.+12     	; 0x35d6 <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    35ca:	89 81       	ldd	r24, Y+1	; 0x01
    35cc:	8f 5f       	subi	r24, 0xFF	; 255
    35ce:	89 83       	std	Y+1, r24	; 0x01
    35d0:	89 81       	ldd	r24, Y+1	; 0x01
    35d2:	80 31       	cpi	r24, 0x10	; 16
    35d4:	e0 f2       	brcs	.-72     	; 0x358e <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    35d6:	e9 89       	ldd	r30, Y+17	; 0x11
    35d8:	fa 89       	ldd	r31, Y+18	; 0x12
    35da:	14 a6       	std	Z+44, r1	; 0x2c
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );
    35dc:	8e 85       	ldd	r24, Y+14	; 0x0e
    35de:	85 30       	cpi	r24, 0x05	; 5
    35e0:	10 f0       	brcs	.+4      	; 0x35e6 <prvInitialiseNewTask+0xc2>
    35e2:	f8 94       	cli
    35e4:	ff cf       	rjmp	.-2      	; 0x35e4 <prvInitialiseNewTask+0xc0>

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    35e6:	8e 85       	ldd	r24, Y+14	; 0x0e
    35e8:	85 30       	cpi	r24, 0x05	; 5
    35ea:	10 f0       	brcs	.+4      	; 0x35f0 <prvInitialiseNewTask+0xcc>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    35ec:	84 e0       	ldi	r24, 0x04	; 4
    35ee:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    35f0:	e9 89       	ldd	r30, Y+17	; 0x11
    35f2:	fa 89       	ldd	r31, Y+18	; 0x12
    35f4:	8e 85       	ldd	r24, Y+14	; 0x0e
    35f6:	82 8f       	std	Z+26, r24	; 0x1a
    {
        pxNewTCB->uxBasePriority = uxPriority;
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    35f8:	89 89       	ldd	r24, Y+17	; 0x11
    35fa:	9a 89       	ldd	r25, Y+18	; 0x12
    35fc:	02 96       	adiw	r24, 0x02	; 2
    35fe:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3602:	89 89       	ldd	r24, Y+17	; 0x11
    3604:	9a 89       	ldd	r25, Y+18	; 0x12
    3606:	0e 96       	adiw	r24, 0x0e	; 14
    3608:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    360c:	e9 89       	ldd	r30, Y+17	; 0x11
    360e:	fa 89       	ldd	r31, Y+18	; 0x12
    3610:	89 89       	ldd	r24, Y+17	; 0x11
    3612:	9a 89       	ldd	r25, Y+18	; 0x12
    3614:	93 87       	std	Z+11, r25	; 0x0b
    3616:	82 87       	std	Z+10, r24	; 0x0a

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3618:	8e 85       	ldd	r24, Y+14	; 0x0e
    361a:	28 2f       	mov	r18, r24
    361c:	30 e0       	ldi	r19, 0x00	; 0
    361e:	40 e0       	ldi	r20, 0x00	; 0
    3620:	50 e0       	ldi	r21, 0x00	; 0
    3622:	85 e0       	ldi	r24, 0x05	; 5
    3624:	90 e0       	ldi	r25, 0x00	; 0
    3626:	a0 e0       	ldi	r26, 0x00	; 0
    3628:	b0 e0       	ldi	r27, 0x00	; 0
    362a:	82 1b       	sub	r24, r18
    362c:	93 0b       	sbc	r25, r19
    362e:	a4 0b       	sbc	r26, r20
    3630:	b5 0b       	sbc	r27, r21
    3632:	e9 89       	ldd	r30, Y+17	; 0x11
    3634:	fa 89       	ldd	r31, Y+18	; 0x12
    3636:	86 87       	std	Z+14, r24	; 0x0e
    3638:	97 87       	std	Z+15, r25	; 0x0f
    363a:	a0 8b       	std	Z+16, r26	; 0x10
    363c:	b1 8b       	std	Z+17, r27	; 0x11
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    363e:	e9 89       	ldd	r30, Y+17	; 0x11
    3640:	fa 89       	ldd	r31, Y+18	; 0x12
    3642:	89 89       	ldd	r24, Y+17	; 0x11
    3644:	9a 89       	ldd	r25, Y+18	; 0x12
    3646:	97 8b       	std	Z+23, r25	; 0x17
    3648:	86 8b       	std	Z+22, r24	; 0x16
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    364a:	8a 81       	ldd	r24, Y+2	; 0x02
    364c:	9b 81       	ldd	r25, Y+3	; 0x03
    364e:	2c 81       	ldd	r18, Y+4	; 0x04
    3650:	3d 81       	ldd	r19, Y+5	; 0x05
    3652:	4c 85       	ldd	r20, Y+12	; 0x0c
    3654:	5d 85       	ldd	r21, Y+13	; 0x0d
    3656:	b9 01       	movw	r22, r18
    3658:	0e 94 3c 08 	call	0x1078	; 0x1078 <pxPortInitialiseStack>
    365c:	e9 89       	ldd	r30, Y+17	; 0x11
    365e:	fa 89       	ldd	r31, Y+18	; 0x12
    3660:	91 83       	std	Z+1, r25	; 0x01
    3662:	80 83       	st	Z, r24
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    3664:	8f 85       	ldd	r24, Y+15	; 0x0f
    3666:	98 89       	ldd	r25, Y+16	; 0x10
    3668:	00 97       	sbiw	r24, 0x00	; 0
    366a:	31 f0       	breq	.+12     	; 0x3678 <prvInitialiseNewTask+0x154>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    366c:	ef 85       	ldd	r30, Y+15	; 0x0f
    366e:	f8 89       	ldd	r31, Y+16	; 0x10
    3670:	89 89       	ldd	r24, Y+17	; 0x11
    3672:	9a 89       	ldd	r25, Y+18	; 0x12
    3674:	91 83       	std	Z+1, r25	; 0x01
    3676:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3678:	64 96       	adiw	r28, 0x14	; 20
    367a:	0f b6       	in	r0, 0x3f	; 63
    367c:	f8 94       	cli
    367e:	de bf       	out	0x3e, r29	; 62
    3680:	0f be       	out	0x3f, r0	; 63
    3682:	cd bf       	out	0x3d, r28	; 61
    3684:	cf 91       	pop	r28
    3686:	df 91       	pop	r29
    3688:	1f 91       	pop	r17
    368a:	0f 91       	pop	r16
    368c:	ef 90       	pop	r14
    368e:	df 90       	pop	r13
    3690:	cf 90       	pop	r12
    3692:	bf 90       	pop	r11
    3694:	af 90       	pop	r10
    3696:	9f 90       	pop	r9
    3698:	8f 90       	pop	r8
    369a:	08 95       	ret

0000369c <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    369c:	df 93       	push	r29
    369e:	cf 93       	push	r28
    36a0:	00 d0       	rcall	.+0      	; 0x36a2 <prvAddNewTaskToReadyList+0x6>
    36a2:	00 d0       	rcall	.+0      	; 0x36a4 <prvAddNewTaskToReadyList+0x8>
    36a4:	cd b7       	in	r28, 0x3d	; 61
    36a6:	de b7       	in	r29, 0x3e	; 62
    36a8:	9c 83       	std	Y+4, r25	; 0x04
    36aa:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    36ac:	0f b6       	in	r0, 0x3f	; 63
    36ae:	f8 94       	cli
    36b0:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    36b2:	80 91 34 15 	lds	r24, 0x1534
    36b6:	8f 5f       	subi	r24, 0xFF	; 255
    36b8:	80 93 34 15 	sts	0x1534, r24

        if( pxCurrentTCB == NULL )
    36bc:	80 91 32 15 	lds	r24, 0x1532
    36c0:	90 91 33 15 	lds	r25, 0x1533
    36c4:	00 97       	sbiw	r24, 0x00	; 0
    36c6:	69 f4       	brne	.+26     	; 0x36e2 <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    36c8:	8b 81       	ldd	r24, Y+3	; 0x03
    36ca:	9c 81       	ldd	r25, Y+4	; 0x04
    36cc:	90 93 33 15 	sts	0x1533, r25
    36d0:	80 93 32 15 	sts	0x1532, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    36d4:	80 91 34 15 	lds	r24, 0x1534
    36d8:	81 30       	cpi	r24, 0x01	; 1
    36da:	b9 f4       	brne	.+46     	; 0x370a <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    36dc:	0e 94 68 25 	call	0x4ad0	; 0x4ad0 <prvInitialiseTaskLists>
    36e0:	14 c0       	rjmp	.+40     	; 0x370a <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    36e2:	80 91 3a 15 	lds	r24, 0x153A
    36e6:	88 23       	and	r24, r24
    36e8:	81 f4       	brne	.+32     	; 0x370a <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    36ea:	e0 91 32 15 	lds	r30, 0x1532
    36ee:	f0 91 33 15 	lds	r31, 0x1533
    36f2:	92 8d       	ldd	r25, Z+26	; 0x1a
    36f4:	eb 81       	ldd	r30, Y+3	; 0x03
    36f6:	fc 81       	ldd	r31, Y+4	; 0x04
    36f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    36fa:	89 17       	cp	r24, r25
    36fc:	30 f0       	brcs	.+12     	; 0x370a <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    36fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3700:	9c 81       	ldd	r25, Y+4	; 0x04
    3702:	90 93 33 15 	sts	0x1533, r25
    3706:	80 93 32 15 	sts	0x1532, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    370a:	80 91 41 15 	lds	r24, 0x1541
    370e:	8f 5f       	subi	r24, 0xFF	; 255
    3710:	80 93 41 15 	sts	0x1541, r24
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    3714:	eb 81       	ldd	r30, Y+3	; 0x03
    3716:	fc 81       	ldd	r31, Y+4	; 0x04
    3718:	92 8d       	ldd	r25, Z+26	; 0x1a
    371a:	80 91 39 15 	lds	r24, 0x1539
    371e:	89 17       	cp	r24, r25
    3720:	28 f4       	brcc	.+10     	; 0x372c <prvAddNewTaskToReadyList+0x90>
    3722:	eb 81       	ldd	r30, Y+3	; 0x03
    3724:	fc 81       	ldd	r31, Y+4	; 0x04
    3726:	82 8d       	ldd	r24, Z+26	; 0x1a
    3728:	80 93 39 15 	sts	0x1539, r24
    372c:	eb 81       	ldd	r30, Y+3	; 0x03
    372e:	fc 81       	ldd	r31, Y+4	; 0x04
    3730:	82 8d       	ldd	r24, Z+26	; 0x1a
    3732:	48 2f       	mov	r20, r24
    3734:	50 e0       	ldi	r21, 0x00	; 0
    3736:	ca 01       	movw	r24, r20
    3738:	88 0f       	add	r24, r24
    373a:	99 1f       	adc	r25, r25
    373c:	9c 01       	movw	r18, r24
    373e:	22 0f       	add	r18, r18
    3740:	33 1f       	adc	r19, r19
    3742:	22 0f       	add	r18, r18
    3744:	33 1f       	adc	r19, r19
    3746:	82 0f       	add	r24, r18
    3748:	93 1f       	adc	r25, r19
    374a:	84 0f       	add	r24, r20
    374c:	95 1f       	adc	r25, r21
    374e:	fc 01       	movw	r30, r24
    3750:	e7 5b       	subi	r30, 0xB7	; 183
    3752:	fa 4e       	sbci	r31, 0xEA	; 234
    3754:	81 81       	ldd	r24, Z+1	; 0x01
    3756:	92 81       	ldd	r25, Z+2	; 0x02
    3758:	9a 83       	std	Y+2, r25	; 0x02
    375a:	89 83       	std	Y+1, r24	; 0x01
    375c:	eb 81       	ldd	r30, Y+3	; 0x03
    375e:	fc 81       	ldd	r31, Y+4	; 0x04
    3760:	89 81       	ldd	r24, Y+1	; 0x01
    3762:	9a 81       	ldd	r25, Y+2	; 0x02
    3764:	97 83       	std	Z+7, r25	; 0x07
    3766:	86 83       	std	Z+6, r24	; 0x06
    3768:	e9 81       	ldd	r30, Y+1	; 0x01
    376a:	fa 81       	ldd	r31, Y+2	; 0x02
    376c:	86 81       	ldd	r24, Z+6	; 0x06
    376e:	97 81       	ldd	r25, Z+7	; 0x07
    3770:	eb 81       	ldd	r30, Y+3	; 0x03
    3772:	fc 81       	ldd	r31, Y+4	; 0x04
    3774:	91 87       	std	Z+9, r25	; 0x09
    3776:	80 87       	std	Z+8, r24	; 0x08
    3778:	e9 81       	ldd	r30, Y+1	; 0x01
    377a:	fa 81       	ldd	r31, Y+2	; 0x02
    377c:	06 80       	ldd	r0, Z+6	; 0x06
    377e:	f7 81       	ldd	r31, Z+7	; 0x07
    3780:	e0 2d       	mov	r30, r0
    3782:	8b 81       	ldd	r24, Y+3	; 0x03
    3784:	9c 81       	ldd	r25, Y+4	; 0x04
    3786:	02 96       	adiw	r24, 0x02	; 2
    3788:	95 83       	std	Z+5, r25	; 0x05
    378a:	84 83       	std	Z+4, r24	; 0x04
    378c:	8b 81       	ldd	r24, Y+3	; 0x03
    378e:	9c 81       	ldd	r25, Y+4	; 0x04
    3790:	02 96       	adiw	r24, 0x02	; 2
    3792:	e9 81       	ldd	r30, Y+1	; 0x01
    3794:	fa 81       	ldd	r31, Y+2	; 0x02
    3796:	97 83       	std	Z+7, r25	; 0x07
    3798:	86 83       	std	Z+6, r24	; 0x06
    379a:	eb 81       	ldd	r30, Y+3	; 0x03
    379c:	fc 81       	ldd	r31, Y+4	; 0x04
    379e:	82 8d       	ldd	r24, Z+26	; 0x1a
    37a0:	48 2f       	mov	r20, r24
    37a2:	50 e0       	ldi	r21, 0x00	; 0
    37a4:	ca 01       	movw	r24, r20
    37a6:	88 0f       	add	r24, r24
    37a8:	99 1f       	adc	r25, r25
    37aa:	9c 01       	movw	r18, r24
    37ac:	22 0f       	add	r18, r18
    37ae:	33 1f       	adc	r19, r19
    37b0:	22 0f       	add	r18, r18
    37b2:	33 1f       	adc	r19, r19
    37b4:	82 0f       	add	r24, r18
    37b6:	93 1f       	adc	r25, r19
    37b8:	84 0f       	add	r24, r20
    37ba:	95 1f       	adc	r25, r21
    37bc:	87 5b       	subi	r24, 0xB7	; 183
    37be:	9a 4e       	sbci	r25, 0xEA	; 234
    37c0:	eb 81       	ldd	r30, Y+3	; 0x03
    37c2:	fc 81       	ldd	r31, Y+4	; 0x04
    37c4:	95 87       	std	Z+13, r25	; 0x0d
    37c6:	84 87       	std	Z+12, r24	; 0x0c
    37c8:	eb 81       	ldd	r30, Y+3	; 0x03
    37ca:	fc 81       	ldd	r31, Y+4	; 0x04
    37cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    37ce:	48 2f       	mov	r20, r24
    37d0:	50 e0       	ldi	r21, 0x00	; 0
    37d2:	ca 01       	movw	r24, r20
    37d4:	88 0f       	add	r24, r24
    37d6:	99 1f       	adc	r25, r25
    37d8:	9c 01       	movw	r18, r24
    37da:	22 0f       	add	r18, r18
    37dc:	33 1f       	adc	r19, r19
    37de:	22 0f       	add	r18, r18
    37e0:	33 1f       	adc	r19, r19
    37e2:	82 0f       	add	r24, r18
    37e4:	93 1f       	adc	r25, r19
    37e6:	84 0f       	add	r24, r20
    37e8:	95 1f       	adc	r25, r21
    37ea:	fc 01       	movw	r30, r24
    37ec:	e7 5b       	subi	r30, 0xB7	; 183
    37ee:	fa 4e       	sbci	r31, 0xEA	; 234
    37f0:	80 81       	ld	r24, Z
    37f2:	8f 5f       	subi	r24, 0xFF	; 255
    37f4:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    37f6:	0f 90       	pop	r0
    37f8:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    37fa:	80 91 3a 15 	lds	r24, 0x153A
    37fe:	88 23       	and	r24, r24
    3800:	61 f0       	breq	.+24     	; 0x381a <prvAddNewTaskToReadyList+0x17e>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3802:	e0 91 32 15 	lds	r30, 0x1532
    3806:	f0 91 33 15 	lds	r31, 0x1533
    380a:	92 8d       	ldd	r25, Z+26	; 0x1a
    380c:	eb 81       	ldd	r30, Y+3	; 0x03
    380e:	fc 81       	ldd	r31, Y+4	; 0x04
    3810:	82 8d       	ldd	r24, Z+26	; 0x1a
    3812:	98 17       	cp	r25, r24
    3814:	10 f4       	brcc	.+4      	; 0x381a <prvAddNewTaskToReadyList+0x17e>
        {
            taskYIELD_IF_USING_PREEMPTION();
    3816:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    381a:	0f 90       	pop	r0
    381c:	0f 90       	pop	r0
    381e:	0f 90       	pop	r0
    3820:	0f 90       	pop	r0
    3822:	cf 91       	pop	r28
    3824:	df 91       	pop	r29
    3826:	08 95       	ret

00003828 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    3828:	df 93       	push	r29
    382a:	cf 93       	push	r28
    382c:	00 d0       	rcall	.+0      	; 0x382e <vTaskDelay+0x6>
    382e:	00 d0       	rcall	.+0      	; 0x3830 <vTaskDelay+0x8>
    3830:	0f 92       	push	r0
    3832:	cd b7       	in	r28, 0x3d	; 61
    3834:	de b7       	in	r29, 0x3e	; 62
    3836:	6a 83       	std	Y+2, r22	; 0x02
    3838:	7b 83       	std	Y+3, r23	; 0x03
    383a:	8c 83       	std	Y+4, r24	; 0x04
    383c:	9d 83       	std	Y+5, r25	; 0x05
        BaseType_t xAlreadyYielded = pdFALSE;
    383e:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    3840:	8a 81       	ldd	r24, Y+2	; 0x02
    3842:	9b 81       	ldd	r25, Y+3	; 0x03
    3844:	ac 81       	ldd	r26, Y+4	; 0x04
    3846:	bd 81       	ldd	r27, Y+5	; 0x05
    3848:	00 97       	sbiw	r24, 0x00	; 0
    384a:	a1 05       	cpc	r26, r1
    384c:	b1 05       	cpc	r27, r1
    384e:	a1 f0       	breq	.+40     	; 0x3878 <vTaskDelay+0x50>
        {
            configASSERT( uxSchedulerSuspended == 0 );
    3850:	80 91 48 15 	lds	r24, 0x1548
    3854:	88 23       	and	r24, r24
    3856:	11 f0       	breq	.+4      	; 0x385c <vTaskDelay+0x34>
    3858:	f8 94       	cli
    385a:	ff cf       	rjmp	.-2      	; 0x385a <vTaskDelay+0x32>
            vTaskSuspendAll();
    385c:	0e 94 9a 1c 	call	0x3934	; 0x3934 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3860:	8a 81       	ldd	r24, Y+2	; 0x02
    3862:	9b 81       	ldd	r25, Y+3	; 0x03
    3864:	ac 81       	ldd	r26, Y+4	; 0x04
    3866:	bd 81       	ldd	r27, Y+5	; 0x05
    3868:	bc 01       	movw	r22, r24
    386a:	cd 01       	movw	r24, r26
    386c:	40 e0       	ldi	r20, 0x00	; 0
    386e:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    3872:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>
    3876:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3878:	89 81       	ldd	r24, Y+1	; 0x01
    387a:	88 23       	and	r24, r24
    387c:	11 f4       	brne	.+4      	; 0x3882 <vTaskDelay+0x5a>
        {
            portYIELD_WITHIN_API();
    387e:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    3882:	0f 90       	pop	r0
    3884:	0f 90       	pop	r0
    3886:	0f 90       	pop	r0
    3888:	0f 90       	pop	r0
    388a:	0f 90       	pop	r0
    388c:	cf 91       	pop	r28
    388e:	df 91       	pop	r29
    3890:	08 95       	ret

00003892 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3892:	ef 92       	push	r14
    3894:	ff 92       	push	r15
    3896:	0f 93       	push	r16
    3898:	df 93       	push	r29
    389a:	cf 93       	push	r28
    389c:	00 d0       	rcall	.+0      	; 0x389e <vTaskStartScheduler+0xc>
    389e:	cd b7       	in	r28, 0x3d	; 61
    38a0:	de b7       	in	r29, 0x3e	; 62
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
    38a2:	88 e5       	ldi	r24, 0x58	; 88
    38a4:	95 e2       	ldi	r25, 0x25	; 37
    38a6:	20 e0       	ldi	r18, 0x00	; 0
    38a8:	32 e0       	ldi	r19, 0x02	; 2
    38aa:	e6 e4       	ldi	r30, 0x46	; 70
    38ac:	f5 e1       	ldi	r31, 0x15	; 21
    38ae:	b9 01       	movw	r22, r18
    38b0:	40 e8       	ldi	r20, 0x80	; 128
    38b2:	50 e0       	ldi	r21, 0x00	; 0
    38b4:	20 e0       	ldi	r18, 0x00	; 0
    38b6:	30 e0       	ldi	r19, 0x00	; 0
    38b8:	00 e0       	ldi	r16, 0x00	; 0
    38ba:	7f 01       	movw	r14, r30
    38bc:	0e 94 12 1a 	call	0x3424	; 0x3424 <xTaskCreate>
    38c0:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    38c2:	89 81       	ldd	r24, Y+1	; 0x01
    38c4:	81 30       	cpi	r24, 0x01	; 1
    38c6:	d9 f4       	brne	.+54     	; 0x38fe <vTaskStartScheduler+0x6c>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    38c8:	f8 94       	cli
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
    38ca:	8f ef       	ldi	r24, 0xFF	; 255
    38cc:	9f ef       	ldi	r25, 0xFF	; 255
    38ce:	af ef       	ldi	r26, 0xFF	; 255
    38d0:	bf ef       	ldi	r27, 0xFF	; 255
    38d2:	80 93 42 15 	sts	0x1542, r24
    38d6:	90 93 43 15 	sts	0x1543, r25
    38da:	a0 93 44 15 	sts	0x1544, r26
    38de:	b0 93 45 15 	sts	0x1545, r27
        xSchedulerRunning = pdTRUE;
    38e2:	81 e0       	ldi	r24, 0x01	; 1
    38e4:	80 93 3a 15 	sts	0x153A, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    38e8:	10 92 35 15 	sts	0x1535, r1
    38ec:	10 92 36 15 	sts	0x1536, r1
    38f0:	10 92 37 15 	sts	0x1537, r1
    38f4:	10 92 38 15 	sts	0x1538, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
    38f8:	0e 94 a8 08 	call	0x1150	; 0x1150 <xPortStartScheduler>
    38fc:	05 c0       	rjmp	.+10     	; 0x3908 <vTaskStartScheduler+0x76>
    else
    {
        /* This line will only be reached if the kernel could not be started,
         * because there was not enough FreeRTOS heap to create the idle task
         * or the timer task. */
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    38fe:	89 81       	ldd	r24, Y+1	; 0x01
    3900:	8f 3f       	cpi	r24, 0xFF	; 255
    3902:	11 f4       	brne	.+4      	; 0x3908 <vTaskStartScheduler+0x76>
    3904:	f8 94       	cli
    3906:	ff cf       	rjmp	.-2      	; 0x3906 <vTaskStartScheduler+0x74>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    3908:	80 91 4a 03 	lds	r24, 0x034A
}
    390c:	0f 90       	pop	r0
    390e:	0f 90       	pop	r0
    3910:	cf 91       	pop	r28
    3912:	df 91       	pop	r29
    3914:	0f 91       	pop	r16
    3916:	ff 90       	pop	r15
    3918:	ef 90       	pop	r14
    391a:	08 95       	ret

0000391c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    391c:	df 93       	push	r29
    391e:	cf 93       	push	r28
    3920:	cd b7       	in	r28, 0x3d	; 61
    3922:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    3924:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    3926:	10 92 3a 15 	sts	0x153A, r1
    vPortEndScheduler();
    392a:	0e 94 dd 08 	call	0x11ba	; 0x11ba <vPortEndScheduler>
}
    392e:	cf 91       	pop	r28
    3930:	df 91       	pop	r29
    3932:	08 95       	ret

00003934 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3934:	df 93       	push	r29
    3936:	cf 93       	push	r28
    3938:	cd b7       	in	r28, 0x3d	; 61
    393a:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    393c:	80 91 48 15 	lds	r24, 0x1548
    3940:	8f 5f       	subi	r24, 0xFF	; 255
    3942:	80 93 48 15 	sts	0x1548, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    3946:	cf 91       	pop	r28
    3948:	df 91       	pop	r29
    394a:	08 95       	ret

0000394c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    394c:	df 93       	push	r29
    394e:	cf 93       	push	r28
    3950:	cd b7       	in	r28, 0x3d	; 61
    3952:	de b7       	in	r29, 0x3e	; 62
    3954:	2d 97       	sbiw	r28, 0x0d	; 13
    3956:	0f b6       	in	r0, 0x3f	; 63
    3958:	f8 94       	cli
    395a:	de bf       	out	0x3e, r29	; 62
    395c:	0f be       	out	0x3f, r0	; 63
    395e:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    3960:	1d 86       	std	Y+13, r1	; 0x0d
    3962:	1c 86       	std	Y+12, r1	; 0x0c
    BaseType_t xAlreadyYielded = pdFALSE;
    3964:	1b 86       	std	Y+11, r1	; 0x0b

    /* If uxSchedulerSuspended is zero then this function does not match a
     * previous call to vTaskSuspendAll(). */
    configASSERT( uxSchedulerSuspended );
    3966:	80 91 48 15 	lds	r24, 0x1548
    396a:	88 23       	and	r24, r24
    396c:	11 f4       	brne	.+4      	; 0x3972 <xTaskResumeAll+0x26>
    396e:	f8 94       	cli
    3970:	ff cf       	rjmp	.-2      	; 0x3970 <xTaskResumeAll+0x24>
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    3972:	0f b6       	in	r0, 0x3f	; 63
    3974:	f8 94       	cli
    3976:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    3978:	80 91 48 15 	lds	r24, 0x1548
    397c:	81 50       	subi	r24, 0x01	; 1
    397e:	80 93 48 15 	sts	0x1548, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3982:	80 91 48 15 	lds	r24, 0x1548
    3986:	88 23       	and	r24, r24
    3988:	09 f0       	breq	.+2      	; 0x398c <xTaskResumeAll+0x40>
    398a:	4b c1       	rjmp	.+662    	; 0x3c22 <xTaskResumeAll+0x2d6>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    398c:	80 91 34 15 	lds	r24, 0x1534
    3990:	88 23       	and	r24, r24
    3992:	09 f4       	brne	.+2      	; 0x3996 <xTaskResumeAll+0x4a>
    3994:	46 c1       	rjmp	.+652    	; 0x3c22 <xTaskResumeAll+0x2d6>
    3996:	fc c0       	rjmp	.+504    	; 0x3b90 <xTaskResumeAll+0x244>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3998:	e0 91 a1 15 	lds	r30, 0x15A1
    399c:	f0 91 a2 15 	lds	r31, 0x15A2
    39a0:	80 85       	ldd	r24, Z+8	; 0x08
    39a2:	91 85       	ldd	r25, Z+9	; 0x09
    39a4:	9d 87       	std	Y+13, r25	; 0x0d
    39a6:	8c 87       	std	Y+12, r24	; 0x0c
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    39a8:	ec 85       	ldd	r30, Y+12	; 0x0c
    39aa:	fd 85       	ldd	r31, Y+13	; 0x0d
    39ac:	80 8d       	ldd	r24, Z+24	; 0x18
    39ae:	91 8d       	ldd	r25, Z+25	; 0x19
    39b0:	9a 87       	std	Y+10, r25	; 0x0a
    39b2:	89 87       	std	Y+9, r24	; 0x09
    39b4:	ec 85       	ldd	r30, Y+12	; 0x0c
    39b6:	fd 85       	ldd	r31, Y+13	; 0x0d
    39b8:	a2 89       	ldd	r26, Z+18	; 0x12
    39ba:	b3 89       	ldd	r27, Z+19	; 0x13
    39bc:	ec 85       	ldd	r30, Y+12	; 0x0c
    39be:	fd 85       	ldd	r31, Y+13	; 0x0d
    39c0:	84 89       	ldd	r24, Z+20	; 0x14
    39c2:	95 89       	ldd	r25, Z+21	; 0x15
    39c4:	17 96       	adiw	r26, 0x07	; 7
    39c6:	9c 93       	st	X, r25
    39c8:	8e 93       	st	-X, r24
    39ca:	16 97       	sbiw	r26, 0x06	; 6
    39cc:	ec 85       	ldd	r30, Y+12	; 0x0c
    39ce:	fd 85       	ldd	r31, Y+13	; 0x0d
    39d0:	a4 89       	ldd	r26, Z+20	; 0x14
    39d2:	b5 89       	ldd	r27, Z+21	; 0x15
    39d4:	ec 85       	ldd	r30, Y+12	; 0x0c
    39d6:	fd 85       	ldd	r31, Y+13	; 0x0d
    39d8:	82 89       	ldd	r24, Z+18	; 0x12
    39da:	93 89       	ldd	r25, Z+19	; 0x13
    39dc:	15 96       	adiw	r26, 0x05	; 5
    39de:	9c 93       	st	X, r25
    39e0:	8e 93       	st	-X, r24
    39e2:	14 97       	sbiw	r26, 0x04	; 4
    39e4:	e9 85       	ldd	r30, Y+9	; 0x09
    39e6:	fa 85       	ldd	r31, Y+10	; 0x0a
    39e8:	21 81       	ldd	r18, Z+1	; 0x01
    39ea:	32 81       	ldd	r19, Z+2	; 0x02
    39ec:	8c 85       	ldd	r24, Y+12	; 0x0c
    39ee:	9d 85       	ldd	r25, Y+13	; 0x0d
    39f0:	0e 96       	adiw	r24, 0x0e	; 14
    39f2:	28 17       	cp	r18, r24
    39f4:	39 07       	cpc	r19, r25
    39f6:	41 f4       	brne	.+16     	; 0x3a08 <xTaskResumeAll+0xbc>
    39f8:	ec 85       	ldd	r30, Y+12	; 0x0c
    39fa:	fd 85       	ldd	r31, Y+13	; 0x0d
    39fc:	84 89       	ldd	r24, Z+20	; 0x14
    39fe:	95 89       	ldd	r25, Z+21	; 0x15
    3a00:	e9 85       	ldd	r30, Y+9	; 0x09
    3a02:	fa 85       	ldd	r31, Y+10	; 0x0a
    3a04:	92 83       	std	Z+2, r25	; 0x02
    3a06:	81 83       	std	Z+1, r24	; 0x01
    3a08:	ec 85       	ldd	r30, Y+12	; 0x0c
    3a0a:	fd 85       	ldd	r31, Y+13	; 0x0d
    3a0c:	11 8e       	std	Z+25, r1	; 0x19
    3a0e:	10 8e       	std	Z+24, r1	; 0x18
    3a10:	e9 85       	ldd	r30, Y+9	; 0x09
    3a12:	fa 85       	ldd	r31, Y+10	; 0x0a
    3a14:	80 81       	ld	r24, Z
    3a16:	81 50       	subi	r24, 0x01	; 1
    3a18:	e9 85       	ldd	r30, Y+9	; 0x09
    3a1a:	fa 85       	ldd	r31, Y+10	; 0x0a
    3a1c:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3a1e:	ec 85       	ldd	r30, Y+12	; 0x0c
    3a20:	fd 85       	ldd	r31, Y+13	; 0x0d
    3a22:	84 85       	ldd	r24, Z+12	; 0x0c
    3a24:	95 85       	ldd	r25, Z+13	; 0x0d
    3a26:	98 87       	std	Y+8, r25	; 0x08
    3a28:	8f 83       	std	Y+7, r24	; 0x07
    3a2a:	ec 85       	ldd	r30, Y+12	; 0x0c
    3a2c:	fd 85       	ldd	r31, Y+13	; 0x0d
    3a2e:	a6 81       	ldd	r26, Z+6	; 0x06
    3a30:	b7 81       	ldd	r27, Z+7	; 0x07
    3a32:	ec 85       	ldd	r30, Y+12	; 0x0c
    3a34:	fd 85       	ldd	r31, Y+13	; 0x0d
    3a36:	80 85       	ldd	r24, Z+8	; 0x08
    3a38:	91 85       	ldd	r25, Z+9	; 0x09
    3a3a:	17 96       	adiw	r26, 0x07	; 7
    3a3c:	9c 93       	st	X, r25
    3a3e:	8e 93       	st	-X, r24
    3a40:	16 97       	sbiw	r26, 0x06	; 6
    3a42:	ec 85       	ldd	r30, Y+12	; 0x0c
    3a44:	fd 85       	ldd	r31, Y+13	; 0x0d
    3a46:	a0 85       	ldd	r26, Z+8	; 0x08
    3a48:	b1 85       	ldd	r27, Z+9	; 0x09
    3a4a:	ec 85       	ldd	r30, Y+12	; 0x0c
    3a4c:	fd 85       	ldd	r31, Y+13	; 0x0d
    3a4e:	86 81       	ldd	r24, Z+6	; 0x06
    3a50:	97 81       	ldd	r25, Z+7	; 0x07
    3a52:	15 96       	adiw	r26, 0x05	; 5
    3a54:	9c 93       	st	X, r25
    3a56:	8e 93       	st	-X, r24
    3a58:	14 97       	sbiw	r26, 0x04	; 4
    3a5a:	ef 81       	ldd	r30, Y+7	; 0x07
    3a5c:	f8 85       	ldd	r31, Y+8	; 0x08
    3a5e:	21 81       	ldd	r18, Z+1	; 0x01
    3a60:	32 81       	ldd	r19, Z+2	; 0x02
    3a62:	8c 85       	ldd	r24, Y+12	; 0x0c
    3a64:	9d 85       	ldd	r25, Y+13	; 0x0d
    3a66:	02 96       	adiw	r24, 0x02	; 2
    3a68:	28 17       	cp	r18, r24
    3a6a:	39 07       	cpc	r19, r25
    3a6c:	41 f4       	brne	.+16     	; 0x3a7e <xTaskResumeAll+0x132>
    3a6e:	ec 85       	ldd	r30, Y+12	; 0x0c
    3a70:	fd 85       	ldd	r31, Y+13	; 0x0d
    3a72:	80 85       	ldd	r24, Z+8	; 0x08
    3a74:	91 85       	ldd	r25, Z+9	; 0x09
    3a76:	ef 81       	ldd	r30, Y+7	; 0x07
    3a78:	f8 85       	ldd	r31, Y+8	; 0x08
    3a7a:	92 83       	std	Z+2, r25	; 0x02
    3a7c:	81 83       	std	Z+1, r24	; 0x01
    3a7e:	ec 85       	ldd	r30, Y+12	; 0x0c
    3a80:	fd 85       	ldd	r31, Y+13	; 0x0d
    3a82:	15 86       	std	Z+13, r1	; 0x0d
    3a84:	14 86       	std	Z+12, r1	; 0x0c
    3a86:	ef 81       	ldd	r30, Y+7	; 0x07
    3a88:	f8 85       	ldd	r31, Y+8	; 0x08
    3a8a:	80 81       	ld	r24, Z
    3a8c:	81 50       	subi	r24, 0x01	; 1
    3a8e:	ef 81       	ldd	r30, Y+7	; 0x07
    3a90:	f8 85       	ldd	r31, Y+8	; 0x08
    3a92:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    3a94:	ec 85       	ldd	r30, Y+12	; 0x0c
    3a96:	fd 85       	ldd	r31, Y+13	; 0x0d
    3a98:	92 8d       	ldd	r25, Z+26	; 0x1a
    3a9a:	80 91 39 15 	lds	r24, 0x1539
    3a9e:	89 17       	cp	r24, r25
    3aa0:	28 f4       	brcc	.+10     	; 0x3aac <xTaskResumeAll+0x160>
    3aa2:	ec 85       	ldd	r30, Y+12	; 0x0c
    3aa4:	fd 85       	ldd	r31, Y+13	; 0x0d
    3aa6:	82 8d       	ldd	r24, Z+26	; 0x1a
    3aa8:	80 93 39 15 	sts	0x1539, r24
    3aac:	ec 85       	ldd	r30, Y+12	; 0x0c
    3aae:	fd 85       	ldd	r31, Y+13	; 0x0d
    3ab0:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ab2:	48 2f       	mov	r20, r24
    3ab4:	50 e0       	ldi	r21, 0x00	; 0
    3ab6:	ca 01       	movw	r24, r20
    3ab8:	88 0f       	add	r24, r24
    3aba:	99 1f       	adc	r25, r25
    3abc:	9c 01       	movw	r18, r24
    3abe:	22 0f       	add	r18, r18
    3ac0:	33 1f       	adc	r19, r19
    3ac2:	22 0f       	add	r18, r18
    3ac4:	33 1f       	adc	r19, r19
    3ac6:	82 0f       	add	r24, r18
    3ac8:	93 1f       	adc	r25, r19
    3aca:	84 0f       	add	r24, r20
    3acc:	95 1f       	adc	r25, r21
    3ace:	fc 01       	movw	r30, r24
    3ad0:	e7 5b       	subi	r30, 0xB7	; 183
    3ad2:	fa 4e       	sbci	r31, 0xEA	; 234
    3ad4:	81 81       	ldd	r24, Z+1	; 0x01
    3ad6:	92 81       	ldd	r25, Z+2	; 0x02
    3ad8:	9e 83       	std	Y+6, r25	; 0x06
    3ada:	8d 83       	std	Y+5, r24	; 0x05
    3adc:	ec 85       	ldd	r30, Y+12	; 0x0c
    3ade:	fd 85       	ldd	r31, Y+13	; 0x0d
    3ae0:	8d 81       	ldd	r24, Y+5	; 0x05
    3ae2:	9e 81       	ldd	r25, Y+6	; 0x06
    3ae4:	97 83       	std	Z+7, r25	; 0x07
    3ae6:	86 83       	std	Z+6, r24	; 0x06
    3ae8:	ed 81       	ldd	r30, Y+5	; 0x05
    3aea:	fe 81       	ldd	r31, Y+6	; 0x06
    3aec:	86 81       	ldd	r24, Z+6	; 0x06
    3aee:	97 81       	ldd	r25, Z+7	; 0x07
    3af0:	ec 85       	ldd	r30, Y+12	; 0x0c
    3af2:	fd 85       	ldd	r31, Y+13	; 0x0d
    3af4:	91 87       	std	Z+9, r25	; 0x09
    3af6:	80 87       	std	Z+8, r24	; 0x08
    3af8:	ed 81       	ldd	r30, Y+5	; 0x05
    3afa:	fe 81       	ldd	r31, Y+6	; 0x06
    3afc:	06 80       	ldd	r0, Z+6	; 0x06
    3afe:	f7 81       	ldd	r31, Z+7	; 0x07
    3b00:	e0 2d       	mov	r30, r0
    3b02:	8c 85       	ldd	r24, Y+12	; 0x0c
    3b04:	9d 85       	ldd	r25, Y+13	; 0x0d
    3b06:	02 96       	adiw	r24, 0x02	; 2
    3b08:	95 83       	std	Z+5, r25	; 0x05
    3b0a:	84 83       	std	Z+4, r24	; 0x04
    3b0c:	8c 85       	ldd	r24, Y+12	; 0x0c
    3b0e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3b10:	02 96       	adiw	r24, 0x02	; 2
    3b12:	ed 81       	ldd	r30, Y+5	; 0x05
    3b14:	fe 81       	ldd	r31, Y+6	; 0x06
    3b16:	97 83       	std	Z+7, r25	; 0x07
    3b18:	86 83       	std	Z+6, r24	; 0x06
    3b1a:	ec 85       	ldd	r30, Y+12	; 0x0c
    3b1c:	fd 85       	ldd	r31, Y+13	; 0x0d
    3b1e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b20:	48 2f       	mov	r20, r24
    3b22:	50 e0       	ldi	r21, 0x00	; 0
    3b24:	ca 01       	movw	r24, r20
    3b26:	88 0f       	add	r24, r24
    3b28:	99 1f       	adc	r25, r25
    3b2a:	9c 01       	movw	r18, r24
    3b2c:	22 0f       	add	r18, r18
    3b2e:	33 1f       	adc	r19, r19
    3b30:	22 0f       	add	r18, r18
    3b32:	33 1f       	adc	r19, r19
    3b34:	82 0f       	add	r24, r18
    3b36:	93 1f       	adc	r25, r19
    3b38:	84 0f       	add	r24, r20
    3b3a:	95 1f       	adc	r25, r21
    3b3c:	87 5b       	subi	r24, 0xB7	; 183
    3b3e:	9a 4e       	sbci	r25, 0xEA	; 234
    3b40:	ec 85       	ldd	r30, Y+12	; 0x0c
    3b42:	fd 85       	ldd	r31, Y+13	; 0x0d
    3b44:	95 87       	std	Z+13, r25	; 0x0d
    3b46:	84 87       	std	Z+12, r24	; 0x0c
    3b48:	ec 85       	ldd	r30, Y+12	; 0x0c
    3b4a:	fd 85       	ldd	r31, Y+13	; 0x0d
    3b4c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b4e:	48 2f       	mov	r20, r24
    3b50:	50 e0       	ldi	r21, 0x00	; 0
    3b52:	ca 01       	movw	r24, r20
    3b54:	88 0f       	add	r24, r24
    3b56:	99 1f       	adc	r25, r25
    3b58:	9c 01       	movw	r18, r24
    3b5a:	22 0f       	add	r18, r18
    3b5c:	33 1f       	adc	r19, r19
    3b5e:	22 0f       	add	r18, r18
    3b60:	33 1f       	adc	r19, r19
    3b62:	82 0f       	add	r24, r18
    3b64:	93 1f       	adc	r25, r19
    3b66:	84 0f       	add	r24, r20
    3b68:	95 1f       	adc	r25, r21
    3b6a:	fc 01       	movw	r30, r24
    3b6c:	e7 5b       	subi	r30, 0xB7	; 183
    3b6e:	fa 4e       	sbci	r31, 0xEA	; 234
    3b70:	80 81       	ld	r24, Z
    3b72:	8f 5f       	subi	r24, 0xFF	; 255
    3b74:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3b76:	ec 85       	ldd	r30, Y+12	; 0x0c
    3b78:	fd 85       	ldd	r31, Y+13	; 0x0d
    3b7a:	92 8d       	ldd	r25, Z+26	; 0x1a
    3b7c:	e0 91 32 15 	lds	r30, 0x1532
    3b80:	f0 91 33 15 	lds	r31, 0x1533
    3b84:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b86:	98 17       	cp	r25, r24
    3b88:	18 f0       	brcs	.+6      	; 0x3b90 <xTaskResumeAll+0x244>
                    {
                        xYieldPending = pdTRUE;
    3b8a:	81 e0       	ldi	r24, 0x01	; 1
    3b8c:	80 93 3f 15 	sts	0x153F, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3b90:	80 91 9a 15 	lds	r24, 0x159A
    3b94:	88 23       	and	r24, r24
    3b96:	09 f0       	breq	.+2      	; 0x3b9a <xTaskResumeAll+0x24e>
    3b98:	ff ce       	rjmp	.-514    	; 0x3998 <xTaskResumeAll+0x4c>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    3b9a:	8c 85       	ldd	r24, Y+12	; 0x0c
    3b9c:	9d 85       	ldd	r25, Y+13	; 0x0d
    3b9e:	00 97       	sbiw	r24, 0x00	; 0
    3ba0:	11 f0       	breq	.+4      	; 0x3ba6 <xTaskResumeAll+0x25a>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    3ba2:	0e 94 ab 25 	call	0x4b56	; 0x4b56 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3ba6:	80 91 3b 15 	lds	r24, 0x153B
    3baa:	90 91 3c 15 	lds	r25, 0x153C
    3bae:	a0 91 3d 15 	lds	r26, 0x153D
    3bb2:	b0 91 3e 15 	lds	r27, 0x153E
    3bb6:	89 83       	std	Y+1, r24	; 0x01
    3bb8:	9a 83       	std	Y+2, r25	; 0x02
    3bba:	ab 83       	std	Y+3, r26	; 0x03
    3bbc:	bc 83       	std	Y+4, r27	; 0x04

                    if( xPendedCounts > ( TickType_t ) 0U )
    3bbe:	89 81       	ldd	r24, Y+1	; 0x01
    3bc0:	9a 81       	ldd	r25, Y+2	; 0x02
    3bc2:	ab 81       	ldd	r26, Y+3	; 0x03
    3bc4:	bc 81       	ldd	r27, Y+4	; 0x04
    3bc6:	00 97       	sbiw	r24, 0x00	; 0
    3bc8:	a1 05       	cpc	r26, r1
    3bca:	b1 05       	cpc	r27, r1
    3bcc:	11 f1       	breq	.+68     	; 0x3c12 <xTaskResumeAll+0x2c6>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    3bce:	0e 94 d6 1e 	call	0x3dac	; 0x3dac <xTaskIncrementTick>
    3bd2:	88 23       	and	r24, r24
    3bd4:	19 f0       	breq	.+6      	; 0x3bdc <xTaskResumeAll+0x290>
                            {
                                xYieldPending = pdTRUE;
    3bd6:	81 e0       	ldi	r24, 0x01	; 1
    3bd8:	80 93 3f 15 	sts	0x153F, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    3bdc:	89 81       	ldd	r24, Y+1	; 0x01
    3bde:	9a 81       	ldd	r25, Y+2	; 0x02
    3be0:	ab 81       	ldd	r26, Y+3	; 0x03
    3be2:	bc 81       	ldd	r27, Y+4	; 0x04
    3be4:	01 97       	sbiw	r24, 0x01	; 1
    3be6:	a1 09       	sbc	r26, r1
    3be8:	b1 09       	sbc	r27, r1
    3bea:	89 83       	std	Y+1, r24	; 0x01
    3bec:	9a 83       	std	Y+2, r25	; 0x02
    3bee:	ab 83       	std	Y+3, r26	; 0x03
    3bf0:	bc 83       	std	Y+4, r27	; 0x04
                        } while( xPendedCounts > ( TickType_t ) 0U );
    3bf2:	89 81       	ldd	r24, Y+1	; 0x01
    3bf4:	9a 81       	ldd	r25, Y+2	; 0x02
    3bf6:	ab 81       	ldd	r26, Y+3	; 0x03
    3bf8:	bc 81       	ldd	r27, Y+4	; 0x04
    3bfa:	00 97       	sbiw	r24, 0x00	; 0
    3bfc:	a1 05       	cpc	r26, r1
    3bfe:	b1 05       	cpc	r27, r1
    3c00:	31 f7       	brne	.-52     	; 0x3bce <xTaskResumeAll+0x282>

                        xPendedTicks = 0;
    3c02:	10 92 3b 15 	sts	0x153B, r1
    3c06:	10 92 3c 15 	sts	0x153C, r1
    3c0a:	10 92 3d 15 	sts	0x153D, r1
    3c0e:	10 92 3e 15 	sts	0x153E, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    3c12:	80 91 3f 15 	lds	r24, 0x153F
    3c16:	88 23       	and	r24, r24
    3c18:	21 f0       	breq	.+8      	; 0x3c22 <xTaskResumeAll+0x2d6>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
    3c1a:	81 e0       	ldi	r24, 0x01	; 1
    3c1c:	8b 87       	std	Y+11, r24	; 0x0b
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    3c1e:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    3c22:	0f 90       	pop	r0
    3c24:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    3c26:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    3c28:	2d 96       	adiw	r28, 0x0d	; 13
    3c2a:	0f b6       	in	r0, 0x3f	; 63
    3c2c:	f8 94       	cli
    3c2e:	de bf       	out	0x3e, r29	; 62
    3c30:	0f be       	out	0x3f, r0	; 63
    3c32:	cd bf       	out	0x3d, r28	; 61
    3c34:	cf 91       	pop	r28
    3c36:	df 91       	pop	r29
    3c38:	08 95       	ret

00003c3a <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3c3a:	df 93       	push	r29
    3c3c:	cf 93       	push	r28
    3c3e:	00 d0       	rcall	.+0      	; 0x3c40 <xTaskGetTickCount+0x6>
    3c40:	00 d0       	rcall	.+0      	; 0x3c42 <xTaskGetTickCount+0x8>
    3c42:	cd b7       	in	r28, 0x3d	; 61
    3c44:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    3c46:	0f b6       	in	r0, 0x3f	; 63
    3c48:	f8 94       	cli
    3c4a:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    3c4c:	80 91 35 15 	lds	r24, 0x1535
    3c50:	90 91 36 15 	lds	r25, 0x1536
    3c54:	a0 91 37 15 	lds	r26, 0x1537
    3c58:	b0 91 38 15 	lds	r27, 0x1538
    3c5c:	89 83       	std	Y+1, r24	; 0x01
    3c5e:	9a 83       	std	Y+2, r25	; 0x02
    3c60:	ab 83       	std	Y+3, r26	; 0x03
    3c62:	bc 83       	std	Y+4, r27	; 0x04
    }
    portTICK_TYPE_EXIT_CRITICAL();
    3c64:	0f 90       	pop	r0
    3c66:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    3c68:	89 81       	ldd	r24, Y+1	; 0x01
    3c6a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c6c:	ab 81       	ldd	r26, Y+3	; 0x03
    3c6e:	bc 81       	ldd	r27, Y+4	; 0x04
}
    3c70:	bc 01       	movw	r22, r24
    3c72:	cd 01       	movw	r24, r26
    3c74:	0f 90       	pop	r0
    3c76:	0f 90       	pop	r0
    3c78:	0f 90       	pop	r0
    3c7a:	0f 90       	pop	r0
    3c7c:	cf 91       	pop	r28
    3c7e:	df 91       	pop	r29
    3c80:	08 95       	ret

00003c82 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3c82:	df 93       	push	r29
    3c84:	cf 93       	push	r28
    3c86:	00 d0       	rcall	.+0      	; 0x3c88 <xTaskGetTickCountFromISR+0x6>
    3c88:	00 d0       	rcall	.+0      	; 0x3c8a <xTaskGetTickCountFromISR+0x8>
    3c8a:	0f 92       	push	r0
    3c8c:	cd b7       	in	r28, 0x3d	; 61
    3c8e:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3c90:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    3c92:	80 91 35 15 	lds	r24, 0x1535
    3c96:	90 91 36 15 	lds	r25, 0x1536
    3c9a:	a0 91 37 15 	lds	r26, 0x1537
    3c9e:	b0 91 38 15 	lds	r27, 0x1538
    3ca2:	8a 83       	std	Y+2, r24	; 0x02
    3ca4:	9b 83       	std	Y+3, r25	; 0x03
    3ca6:	ac 83       	std	Y+4, r26	; 0x04
    3ca8:	bd 83       	std	Y+5, r27	; 0x05
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3caa:	8a 81       	ldd	r24, Y+2	; 0x02
    3cac:	9b 81       	ldd	r25, Y+3	; 0x03
    3cae:	ac 81       	ldd	r26, Y+4	; 0x04
    3cb0:	bd 81       	ldd	r27, Y+5	; 0x05
}
    3cb2:	bc 01       	movw	r22, r24
    3cb4:	cd 01       	movw	r24, r26
    3cb6:	0f 90       	pop	r0
    3cb8:	0f 90       	pop	r0
    3cba:	0f 90       	pop	r0
    3cbc:	0f 90       	pop	r0
    3cbe:	0f 90       	pop	r0
    3cc0:	cf 91       	pop	r28
    3cc2:	df 91       	pop	r29
    3cc4:	08 95       	ret

00003cc6 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3cc6:	df 93       	push	r29
    3cc8:	cf 93       	push	r28
    3cca:	cd b7       	in	r28, 0x3d	; 61
    3ccc:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    3cce:	80 91 34 15 	lds	r24, 0x1534
}
    3cd2:	cf 91       	pop	r28
    3cd4:	df 91       	pop	r29
    3cd6:	08 95       	ret

00003cd8 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3cd8:	df 93       	push	r29
    3cda:	cf 93       	push	r28
    3cdc:	00 d0       	rcall	.+0      	; 0x3cde <pcTaskGetName+0x6>
    3cde:	00 d0       	rcall	.+0      	; 0x3ce0 <pcTaskGetName+0x8>
    3ce0:	00 d0       	rcall	.+0      	; 0x3ce2 <pcTaskGetName+0xa>
    3ce2:	cd b7       	in	r28, 0x3d	; 61
    3ce4:	de b7       	in	r29, 0x3e	; 62
    3ce6:	9c 83       	std	Y+4, r25	; 0x04
    3ce8:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3cea:	8b 81       	ldd	r24, Y+3	; 0x03
    3cec:	9c 81       	ldd	r25, Y+4	; 0x04
    3cee:	00 97       	sbiw	r24, 0x00	; 0
    3cf0:	39 f4       	brne	.+14     	; 0x3d00 <pcTaskGetName+0x28>
    3cf2:	80 91 32 15 	lds	r24, 0x1532
    3cf6:	90 91 33 15 	lds	r25, 0x1533
    3cfa:	9e 83       	std	Y+6, r25	; 0x06
    3cfc:	8d 83       	std	Y+5, r24	; 0x05
    3cfe:	04 c0       	rjmp	.+8      	; 0x3d08 <pcTaskGetName+0x30>
    3d00:	8b 81       	ldd	r24, Y+3	; 0x03
    3d02:	9c 81       	ldd	r25, Y+4	; 0x04
    3d04:	9e 83       	std	Y+6, r25	; 0x06
    3d06:	8d 83       	std	Y+5, r24	; 0x05
    3d08:	8d 81       	ldd	r24, Y+5	; 0x05
    3d0a:	9e 81       	ldd	r25, Y+6	; 0x06
    3d0c:	9a 83       	std	Y+2, r25	; 0x02
    3d0e:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    3d10:	89 81       	ldd	r24, Y+1	; 0x01
    3d12:	9a 81       	ldd	r25, Y+2	; 0x02
    3d14:	00 97       	sbiw	r24, 0x00	; 0
    3d16:	11 f4       	brne	.+4      	; 0x3d1c <pcTaskGetName+0x44>
    3d18:	f8 94       	cli
    3d1a:	ff cf       	rjmp	.-2      	; 0x3d1a <pcTaskGetName+0x42>
    return &( pxTCB->pcTaskName[ 0 ] );
    3d1c:	89 81       	ldd	r24, Y+1	; 0x01
    3d1e:	9a 81       	ldd	r25, Y+2	; 0x02
    3d20:	4d 96       	adiw	r24, 0x1d	; 29
}
    3d22:	26 96       	adiw	r28, 0x06	; 6
    3d24:	0f b6       	in	r0, 0x3f	; 63
    3d26:	f8 94       	cli
    3d28:	de bf       	out	0x3e, r29	; 62
    3d2a:	0f be       	out	0x3f, r0	; 63
    3d2c:	cd bf       	out	0x3d, r28	; 61
    3d2e:	cf 91       	pop	r28
    3d30:	df 91       	pop	r29
    3d32:	08 95       	ret

00003d34 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    3d34:	df 93       	push	r29
    3d36:	cf 93       	push	r28
    3d38:	00 d0       	rcall	.+0      	; 0x3d3a <xTaskCatchUpTicks+0x6>
    3d3a:	00 d0       	rcall	.+0      	; 0x3d3c <xTaskCatchUpTicks+0x8>
    3d3c:	0f 92       	push	r0
    3d3e:	cd b7       	in	r28, 0x3d	; 61
    3d40:	de b7       	in	r29, 0x3e	; 62
    3d42:	6a 83       	std	Y+2, r22	; 0x02
    3d44:	7b 83       	std	Y+3, r23	; 0x03
    3d46:	8c 83       	std	Y+4, r24	; 0x04
    3d48:	9d 83       	std	Y+5, r25	; 0x05
    BaseType_t xYieldOccurred;

    /* Must not be called with the scheduler suspended as the implementation
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );
    3d4a:	80 91 48 15 	lds	r24, 0x1548
    3d4e:	88 23       	and	r24, r24
    3d50:	11 f0       	breq	.+4      	; 0x3d56 <xTaskCatchUpTicks+0x22>
    3d52:	f8 94       	cli
    3d54:	ff cf       	rjmp	.-2      	; 0x3d54 <xTaskCatchUpTicks+0x20>

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    3d56:	0e 94 9a 1c 	call	0x3934	; 0x3934 <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
    3d5a:	0f b6       	in	r0, 0x3f	; 63
    3d5c:	f8 94       	cli
    3d5e:	0f 92       	push	r0
    {
        xPendedTicks += xTicksToCatchUp;
    3d60:	20 91 3b 15 	lds	r18, 0x153B
    3d64:	30 91 3c 15 	lds	r19, 0x153C
    3d68:	40 91 3d 15 	lds	r20, 0x153D
    3d6c:	50 91 3e 15 	lds	r21, 0x153E
    3d70:	8a 81       	ldd	r24, Y+2	; 0x02
    3d72:	9b 81       	ldd	r25, Y+3	; 0x03
    3d74:	ac 81       	ldd	r26, Y+4	; 0x04
    3d76:	bd 81       	ldd	r27, Y+5	; 0x05
    3d78:	82 0f       	add	r24, r18
    3d7a:	93 1f       	adc	r25, r19
    3d7c:	a4 1f       	adc	r26, r20
    3d7e:	b5 1f       	adc	r27, r21
    3d80:	80 93 3b 15 	sts	0x153B, r24
    3d84:	90 93 3c 15 	sts	0x153C, r25
    3d88:	a0 93 3d 15 	sts	0x153D, r26
    3d8c:	b0 93 3e 15 	sts	0x153E, r27
    }
    taskEXIT_CRITICAL();
    3d90:	0f 90       	pop	r0
    3d92:	0f be       	out	0x3f, r0	; 63
    xYieldOccurred = xTaskResumeAll();
    3d94:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskResumeAll>
    3d98:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    3d9a:	89 81       	ldd	r24, Y+1	; 0x01
}
    3d9c:	0f 90       	pop	r0
    3d9e:	0f 90       	pop	r0
    3da0:	0f 90       	pop	r0
    3da2:	0f 90       	pop	r0
    3da4:	0f 90       	pop	r0
    3da6:	cf 91       	pop	r28
    3da8:	df 91       	pop	r29
    3daa:	08 95       	ret

00003dac <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3dac:	df 93       	push	r29
    3dae:	cf 93       	push	r28
    3db0:	cd b7       	in	r28, 0x3d	; 61
    3db2:	de b7       	in	r29, 0x3e	; 62
    3db4:	63 97       	sbiw	r28, 0x13	; 19
    3db6:	0f b6       	in	r0, 0x3f	; 63
    3db8:	f8 94       	cli
    3dba:	de bf       	out	0x3e, r29	; 62
    3dbc:	0f be       	out	0x3f, r0	; 63
    3dbe:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    3dc0:	1d 86       	std	Y+13, r1	; 0x0d
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3dc2:	80 91 48 15 	lds	r24, 0x1548
    3dc6:	88 23       	and	r24, r24
    3dc8:	09 f0       	breq	.+2      	; 0x3dcc <xTaskIncrementTick+0x20>
    3dca:	b9 c1       	rjmp	.+882    	; 0x413e <xTaskIncrementTick+0x392>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3dcc:	80 91 35 15 	lds	r24, 0x1535
    3dd0:	90 91 36 15 	lds	r25, 0x1536
    3dd4:	a0 91 37 15 	lds	r26, 0x1537
    3dd8:	b0 91 38 15 	lds	r27, 0x1538
    3ddc:	01 96       	adiw	r24, 0x01	; 1
    3dde:	a1 1d       	adc	r26, r1
    3de0:	b1 1d       	adc	r27, r1
    3de2:	89 87       	std	Y+9, r24	; 0x09
    3de4:	9a 87       	std	Y+10, r25	; 0x0a
    3de6:	ab 87       	std	Y+11, r26	; 0x0b
    3de8:	bc 87       	std	Y+12, r27	; 0x0c

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    3dea:	89 85       	ldd	r24, Y+9	; 0x09
    3dec:	9a 85       	ldd	r25, Y+10	; 0x0a
    3dee:	ab 85       	ldd	r26, Y+11	; 0x0b
    3df0:	bc 85       	ldd	r27, Y+12	; 0x0c
    3df2:	80 93 35 15 	sts	0x1535, r24
    3df6:	90 93 36 15 	sts	0x1536, r25
    3dfa:	a0 93 37 15 	sts	0x1537, r26
    3dfe:	b0 93 38 15 	sts	0x1538, r27

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    3e02:	89 85       	ldd	r24, Y+9	; 0x09
    3e04:	9a 85       	ldd	r25, Y+10	; 0x0a
    3e06:	ab 85       	ldd	r26, Y+11	; 0x0b
    3e08:	bc 85       	ldd	r27, Y+12	; 0x0c
    3e0a:	00 97       	sbiw	r24, 0x00	; 0
    3e0c:	a1 05       	cpc	r26, r1
    3e0e:	b1 05       	cpc	r27, r1
    3e10:	21 f5       	brne	.+72     	; 0x3e5a <xTaskIncrementTick+0xae>
        {
            taskSWITCH_DELAYED_LISTS();
    3e12:	e0 91 96 15 	lds	r30, 0x1596
    3e16:	f0 91 97 15 	lds	r31, 0x1597
    3e1a:	80 81       	ld	r24, Z
    3e1c:	88 23       	and	r24, r24
    3e1e:	11 f0       	breq	.+4      	; 0x3e24 <xTaskIncrementTick+0x78>
    3e20:	f8 94       	cli
    3e22:	ff cf       	rjmp	.-2      	; 0x3e22 <xTaskIncrementTick+0x76>
    3e24:	80 91 96 15 	lds	r24, 0x1596
    3e28:	90 91 97 15 	lds	r25, 0x1597
    3e2c:	98 87       	std	Y+8, r25	; 0x08
    3e2e:	8f 83       	std	Y+7, r24	; 0x07
    3e30:	80 91 98 15 	lds	r24, 0x1598
    3e34:	90 91 99 15 	lds	r25, 0x1599
    3e38:	90 93 97 15 	sts	0x1597, r25
    3e3c:	80 93 96 15 	sts	0x1596, r24
    3e40:	8f 81       	ldd	r24, Y+7	; 0x07
    3e42:	98 85       	ldd	r25, Y+8	; 0x08
    3e44:	90 93 99 15 	sts	0x1599, r25
    3e48:	80 93 98 15 	sts	0x1598, r24
    3e4c:	80 91 40 15 	lds	r24, 0x1540
    3e50:	8f 5f       	subi	r24, 0xFF	; 255
    3e52:	80 93 40 15 	sts	0x1540, r24
    3e56:	0e 94 ab 25 	call	0x4b56	; 0x4b56 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    3e5a:	20 91 42 15 	lds	r18, 0x1542
    3e5e:	30 91 43 15 	lds	r19, 0x1543
    3e62:	40 91 44 15 	lds	r20, 0x1544
    3e66:	50 91 45 15 	lds	r21, 0x1545
    3e6a:	89 85       	ldd	r24, Y+9	; 0x09
    3e6c:	9a 85       	ldd	r25, Y+10	; 0x0a
    3e6e:	ab 85       	ldd	r26, Y+11	; 0x0b
    3e70:	bc 85       	ldd	r27, Y+12	; 0x0c
    3e72:	82 17       	cp	r24, r18
    3e74:	93 07       	cpc	r25, r19
    3e76:	a4 07       	cpc	r26, r20
    3e78:	b5 07       	cpc	r27, r21
    3e7a:	08 f4       	brcc	.+2      	; 0x3e7e <xTaskIncrementTick+0xd2>
    3e7c:	3e c1       	rjmp	.+636    	; 0x40fa <xTaskIncrementTick+0x34e>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3e7e:	e0 91 96 15 	lds	r30, 0x1596
    3e82:	f0 91 97 15 	lds	r31, 0x1597
    3e86:	80 81       	ld	r24, Z
    3e88:	88 23       	and	r24, r24
    3e8a:	69 f4       	brne	.+26     	; 0x3ea6 <xTaskIncrementTick+0xfa>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3e8c:	8f ef       	ldi	r24, 0xFF	; 255
    3e8e:	9f ef       	ldi	r25, 0xFF	; 255
    3e90:	af ef       	ldi	r26, 0xFF	; 255
    3e92:	bf ef       	ldi	r27, 0xFF	; 255
    3e94:	80 93 42 15 	sts	0x1542, r24
    3e98:	90 93 43 15 	sts	0x1543, r25
    3e9c:	a0 93 44 15 	sts	0x1544, r26
    3ea0:	b0 93 45 15 	sts	0x1545, r27
    3ea4:	2a c1       	rjmp	.+596    	; 0x40fa <xTaskIncrementTick+0x34e>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3ea6:	e0 91 96 15 	lds	r30, 0x1596
    3eaa:	f0 91 97 15 	lds	r31, 0x1597
    3eae:	07 80       	ldd	r0, Z+7	; 0x07
    3eb0:	f0 85       	ldd	r31, Z+8	; 0x08
    3eb2:	e0 2d       	mov	r30, r0
    3eb4:	80 85       	ldd	r24, Z+8	; 0x08
    3eb6:	91 85       	ldd	r25, Z+9	; 0x09
    3eb8:	9b 8b       	std	Y+19, r25	; 0x13
    3eba:	8a 8b       	std	Y+18, r24	; 0x12
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3ebc:	ea 89       	ldd	r30, Y+18	; 0x12
    3ebe:	fb 89       	ldd	r31, Y+19	; 0x13
    3ec0:	82 81       	ldd	r24, Z+2	; 0x02
    3ec2:	93 81       	ldd	r25, Z+3	; 0x03
    3ec4:	a4 81       	ldd	r26, Z+4	; 0x04
    3ec6:	b5 81       	ldd	r27, Z+5	; 0x05
    3ec8:	8e 87       	std	Y+14, r24	; 0x0e
    3eca:	9f 87       	std	Y+15, r25	; 0x0f
    3ecc:	a8 8b       	std	Y+16, r26	; 0x10
    3ece:	b9 8b       	std	Y+17, r27	; 0x11

                    if( xConstTickCount < xItemValue )
    3ed0:	29 85       	ldd	r18, Y+9	; 0x09
    3ed2:	3a 85       	ldd	r19, Y+10	; 0x0a
    3ed4:	4b 85       	ldd	r20, Y+11	; 0x0b
    3ed6:	5c 85       	ldd	r21, Y+12	; 0x0c
    3ed8:	8e 85       	ldd	r24, Y+14	; 0x0e
    3eda:	9f 85       	ldd	r25, Y+15	; 0x0f
    3edc:	a8 89       	ldd	r26, Y+16	; 0x10
    3ede:	b9 89       	ldd	r27, Y+17	; 0x11
    3ee0:	28 17       	cp	r18, r24
    3ee2:	39 07       	cpc	r19, r25
    3ee4:	4a 07       	cpc	r20, r26
    3ee6:	5b 07       	cpc	r21, r27
    3ee8:	68 f4       	brcc	.+26     	; 0x3f04 <xTaskIncrementTick+0x158>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    3eea:	8e 85       	ldd	r24, Y+14	; 0x0e
    3eec:	9f 85       	ldd	r25, Y+15	; 0x0f
    3eee:	a8 89       	ldd	r26, Y+16	; 0x10
    3ef0:	b9 89       	ldd	r27, Y+17	; 0x11
    3ef2:	80 93 42 15 	sts	0x1542, r24
    3ef6:	90 93 43 15 	sts	0x1543, r25
    3efa:	a0 93 44 15 	sts	0x1544, r26
    3efe:	b0 93 45 15 	sts	0x1545, r27
    3f02:	fb c0       	rjmp	.+502    	; 0x40fa <xTaskIncrementTick+0x34e>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3f04:	ea 89       	ldd	r30, Y+18	; 0x12
    3f06:	fb 89       	ldd	r31, Y+19	; 0x13
    3f08:	84 85       	ldd	r24, Z+12	; 0x0c
    3f0a:	95 85       	ldd	r25, Z+13	; 0x0d
    3f0c:	9e 83       	std	Y+6, r25	; 0x06
    3f0e:	8d 83       	std	Y+5, r24	; 0x05
    3f10:	ea 89       	ldd	r30, Y+18	; 0x12
    3f12:	fb 89       	ldd	r31, Y+19	; 0x13
    3f14:	a6 81       	ldd	r26, Z+6	; 0x06
    3f16:	b7 81       	ldd	r27, Z+7	; 0x07
    3f18:	ea 89       	ldd	r30, Y+18	; 0x12
    3f1a:	fb 89       	ldd	r31, Y+19	; 0x13
    3f1c:	80 85       	ldd	r24, Z+8	; 0x08
    3f1e:	91 85       	ldd	r25, Z+9	; 0x09
    3f20:	17 96       	adiw	r26, 0x07	; 7
    3f22:	9c 93       	st	X, r25
    3f24:	8e 93       	st	-X, r24
    3f26:	16 97       	sbiw	r26, 0x06	; 6
    3f28:	ea 89       	ldd	r30, Y+18	; 0x12
    3f2a:	fb 89       	ldd	r31, Y+19	; 0x13
    3f2c:	a0 85       	ldd	r26, Z+8	; 0x08
    3f2e:	b1 85       	ldd	r27, Z+9	; 0x09
    3f30:	ea 89       	ldd	r30, Y+18	; 0x12
    3f32:	fb 89       	ldd	r31, Y+19	; 0x13
    3f34:	86 81       	ldd	r24, Z+6	; 0x06
    3f36:	97 81       	ldd	r25, Z+7	; 0x07
    3f38:	15 96       	adiw	r26, 0x05	; 5
    3f3a:	9c 93       	st	X, r25
    3f3c:	8e 93       	st	-X, r24
    3f3e:	14 97       	sbiw	r26, 0x04	; 4
    3f40:	ed 81       	ldd	r30, Y+5	; 0x05
    3f42:	fe 81       	ldd	r31, Y+6	; 0x06
    3f44:	21 81       	ldd	r18, Z+1	; 0x01
    3f46:	32 81       	ldd	r19, Z+2	; 0x02
    3f48:	8a 89       	ldd	r24, Y+18	; 0x12
    3f4a:	9b 89       	ldd	r25, Y+19	; 0x13
    3f4c:	02 96       	adiw	r24, 0x02	; 2
    3f4e:	28 17       	cp	r18, r24
    3f50:	39 07       	cpc	r19, r25
    3f52:	41 f4       	brne	.+16     	; 0x3f64 <xTaskIncrementTick+0x1b8>
    3f54:	ea 89       	ldd	r30, Y+18	; 0x12
    3f56:	fb 89       	ldd	r31, Y+19	; 0x13
    3f58:	80 85       	ldd	r24, Z+8	; 0x08
    3f5a:	91 85       	ldd	r25, Z+9	; 0x09
    3f5c:	ed 81       	ldd	r30, Y+5	; 0x05
    3f5e:	fe 81       	ldd	r31, Y+6	; 0x06
    3f60:	92 83       	std	Z+2, r25	; 0x02
    3f62:	81 83       	std	Z+1, r24	; 0x01
    3f64:	ea 89       	ldd	r30, Y+18	; 0x12
    3f66:	fb 89       	ldd	r31, Y+19	; 0x13
    3f68:	15 86       	std	Z+13, r1	; 0x0d
    3f6a:	14 86       	std	Z+12, r1	; 0x0c
    3f6c:	ed 81       	ldd	r30, Y+5	; 0x05
    3f6e:	fe 81       	ldd	r31, Y+6	; 0x06
    3f70:	80 81       	ld	r24, Z
    3f72:	81 50       	subi	r24, 0x01	; 1
    3f74:	ed 81       	ldd	r30, Y+5	; 0x05
    3f76:	fe 81       	ldd	r31, Y+6	; 0x06
    3f78:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3f7a:	ea 89       	ldd	r30, Y+18	; 0x12
    3f7c:	fb 89       	ldd	r31, Y+19	; 0x13
    3f7e:	80 8d       	ldd	r24, Z+24	; 0x18
    3f80:	91 8d       	ldd	r25, Z+25	; 0x19
    3f82:	00 97       	sbiw	r24, 0x00	; 0
    3f84:	d9 f1       	breq	.+118    	; 0x3ffc <xTaskIncrementTick+0x250>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3f86:	ea 89       	ldd	r30, Y+18	; 0x12
    3f88:	fb 89       	ldd	r31, Y+19	; 0x13
    3f8a:	80 8d       	ldd	r24, Z+24	; 0x18
    3f8c:	91 8d       	ldd	r25, Z+25	; 0x19
    3f8e:	9c 83       	std	Y+4, r25	; 0x04
    3f90:	8b 83       	std	Y+3, r24	; 0x03
    3f92:	ea 89       	ldd	r30, Y+18	; 0x12
    3f94:	fb 89       	ldd	r31, Y+19	; 0x13
    3f96:	a2 89       	ldd	r26, Z+18	; 0x12
    3f98:	b3 89       	ldd	r27, Z+19	; 0x13
    3f9a:	ea 89       	ldd	r30, Y+18	; 0x12
    3f9c:	fb 89       	ldd	r31, Y+19	; 0x13
    3f9e:	84 89       	ldd	r24, Z+20	; 0x14
    3fa0:	95 89       	ldd	r25, Z+21	; 0x15
    3fa2:	17 96       	adiw	r26, 0x07	; 7
    3fa4:	9c 93       	st	X, r25
    3fa6:	8e 93       	st	-X, r24
    3fa8:	16 97       	sbiw	r26, 0x06	; 6
    3faa:	ea 89       	ldd	r30, Y+18	; 0x12
    3fac:	fb 89       	ldd	r31, Y+19	; 0x13
    3fae:	a4 89       	ldd	r26, Z+20	; 0x14
    3fb0:	b5 89       	ldd	r27, Z+21	; 0x15
    3fb2:	ea 89       	ldd	r30, Y+18	; 0x12
    3fb4:	fb 89       	ldd	r31, Y+19	; 0x13
    3fb6:	82 89       	ldd	r24, Z+18	; 0x12
    3fb8:	93 89       	ldd	r25, Z+19	; 0x13
    3fba:	15 96       	adiw	r26, 0x05	; 5
    3fbc:	9c 93       	st	X, r25
    3fbe:	8e 93       	st	-X, r24
    3fc0:	14 97       	sbiw	r26, 0x04	; 4
    3fc2:	eb 81       	ldd	r30, Y+3	; 0x03
    3fc4:	fc 81       	ldd	r31, Y+4	; 0x04
    3fc6:	21 81       	ldd	r18, Z+1	; 0x01
    3fc8:	32 81       	ldd	r19, Z+2	; 0x02
    3fca:	8a 89       	ldd	r24, Y+18	; 0x12
    3fcc:	9b 89       	ldd	r25, Y+19	; 0x13
    3fce:	0e 96       	adiw	r24, 0x0e	; 14
    3fd0:	28 17       	cp	r18, r24
    3fd2:	39 07       	cpc	r19, r25
    3fd4:	41 f4       	brne	.+16     	; 0x3fe6 <xTaskIncrementTick+0x23a>
    3fd6:	ea 89       	ldd	r30, Y+18	; 0x12
    3fd8:	fb 89       	ldd	r31, Y+19	; 0x13
    3fda:	84 89       	ldd	r24, Z+20	; 0x14
    3fdc:	95 89       	ldd	r25, Z+21	; 0x15
    3fde:	eb 81       	ldd	r30, Y+3	; 0x03
    3fe0:	fc 81       	ldd	r31, Y+4	; 0x04
    3fe2:	92 83       	std	Z+2, r25	; 0x02
    3fe4:	81 83       	std	Z+1, r24	; 0x01
    3fe6:	ea 89       	ldd	r30, Y+18	; 0x12
    3fe8:	fb 89       	ldd	r31, Y+19	; 0x13
    3fea:	11 8e       	std	Z+25, r1	; 0x19
    3fec:	10 8e       	std	Z+24, r1	; 0x18
    3fee:	eb 81       	ldd	r30, Y+3	; 0x03
    3ff0:	fc 81       	ldd	r31, Y+4	; 0x04
    3ff2:	80 81       	ld	r24, Z
    3ff4:	81 50       	subi	r24, 0x01	; 1
    3ff6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ff8:	fc 81       	ldd	r31, Y+4	; 0x04
    3ffa:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    3ffc:	ea 89       	ldd	r30, Y+18	; 0x12
    3ffe:	fb 89       	ldd	r31, Y+19	; 0x13
    4000:	92 8d       	ldd	r25, Z+26	; 0x1a
    4002:	80 91 39 15 	lds	r24, 0x1539
    4006:	89 17       	cp	r24, r25
    4008:	28 f4       	brcc	.+10     	; 0x4014 <xTaskIncrementTick+0x268>
    400a:	ea 89       	ldd	r30, Y+18	; 0x12
    400c:	fb 89       	ldd	r31, Y+19	; 0x13
    400e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4010:	80 93 39 15 	sts	0x1539, r24
    4014:	ea 89       	ldd	r30, Y+18	; 0x12
    4016:	fb 89       	ldd	r31, Y+19	; 0x13
    4018:	82 8d       	ldd	r24, Z+26	; 0x1a
    401a:	48 2f       	mov	r20, r24
    401c:	50 e0       	ldi	r21, 0x00	; 0
    401e:	ca 01       	movw	r24, r20
    4020:	88 0f       	add	r24, r24
    4022:	99 1f       	adc	r25, r25
    4024:	9c 01       	movw	r18, r24
    4026:	22 0f       	add	r18, r18
    4028:	33 1f       	adc	r19, r19
    402a:	22 0f       	add	r18, r18
    402c:	33 1f       	adc	r19, r19
    402e:	82 0f       	add	r24, r18
    4030:	93 1f       	adc	r25, r19
    4032:	84 0f       	add	r24, r20
    4034:	95 1f       	adc	r25, r21
    4036:	fc 01       	movw	r30, r24
    4038:	e7 5b       	subi	r30, 0xB7	; 183
    403a:	fa 4e       	sbci	r31, 0xEA	; 234
    403c:	81 81       	ldd	r24, Z+1	; 0x01
    403e:	92 81       	ldd	r25, Z+2	; 0x02
    4040:	9a 83       	std	Y+2, r25	; 0x02
    4042:	89 83       	std	Y+1, r24	; 0x01
    4044:	ea 89       	ldd	r30, Y+18	; 0x12
    4046:	fb 89       	ldd	r31, Y+19	; 0x13
    4048:	89 81       	ldd	r24, Y+1	; 0x01
    404a:	9a 81       	ldd	r25, Y+2	; 0x02
    404c:	97 83       	std	Z+7, r25	; 0x07
    404e:	86 83       	std	Z+6, r24	; 0x06
    4050:	e9 81       	ldd	r30, Y+1	; 0x01
    4052:	fa 81       	ldd	r31, Y+2	; 0x02
    4054:	86 81       	ldd	r24, Z+6	; 0x06
    4056:	97 81       	ldd	r25, Z+7	; 0x07
    4058:	ea 89       	ldd	r30, Y+18	; 0x12
    405a:	fb 89       	ldd	r31, Y+19	; 0x13
    405c:	91 87       	std	Z+9, r25	; 0x09
    405e:	80 87       	std	Z+8, r24	; 0x08
    4060:	e9 81       	ldd	r30, Y+1	; 0x01
    4062:	fa 81       	ldd	r31, Y+2	; 0x02
    4064:	06 80       	ldd	r0, Z+6	; 0x06
    4066:	f7 81       	ldd	r31, Z+7	; 0x07
    4068:	e0 2d       	mov	r30, r0
    406a:	8a 89       	ldd	r24, Y+18	; 0x12
    406c:	9b 89       	ldd	r25, Y+19	; 0x13
    406e:	02 96       	adiw	r24, 0x02	; 2
    4070:	95 83       	std	Z+5, r25	; 0x05
    4072:	84 83       	std	Z+4, r24	; 0x04
    4074:	8a 89       	ldd	r24, Y+18	; 0x12
    4076:	9b 89       	ldd	r25, Y+19	; 0x13
    4078:	02 96       	adiw	r24, 0x02	; 2
    407a:	e9 81       	ldd	r30, Y+1	; 0x01
    407c:	fa 81       	ldd	r31, Y+2	; 0x02
    407e:	97 83       	std	Z+7, r25	; 0x07
    4080:	86 83       	std	Z+6, r24	; 0x06
    4082:	ea 89       	ldd	r30, Y+18	; 0x12
    4084:	fb 89       	ldd	r31, Y+19	; 0x13
    4086:	82 8d       	ldd	r24, Z+26	; 0x1a
    4088:	48 2f       	mov	r20, r24
    408a:	50 e0       	ldi	r21, 0x00	; 0
    408c:	ca 01       	movw	r24, r20
    408e:	88 0f       	add	r24, r24
    4090:	99 1f       	adc	r25, r25
    4092:	9c 01       	movw	r18, r24
    4094:	22 0f       	add	r18, r18
    4096:	33 1f       	adc	r19, r19
    4098:	22 0f       	add	r18, r18
    409a:	33 1f       	adc	r19, r19
    409c:	82 0f       	add	r24, r18
    409e:	93 1f       	adc	r25, r19
    40a0:	84 0f       	add	r24, r20
    40a2:	95 1f       	adc	r25, r21
    40a4:	87 5b       	subi	r24, 0xB7	; 183
    40a6:	9a 4e       	sbci	r25, 0xEA	; 234
    40a8:	ea 89       	ldd	r30, Y+18	; 0x12
    40aa:	fb 89       	ldd	r31, Y+19	; 0x13
    40ac:	95 87       	std	Z+13, r25	; 0x0d
    40ae:	84 87       	std	Z+12, r24	; 0x0c
    40b0:	ea 89       	ldd	r30, Y+18	; 0x12
    40b2:	fb 89       	ldd	r31, Y+19	; 0x13
    40b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    40b6:	48 2f       	mov	r20, r24
    40b8:	50 e0       	ldi	r21, 0x00	; 0
    40ba:	ca 01       	movw	r24, r20
    40bc:	88 0f       	add	r24, r24
    40be:	99 1f       	adc	r25, r25
    40c0:	9c 01       	movw	r18, r24
    40c2:	22 0f       	add	r18, r18
    40c4:	33 1f       	adc	r19, r19
    40c6:	22 0f       	add	r18, r18
    40c8:	33 1f       	adc	r19, r19
    40ca:	82 0f       	add	r24, r18
    40cc:	93 1f       	adc	r25, r19
    40ce:	84 0f       	add	r24, r20
    40d0:	95 1f       	adc	r25, r21
    40d2:	fc 01       	movw	r30, r24
    40d4:	e7 5b       	subi	r30, 0xB7	; 183
    40d6:	fa 4e       	sbci	r31, 0xEA	; 234
    40d8:	80 81       	ld	r24, Z
    40da:	8f 5f       	subi	r24, 0xFF	; 255
    40dc:	80 83       	st	Z, r24
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    40de:	ea 89       	ldd	r30, Y+18	; 0x12
    40e0:	fb 89       	ldd	r31, Y+19	; 0x13
    40e2:	92 8d       	ldd	r25, Z+26	; 0x1a
    40e4:	e0 91 32 15 	lds	r30, 0x1532
    40e8:	f0 91 33 15 	lds	r31, 0x1533
    40ec:	82 8d       	ldd	r24, Z+26	; 0x1a
    40ee:	89 17       	cp	r24, r25
    40f0:	08 f0       	brcs	.+2      	; 0x40f4 <xTaskIncrementTick+0x348>
    40f2:	c5 ce       	rjmp	.-630    	; 0x3e7e <xTaskIncrementTick+0xd2>
                        {
                            xSwitchRequired = pdTRUE;
    40f4:	81 e0       	ldi	r24, 0x01	; 1
    40f6:	8d 87       	std	Y+13, r24	; 0x0d
    40f8:	c2 ce       	rjmp	.-636    	; 0x3e7e <xTaskIncrementTick+0xd2>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    40fa:	e0 91 32 15 	lds	r30, 0x1532
    40fe:	f0 91 33 15 	lds	r31, 0x1533
    4102:	82 8d       	ldd	r24, Z+26	; 0x1a
    4104:	48 2f       	mov	r20, r24
    4106:	50 e0       	ldi	r21, 0x00	; 0
    4108:	ca 01       	movw	r24, r20
    410a:	88 0f       	add	r24, r24
    410c:	99 1f       	adc	r25, r25
    410e:	9c 01       	movw	r18, r24
    4110:	22 0f       	add	r18, r18
    4112:	33 1f       	adc	r19, r19
    4114:	22 0f       	add	r18, r18
    4116:	33 1f       	adc	r19, r19
    4118:	82 0f       	add	r24, r18
    411a:	93 1f       	adc	r25, r19
    411c:	84 0f       	add	r24, r20
    411e:	95 1f       	adc	r25, r21
    4120:	fc 01       	movw	r30, r24
    4122:	e7 5b       	subi	r30, 0xB7	; 183
    4124:	fa 4e       	sbci	r31, 0xEA	; 234
    4126:	80 81       	ld	r24, Z
    4128:	82 30       	cpi	r24, 0x02	; 2
    412a:	10 f0       	brcs	.+4      	; 0x4130 <xTaskIncrementTick+0x384>
            {
                xSwitchRequired = pdTRUE;
    412c:	81 e0       	ldi	r24, 0x01	; 1
    412e:	8d 87       	std	Y+13, r24	; 0x0d
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
    4130:	80 91 3f 15 	lds	r24, 0x153F
    4134:	88 23       	and	r24, r24
    4136:	b1 f0       	breq	.+44     	; 0x4164 <xTaskIncrementTick+0x3b8>
            {
                xSwitchRequired = pdTRUE;
    4138:	81 e0       	ldi	r24, 0x01	; 1
    413a:	8d 87       	std	Y+13, r24	; 0x0d
    413c:	13 c0       	rjmp	.+38     	; 0x4164 <xTaskIncrementTick+0x3b8>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    413e:	80 91 3b 15 	lds	r24, 0x153B
    4142:	90 91 3c 15 	lds	r25, 0x153C
    4146:	a0 91 3d 15 	lds	r26, 0x153D
    414a:	b0 91 3e 15 	lds	r27, 0x153E
    414e:	01 96       	adiw	r24, 0x01	; 1
    4150:	a1 1d       	adc	r26, r1
    4152:	b1 1d       	adc	r27, r1
    4154:	80 93 3b 15 	sts	0x153B, r24
    4158:	90 93 3c 15 	sts	0x153C, r25
    415c:	a0 93 3d 15 	sts	0x153D, r26
    4160:	b0 93 3e 15 	sts	0x153E, r27
            vApplicationTickHook();
        }
        #endif
    }

    return xSwitchRequired;
    4164:	8d 85       	ldd	r24, Y+13	; 0x0d
}
    4166:	63 96       	adiw	r28, 0x13	; 19
    4168:	0f b6       	in	r0, 0x3f	; 63
    416a:	f8 94       	cli
    416c:	de bf       	out	0x3e, r29	; 62
    416e:	0f be       	out	0x3f, r0	; 63
    4170:	cd bf       	out	0x3d, r28	; 61
    4172:	cf 91       	pop	r28
    4174:	df 91       	pop	r29
    4176:	08 95       	ret

00004178 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4178:	df 93       	push	r29
    417a:	cf 93       	push	r28
    417c:	00 d0       	rcall	.+0      	; 0x417e <vTaskSwitchContext+0x6>
    417e:	0f 92       	push	r0
    4180:	cd b7       	in	r28, 0x3d	; 61
    4182:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4184:	80 91 48 15 	lds	r24, 0x1548
    4188:	88 23       	and	r24, r24
    418a:	21 f0       	breq	.+8      	; 0x4194 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    418c:	81 e0       	ldi	r24, 0x01	; 1
    418e:	80 93 3f 15 	sts	0x153F, r24
    4192:	64 c0       	rjmp	.+200    	; 0x425c <vTaskSwitchContext+0xe4>
    }
    else
    {
        xYieldPending = pdFALSE;
    4194:	10 92 3f 15 	sts	0x153F, r1
        }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4198:	80 91 39 15 	lds	r24, 0x1539
    419c:	8b 83       	std	Y+3, r24	; 0x03
    419e:	08 c0       	rjmp	.+16     	; 0x41b0 <vTaskSwitchContext+0x38>
    41a0:	8b 81       	ldd	r24, Y+3	; 0x03
    41a2:	88 23       	and	r24, r24
    41a4:	11 f4       	brne	.+4      	; 0x41aa <vTaskSwitchContext+0x32>
    41a6:	f8 94       	cli
    41a8:	ff cf       	rjmp	.-2      	; 0x41a8 <vTaskSwitchContext+0x30>
    41aa:	8b 81       	ldd	r24, Y+3	; 0x03
    41ac:	81 50       	subi	r24, 0x01	; 1
    41ae:	8b 83       	std	Y+3, r24	; 0x03
    41b0:	8b 81       	ldd	r24, Y+3	; 0x03
    41b2:	48 2f       	mov	r20, r24
    41b4:	50 e0       	ldi	r21, 0x00	; 0
    41b6:	ca 01       	movw	r24, r20
    41b8:	88 0f       	add	r24, r24
    41ba:	99 1f       	adc	r25, r25
    41bc:	9c 01       	movw	r18, r24
    41be:	22 0f       	add	r18, r18
    41c0:	33 1f       	adc	r19, r19
    41c2:	22 0f       	add	r18, r18
    41c4:	33 1f       	adc	r19, r19
    41c6:	82 0f       	add	r24, r18
    41c8:	93 1f       	adc	r25, r19
    41ca:	84 0f       	add	r24, r20
    41cc:	95 1f       	adc	r25, r21
    41ce:	fc 01       	movw	r30, r24
    41d0:	e7 5b       	subi	r30, 0xB7	; 183
    41d2:	fa 4e       	sbci	r31, 0xEA	; 234
    41d4:	80 81       	ld	r24, Z
    41d6:	88 23       	and	r24, r24
    41d8:	19 f3       	breq	.-58     	; 0x41a0 <vTaskSwitchContext+0x28>
    41da:	8b 81       	ldd	r24, Y+3	; 0x03
    41dc:	48 2f       	mov	r20, r24
    41de:	50 e0       	ldi	r21, 0x00	; 0
    41e0:	ca 01       	movw	r24, r20
    41e2:	88 0f       	add	r24, r24
    41e4:	99 1f       	adc	r25, r25
    41e6:	9c 01       	movw	r18, r24
    41e8:	22 0f       	add	r18, r18
    41ea:	33 1f       	adc	r19, r19
    41ec:	22 0f       	add	r18, r18
    41ee:	33 1f       	adc	r19, r19
    41f0:	82 0f       	add	r24, r18
    41f2:	93 1f       	adc	r25, r19
    41f4:	84 0f       	add	r24, r20
    41f6:	95 1f       	adc	r25, r21
    41f8:	87 5b       	subi	r24, 0xB7	; 183
    41fa:	9a 4e       	sbci	r25, 0xEA	; 234
    41fc:	9a 83       	std	Y+2, r25	; 0x02
    41fe:	89 83       	std	Y+1, r24	; 0x01
    4200:	e9 81       	ldd	r30, Y+1	; 0x01
    4202:	fa 81       	ldd	r31, Y+2	; 0x02
    4204:	01 80       	ldd	r0, Z+1	; 0x01
    4206:	f2 81       	ldd	r31, Z+2	; 0x02
    4208:	e0 2d       	mov	r30, r0
    420a:	84 81       	ldd	r24, Z+4	; 0x04
    420c:	95 81       	ldd	r25, Z+5	; 0x05
    420e:	e9 81       	ldd	r30, Y+1	; 0x01
    4210:	fa 81       	ldd	r31, Y+2	; 0x02
    4212:	92 83       	std	Z+2, r25	; 0x02
    4214:	81 83       	std	Z+1, r24	; 0x01
    4216:	e9 81       	ldd	r30, Y+1	; 0x01
    4218:	fa 81       	ldd	r31, Y+2	; 0x02
    421a:	21 81       	ldd	r18, Z+1	; 0x01
    421c:	32 81       	ldd	r19, Z+2	; 0x02
    421e:	89 81       	ldd	r24, Y+1	; 0x01
    4220:	9a 81       	ldd	r25, Y+2	; 0x02
    4222:	03 96       	adiw	r24, 0x03	; 3
    4224:	28 17       	cp	r18, r24
    4226:	39 07       	cpc	r19, r25
    4228:	59 f4       	brne	.+22     	; 0x4240 <vTaskSwitchContext+0xc8>
    422a:	e9 81       	ldd	r30, Y+1	; 0x01
    422c:	fa 81       	ldd	r31, Y+2	; 0x02
    422e:	01 80       	ldd	r0, Z+1	; 0x01
    4230:	f2 81       	ldd	r31, Z+2	; 0x02
    4232:	e0 2d       	mov	r30, r0
    4234:	84 81       	ldd	r24, Z+4	; 0x04
    4236:	95 81       	ldd	r25, Z+5	; 0x05
    4238:	e9 81       	ldd	r30, Y+1	; 0x01
    423a:	fa 81       	ldd	r31, Y+2	; 0x02
    423c:	92 83       	std	Z+2, r25	; 0x02
    423e:	81 83       	std	Z+1, r24	; 0x01
    4240:	e9 81       	ldd	r30, Y+1	; 0x01
    4242:	fa 81       	ldd	r31, Y+2	; 0x02
    4244:	01 80       	ldd	r0, Z+1	; 0x01
    4246:	f2 81       	ldd	r31, Z+2	; 0x02
    4248:	e0 2d       	mov	r30, r0
    424a:	80 85       	ldd	r24, Z+8	; 0x08
    424c:	91 85       	ldd	r25, Z+9	; 0x09
    424e:	90 93 33 15 	sts	0x1533, r25
    4252:	80 93 32 15 	sts	0x1532, r24
    4256:	8b 81       	ldd	r24, Y+3	; 0x03
    4258:	80 93 39 15 	sts	0x1539, r24
             * Block specific to this task. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif
    }
}
    425c:	0f 90       	pop	r0
    425e:	0f 90       	pop	r0
    4260:	0f 90       	pop	r0
    4262:	cf 91       	pop	r28
    4264:	df 91       	pop	r29
    4266:	08 95       	ret

00004268 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    4268:	df 93       	push	r29
    426a:	cf 93       	push	r28
    426c:	00 d0       	rcall	.+0      	; 0x426e <vTaskPlaceOnEventList+0x6>
    426e:	00 d0       	rcall	.+0      	; 0x4270 <vTaskPlaceOnEventList+0x8>
    4270:	00 d0       	rcall	.+0      	; 0x4272 <vTaskPlaceOnEventList+0xa>
    4272:	cd b7       	in	r28, 0x3d	; 61
    4274:	de b7       	in	r29, 0x3e	; 62
    4276:	9a 83       	std	Y+2, r25	; 0x02
    4278:	89 83       	std	Y+1, r24	; 0x01
    427a:	4b 83       	std	Y+3, r20	; 0x03
    427c:	5c 83       	std	Y+4, r21	; 0x04
    427e:	6d 83       	std	Y+5, r22	; 0x05
    4280:	7e 83       	std	Y+6, r23	; 0x06
    configASSERT( pxEventList );
    4282:	89 81       	ldd	r24, Y+1	; 0x01
    4284:	9a 81       	ldd	r25, Y+2	; 0x02
    4286:	00 97       	sbiw	r24, 0x00	; 0
    4288:	11 f4       	brne	.+4      	; 0x428e <vTaskPlaceOnEventList+0x26>
    428a:	f8 94       	cli
    428c:	ff cf       	rjmp	.-2      	; 0x428c <vTaskPlaceOnEventList+0x24>
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    428e:	80 91 32 15 	lds	r24, 0x1532
    4292:	90 91 33 15 	lds	r25, 0x1533
    4296:	9c 01       	movw	r18, r24
    4298:	22 5f       	subi	r18, 0xF2	; 242
    429a:	3f 4f       	sbci	r19, 0xFF	; 255
    429c:	89 81       	ldd	r24, Y+1	; 0x01
    429e:	9a 81       	ldd	r25, Y+2	; 0x02
    42a0:	b9 01       	movw	r22, r18
    42a2:	0e 94 50 10 	call	0x20a0	; 0x20a0 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    42a6:	8b 81       	ldd	r24, Y+3	; 0x03
    42a8:	9c 81       	ldd	r25, Y+4	; 0x04
    42aa:	ad 81       	ldd	r26, Y+5	; 0x05
    42ac:	be 81       	ldd	r27, Y+6	; 0x06
    42ae:	bc 01       	movw	r22, r24
    42b0:	cd 01       	movw	r24, r26
    42b2:	41 e0       	ldi	r20, 0x01	; 1
    42b4:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <prvAddCurrentTaskToDelayedList>
}
    42b8:	26 96       	adiw	r28, 0x06	; 6
    42ba:	0f b6       	in	r0, 0x3f	; 63
    42bc:	f8 94       	cli
    42be:	de bf       	out	0x3e, r29	; 62
    42c0:	0f be       	out	0x3f, r0	; 63
    42c2:	cd bf       	out	0x3d, r28	; 61
    42c4:	cf 91       	pop	r28
    42c6:	df 91       	pop	r29
    42c8:	08 95       	ret

000042ca <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    42ca:	0f 93       	push	r16
    42cc:	1f 93       	push	r17
    42ce:	df 93       	push	r29
    42d0:	cf 93       	push	r28
    42d2:	cd b7       	in	r28, 0x3d	; 61
    42d4:	de b7       	in	r29, 0x3e	; 62
    42d6:	2c 97       	sbiw	r28, 0x0c	; 12
    42d8:	0f b6       	in	r0, 0x3f	; 63
    42da:	f8 94       	cli
    42dc:	de bf       	out	0x3e, r29	; 62
    42de:	0f be       	out	0x3f, r0	; 63
    42e0:	cd bf       	out	0x3d, r28	; 61
    42e2:	9c 83       	std	Y+4, r25	; 0x04
    42e4:	8b 83       	std	Y+3, r24	; 0x03
    42e6:	4d 83       	std	Y+5, r20	; 0x05
    42e8:	5e 83       	std	Y+6, r21	; 0x06
    42ea:	6f 83       	std	Y+7, r22	; 0x07
    42ec:	78 87       	std	Y+8, r23	; 0x08
    42ee:	09 87       	std	Y+9, r16	; 0x09
    42f0:	1a 87       	std	Y+10, r17	; 0x0a
    42f2:	2b 87       	std	Y+11, r18	; 0x0b
    42f4:	3c 87       	std	Y+12, r19	; 0x0c
    configASSERT( pxEventList );
    42f6:	8b 81       	ldd	r24, Y+3	; 0x03
    42f8:	9c 81       	ldd	r25, Y+4	; 0x04
    42fa:	00 97       	sbiw	r24, 0x00	; 0
    42fc:	11 f4       	brne	.+4      	; 0x4302 <vTaskPlaceOnUnorderedEventList+0x38>
    42fe:	f8 94       	cli
    4300:	ff cf       	rjmp	.-2      	; 0x4300 <vTaskPlaceOnUnorderedEventList+0x36>

    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event groups implementation. */
    configASSERT( uxSchedulerSuspended != 0 );
    4302:	80 91 48 15 	lds	r24, 0x1548
    4306:	88 23       	and	r24, r24
    4308:	11 f4       	brne	.+4      	; 0x430e <vTaskPlaceOnUnorderedEventList+0x44>
    430a:	f8 94       	cli
    430c:	ff cf       	rjmp	.-2      	; 0x430c <vTaskPlaceOnUnorderedEventList+0x42>

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    430e:	e0 91 32 15 	lds	r30, 0x1532
    4312:	f0 91 33 15 	lds	r31, 0x1533
    4316:	8d 81       	ldd	r24, Y+5	; 0x05
    4318:	9e 81       	ldd	r25, Y+6	; 0x06
    431a:	af 81       	ldd	r26, Y+7	; 0x07
    431c:	b8 85       	ldd	r27, Y+8	; 0x08
    431e:	b0 68       	ori	r27, 0x80	; 128
    4320:	86 87       	std	Z+14, r24	; 0x0e
    4322:	97 87       	std	Z+15, r25	; 0x0f
    4324:	a0 8b       	std	Z+16, r26	; 0x10
    4326:	b1 8b       	std	Z+17, r27	; 0x11
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4328:	eb 81       	ldd	r30, Y+3	; 0x03
    432a:	fc 81       	ldd	r31, Y+4	; 0x04
    432c:	81 81       	ldd	r24, Z+1	; 0x01
    432e:	92 81       	ldd	r25, Z+2	; 0x02
    4330:	9a 83       	std	Y+2, r25	; 0x02
    4332:	89 83       	std	Y+1, r24	; 0x01
    4334:	e0 91 32 15 	lds	r30, 0x1532
    4338:	f0 91 33 15 	lds	r31, 0x1533
    433c:	89 81       	ldd	r24, Y+1	; 0x01
    433e:	9a 81       	ldd	r25, Y+2	; 0x02
    4340:	93 8b       	std	Z+19, r25	; 0x13
    4342:	82 8b       	std	Z+18, r24	; 0x12
    4344:	a0 91 32 15 	lds	r26, 0x1532
    4348:	b0 91 33 15 	lds	r27, 0x1533
    434c:	e9 81       	ldd	r30, Y+1	; 0x01
    434e:	fa 81       	ldd	r31, Y+2	; 0x02
    4350:	86 81       	ldd	r24, Z+6	; 0x06
    4352:	97 81       	ldd	r25, Z+7	; 0x07
    4354:	55 96       	adiw	r26, 0x15	; 21
    4356:	9c 93       	st	X, r25
    4358:	8e 93       	st	-X, r24
    435a:	54 97       	sbiw	r26, 0x14	; 20
    435c:	e9 81       	ldd	r30, Y+1	; 0x01
    435e:	fa 81       	ldd	r31, Y+2	; 0x02
    4360:	06 80       	ldd	r0, Z+6	; 0x06
    4362:	f7 81       	ldd	r31, Z+7	; 0x07
    4364:	e0 2d       	mov	r30, r0
    4366:	80 91 32 15 	lds	r24, 0x1532
    436a:	90 91 33 15 	lds	r25, 0x1533
    436e:	0e 96       	adiw	r24, 0x0e	; 14
    4370:	95 83       	std	Z+5, r25	; 0x05
    4372:	84 83       	std	Z+4, r24	; 0x04
    4374:	80 91 32 15 	lds	r24, 0x1532
    4378:	90 91 33 15 	lds	r25, 0x1533
    437c:	0e 96       	adiw	r24, 0x0e	; 14
    437e:	e9 81       	ldd	r30, Y+1	; 0x01
    4380:	fa 81       	ldd	r31, Y+2	; 0x02
    4382:	97 83       	std	Z+7, r25	; 0x07
    4384:	86 83       	std	Z+6, r24	; 0x06
    4386:	e0 91 32 15 	lds	r30, 0x1532
    438a:	f0 91 33 15 	lds	r31, 0x1533
    438e:	8b 81       	ldd	r24, Y+3	; 0x03
    4390:	9c 81       	ldd	r25, Y+4	; 0x04
    4392:	91 8f       	std	Z+25, r25	; 0x19
    4394:	80 8f       	std	Z+24, r24	; 0x18
    4396:	eb 81       	ldd	r30, Y+3	; 0x03
    4398:	fc 81       	ldd	r31, Y+4	; 0x04
    439a:	80 81       	ld	r24, Z
    439c:	8f 5f       	subi	r24, 0xFF	; 255
    439e:	eb 81       	ldd	r30, Y+3	; 0x03
    43a0:	fc 81       	ldd	r31, Y+4	; 0x04
    43a2:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    43a4:	89 85       	ldd	r24, Y+9	; 0x09
    43a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    43a8:	ab 85       	ldd	r26, Y+11	; 0x0b
    43aa:	bc 85       	ldd	r27, Y+12	; 0x0c
    43ac:	bc 01       	movw	r22, r24
    43ae:	cd 01       	movw	r24, r26
    43b0:	41 e0       	ldi	r20, 0x01	; 1
    43b2:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <prvAddCurrentTaskToDelayedList>
}
    43b6:	2c 96       	adiw	r28, 0x0c	; 12
    43b8:	0f b6       	in	r0, 0x3f	; 63
    43ba:	f8 94       	cli
    43bc:	de bf       	out	0x3e, r29	; 62
    43be:	0f be       	out	0x3f, r0	; 63
    43c0:	cd bf       	out	0x3d, r28	; 61
    43c2:	cf 91       	pop	r28
    43c4:	df 91       	pop	r29
    43c6:	1f 91       	pop	r17
    43c8:	0f 91       	pop	r16
    43ca:	08 95       	ret

000043cc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    43cc:	df 93       	push	r29
    43ce:	cf 93       	push	r28
    43d0:	cd b7       	in	r28, 0x3d	; 61
    43d2:	de b7       	in	r29, 0x3e	; 62
    43d4:	2d 97       	sbiw	r28, 0x0d	; 13
    43d6:	0f b6       	in	r0, 0x3f	; 63
    43d8:	f8 94       	cli
    43da:	de bf       	out	0x3e, r29	; 62
    43dc:	0f be       	out	0x3f, r0	; 63
    43de:	cd bf       	out	0x3d, r28	; 61
    43e0:	9d 87       	std	Y+13, r25	; 0x0d
    43e2:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    43e4:	ec 85       	ldd	r30, Y+12	; 0x0c
    43e6:	fd 85       	ldd	r31, Y+13	; 0x0d
    43e8:	07 80       	ldd	r0, Z+7	; 0x07
    43ea:	f0 85       	ldd	r31, Z+8	; 0x08
    43ec:	e0 2d       	mov	r30, r0
    43ee:	80 85       	ldd	r24, Z+8	; 0x08
    43f0:	91 85       	ldd	r25, Z+9	; 0x09
    43f2:	9b 87       	std	Y+11, r25	; 0x0b
    43f4:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    43f6:	8a 85       	ldd	r24, Y+10	; 0x0a
    43f8:	9b 85       	ldd	r25, Y+11	; 0x0b
    43fa:	00 97       	sbiw	r24, 0x00	; 0
    43fc:	11 f4       	brne	.+4      	; 0x4402 <xTaskRemoveFromEventList+0x36>
    43fe:	f8 94       	cli
    4400:	ff cf       	rjmp	.-2      	; 0x4400 <xTaskRemoveFromEventList+0x34>
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    4402:	ea 85       	ldd	r30, Y+10	; 0x0a
    4404:	fb 85       	ldd	r31, Y+11	; 0x0b
    4406:	80 8d       	ldd	r24, Z+24	; 0x18
    4408:	91 8d       	ldd	r25, Z+25	; 0x19
    440a:	98 87       	std	Y+8, r25	; 0x08
    440c:	8f 83       	std	Y+7, r24	; 0x07
    440e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4410:	fb 85       	ldd	r31, Y+11	; 0x0b
    4412:	a2 89       	ldd	r26, Z+18	; 0x12
    4414:	b3 89       	ldd	r27, Z+19	; 0x13
    4416:	ea 85       	ldd	r30, Y+10	; 0x0a
    4418:	fb 85       	ldd	r31, Y+11	; 0x0b
    441a:	84 89       	ldd	r24, Z+20	; 0x14
    441c:	95 89       	ldd	r25, Z+21	; 0x15
    441e:	17 96       	adiw	r26, 0x07	; 7
    4420:	9c 93       	st	X, r25
    4422:	8e 93       	st	-X, r24
    4424:	16 97       	sbiw	r26, 0x06	; 6
    4426:	ea 85       	ldd	r30, Y+10	; 0x0a
    4428:	fb 85       	ldd	r31, Y+11	; 0x0b
    442a:	a4 89       	ldd	r26, Z+20	; 0x14
    442c:	b5 89       	ldd	r27, Z+21	; 0x15
    442e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4430:	fb 85       	ldd	r31, Y+11	; 0x0b
    4432:	82 89       	ldd	r24, Z+18	; 0x12
    4434:	93 89       	ldd	r25, Z+19	; 0x13
    4436:	15 96       	adiw	r26, 0x05	; 5
    4438:	9c 93       	st	X, r25
    443a:	8e 93       	st	-X, r24
    443c:	14 97       	sbiw	r26, 0x04	; 4
    443e:	ef 81       	ldd	r30, Y+7	; 0x07
    4440:	f8 85       	ldd	r31, Y+8	; 0x08
    4442:	21 81       	ldd	r18, Z+1	; 0x01
    4444:	32 81       	ldd	r19, Z+2	; 0x02
    4446:	8a 85       	ldd	r24, Y+10	; 0x0a
    4448:	9b 85       	ldd	r25, Y+11	; 0x0b
    444a:	0e 96       	adiw	r24, 0x0e	; 14
    444c:	28 17       	cp	r18, r24
    444e:	39 07       	cpc	r19, r25
    4450:	41 f4       	brne	.+16     	; 0x4462 <xTaskRemoveFromEventList+0x96>
    4452:	ea 85       	ldd	r30, Y+10	; 0x0a
    4454:	fb 85       	ldd	r31, Y+11	; 0x0b
    4456:	84 89       	ldd	r24, Z+20	; 0x14
    4458:	95 89       	ldd	r25, Z+21	; 0x15
    445a:	ef 81       	ldd	r30, Y+7	; 0x07
    445c:	f8 85       	ldd	r31, Y+8	; 0x08
    445e:	92 83       	std	Z+2, r25	; 0x02
    4460:	81 83       	std	Z+1, r24	; 0x01
    4462:	ea 85       	ldd	r30, Y+10	; 0x0a
    4464:	fb 85       	ldd	r31, Y+11	; 0x0b
    4466:	11 8e       	std	Z+25, r1	; 0x19
    4468:	10 8e       	std	Z+24, r1	; 0x18
    446a:	ef 81       	ldd	r30, Y+7	; 0x07
    446c:	f8 85       	ldd	r31, Y+8	; 0x08
    446e:	80 81       	ld	r24, Z
    4470:	81 50       	subi	r24, 0x01	; 1
    4472:	ef 81       	ldd	r30, Y+7	; 0x07
    4474:	f8 85       	ldd	r31, Y+8	; 0x08
    4476:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4478:	80 91 48 15 	lds	r24, 0x1548
    447c:	88 23       	and	r24, r24
    447e:	09 f0       	breq	.+2      	; 0x4482 <xTaskRemoveFromEventList+0xb6>
    4480:	ad c0       	rjmp	.+346    	; 0x45dc <xTaskRemoveFromEventList+0x210>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4482:	ea 85       	ldd	r30, Y+10	; 0x0a
    4484:	fb 85       	ldd	r31, Y+11	; 0x0b
    4486:	84 85       	ldd	r24, Z+12	; 0x0c
    4488:	95 85       	ldd	r25, Z+13	; 0x0d
    448a:	9e 83       	std	Y+6, r25	; 0x06
    448c:	8d 83       	std	Y+5, r24	; 0x05
    448e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4490:	fb 85       	ldd	r31, Y+11	; 0x0b
    4492:	a6 81       	ldd	r26, Z+6	; 0x06
    4494:	b7 81       	ldd	r27, Z+7	; 0x07
    4496:	ea 85       	ldd	r30, Y+10	; 0x0a
    4498:	fb 85       	ldd	r31, Y+11	; 0x0b
    449a:	80 85       	ldd	r24, Z+8	; 0x08
    449c:	91 85       	ldd	r25, Z+9	; 0x09
    449e:	17 96       	adiw	r26, 0x07	; 7
    44a0:	9c 93       	st	X, r25
    44a2:	8e 93       	st	-X, r24
    44a4:	16 97       	sbiw	r26, 0x06	; 6
    44a6:	ea 85       	ldd	r30, Y+10	; 0x0a
    44a8:	fb 85       	ldd	r31, Y+11	; 0x0b
    44aa:	a0 85       	ldd	r26, Z+8	; 0x08
    44ac:	b1 85       	ldd	r27, Z+9	; 0x09
    44ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    44b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    44b2:	86 81       	ldd	r24, Z+6	; 0x06
    44b4:	97 81       	ldd	r25, Z+7	; 0x07
    44b6:	15 96       	adiw	r26, 0x05	; 5
    44b8:	9c 93       	st	X, r25
    44ba:	8e 93       	st	-X, r24
    44bc:	14 97       	sbiw	r26, 0x04	; 4
    44be:	ed 81       	ldd	r30, Y+5	; 0x05
    44c0:	fe 81       	ldd	r31, Y+6	; 0x06
    44c2:	21 81       	ldd	r18, Z+1	; 0x01
    44c4:	32 81       	ldd	r19, Z+2	; 0x02
    44c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    44c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    44ca:	02 96       	adiw	r24, 0x02	; 2
    44cc:	28 17       	cp	r18, r24
    44ce:	39 07       	cpc	r19, r25
    44d0:	41 f4       	brne	.+16     	; 0x44e2 <xTaskRemoveFromEventList+0x116>
    44d2:	ea 85       	ldd	r30, Y+10	; 0x0a
    44d4:	fb 85       	ldd	r31, Y+11	; 0x0b
    44d6:	80 85       	ldd	r24, Z+8	; 0x08
    44d8:	91 85       	ldd	r25, Z+9	; 0x09
    44da:	ed 81       	ldd	r30, Y+5	; 0x05
    44dc:	fe 81       	ldd	r31, Y+6	; 0x06
    44de:	92 83       	std	Z+2, r25	; 0x02
    44e0:	81 83       	std	Z+1, r24	; 0x01
    44e2:	ea 85       	ldd	r30, Y+10	; 0x0a
    44e4:	fb 85       	ldd	r31, Y+11	; 0x0b
    44e6:	15 86       	std	Z+13, r1	; 0x0d
    44e8:	14 86       	std	Z+12, r1	; 0x0c
    44ea:	ed 81       	ldd	r30, Y+5	; 0x05
    44ec:	fe 81       	ldd	r31, Y+6	; 0x06
    44ee:	80 81       	ld	r24, Z
    44f0:	81 50       	subi	r24, 0x01	; 1
    44f2:	ed 81       	ldd	r30, Y+5	; 0x05
    44f4:	fe 81       	ldd	r31, Y+6	; 0x06
    44f6:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    44f8:	ea 85       	ldd	r30, Y+10	; 0x0a
    44fa:	fb 85       	ldd	r31, Y+11	; 0x0b
    44fc:	92 8d       	ldd	r25, Z+26	; 0x1a
    44fe:	80 91 39 15 	lds	r24, 0x1539
    4502:	89 17       	cp	r24, r25
    4504:	28 f4       	brcc	.+10     	; 0x4510 <xTaskRemoveFromEventList+0x144>
    4506:	ea 85       	ldd	r30, Y+10	; 0x0a
    4508:	fb 85       	ldd	r31, Y+11	; 0x0b
    450a:	82 8d       	ldd	r24, Z+26	; 0x1a
    450c:	80 93 39 15 	sts	0x1539, r24
    4510:	ea 85       	ldd	r30, Y+10	; 0x0a
    4512:	fb 85       	ldd	r31, Y+11	; 0x0b
    4514:	82 8d       	ldd	r24, Z+26	; 0x1a
    4516:	48 2f       	mov	r20, r24
    4518:	50 e0       	ldi	r21, 0x00	; 0
    451a:	ca 01       	movw	r24, r20
    451c:	88 0f       	add	r24, r24
    451e:	99 1f       	adc	r25, r25
    4520:	9c 01       	movw	r18, r24
    4522:	22 0f       	add	r18, r18
    4524:	33 1f       	adc	r19, r19
    4526:	22 0f       	add	r18, r18
    4528:	33 1f       	adc	r19, r19
    452a:	82 0f       	add	r24, r18
    452c:	93 1f       	adc	r25, r19
    452e:	84 0f       	add	r24, r20
    4530:	95 1f       	adc	r25, r21
    4532:	fc 01       	movw	r30, r24
    4534:	e7 5b       	subi	r30, 0xB7	; 183
    4536:	fa 4e       	sbci	r31, 0xEA	; 234
    4538:	81 81       	ldd	r24, Z+1	; 0x01
    453a:	92 81       	ldd	r25, Z+2	; 0x02
    453c:	9c 83       	std	Y+4, r25	; 0x04
    453e:	8b 83       	std	Y+3, r24	; 0x03
    4540:	ea 85       	ldd	r30, Y+10	; 0x0a
    4542:	fb 85       	ldd	r31, Y+11	; 0x0b
    4544:	8b 81       	ldd	r24, Y+3	; 0x03
    4546:	9c 81       	ldd	r25, Y+4	; 0x04
    4548:	97 83       	std	Z+7, r25	; 0x07
    454a:	86 83       	std	Z+6, r24	; 0x06
    454c:	eb 81       	ldd	r30, Y+3	; 0x03
    454e:	fc 81       	ldd	r31, Y+4	; 0x04
    4550:	86 81       	ldd	r24, Z+6	; 0x06
    4552:	97 81       	ldd	r25, Z+7	; 0x07
    4554:	ea 85       	ldd	r30, Y+10	; 0x0a
    4556:	fb 85       	ldd	r31, Y+11	; 0x0b
    4558:	91 87       	std	Z+9, r25	; 0x09
    455a:	80 87       	std	Z+8, r24	; 0x08
    455c:	eb 81       	ldd	r30, Y+3	; 0x03
    455e:	fc 81       	ldd	r31, Y+4	; 0x04
    4560:	06 80       	ldd	r0, Z+6	; 0x06
    4562:	f7 81       	ldd	r31, Z+7	; 0x07
    4564:	e0 2d       	mov	r30, r0
    4566:	8a 85       	ldd	r24, Y+10	; 0x0a
    4568:	9b 85       	ldd	r25, Y+11	; 0x0b
    456a:	02 96       	adiw	r24, 0x02	; 2
    456c:	95 83       	std	Z+5, r25	; 0x05
    456e:	84 83       	std	Z+4, r24	; 0x04
    4570:	8a 85       	ldd	r24, Y+10	; 0x0a
    4572:	9b 85       	ldd	r25, Y+11	; 0x0b
    4574:	02 96       	adiw	r24, 0x02	; 2
    4576:	eb 81       	ldd	r30, Y+3	; 0x03
    4578:	fc 81       	ldd	r31, Y+4	; 0x04
    457a:	97 83       	std	Z+7, r25	; 0x07
    457c:	86 83       	std	Z+6, r24	; 0x06
    457e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4580:	fb 85       	ldd	r31, Y+11	; 0x0b
    4582:	82 8d       	ldd	r24, Z+26	; 0x1a
    4584:	48 2f       	mov	r20, r24
    4586:	50 e0       	ldi	r21, 0x00	; 0
    4588:	ca 01       	movw	r24, r20
    458a:	88 0f       	add	r24, r24
    458c:	99 1f       	adc	r25, r25
    458e:	9c 01       	movw	r18, r24
    4590:	22 0f       	add	r18, r18
    4592:	33 1f       	adc	r19, r19
    4594:	22 0f       	add	r18, r18
    4596:	33 1f       	adc	r19, r19
    4598:	82 0f       	add	r24, r18
    459a:	93 1f       	adc	r25, r19
    459c:	84 0f       	add	r24, r20
    459e:	95 1f       	adc	r25, r21
    45a0:	87 5b       	subi	r24, 0xB7	; 183
    45a2:	9a 4e       	sbci	r25, 0xEA	; 234
    45a4:	ea 85       	ldd	r30, Y+10	; 0x0a
    45a6:	fb 85       	ldd	r31, Y+11	; 0x0b
    45a8:	95 87       	std	Z+13, r25	; 0x0d
    45aa:	84 87       	std	Z+12, r24	; 0x0c
    45ac:	ea 85       	ldd	r30, Y+10	; 0x0a
    45ae:	fb 85       	ldd	r31, Y+11	; 0x0b
    45b0:	82 8d       	ldd	r24, Z+26	; 0x1a
    45b2:	48 2f       	mov	r20, r24
    45b4:	50 e0       	ldi	r21, 0x00	; 0
    45b6:	ca 01       	movw	r24, r20
    45b8:	88 0f       	add	r24, r24
    45ba:	99 1f       	adc	r25, r25
    45bc:	9c 01       	movw	r18, r24
    45be:	22 0f       	add	r18, r18
    45c0:	33 1f       	adc	r19, r19
    45c2:	22 0f       	add	r18, r18
    45c4:	33 1f       	adc	r19, r19
    45c6:	82 0f       	add	r24, r18
    45c8:	93 1f       	adc	r25, r19
    45ca:	84 0f       	add	r24, r20
    45cc:	95 1f       	adc	r25, r21
    45ce:	fc 01       	movw	r30, r24
    45d0:	e7 5b       	subi	r30, 0xB7	; 183
    45d2:	fa 4e       	sbci	r31, 0xEA	; 234
    45d4:	80 81       	ld	r24, Z
    45d6:	8f 5f       	subi	r24, 0xFF	; 255
    45d8:	80 83       	st	Z, r24
    45da:	30 c0       	rjmp	.+96     	; 0x463c <xTaskRemoveFromEventList+0x270>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    45dc:	80 91 9b 15 	lds	r24, 0x159B
    45e0:	90 91 9c 15 	lds	r25, 0x159C
    45e4:	9a 83       	std	Y+2, r25	; 0x02
    45e6:	89 83       	std	Y+1, r24	; 0x01
    45e8:	ea 85       	ldd	r30, Y+10	; 0x0a
    45ea:	fb 85       	ldd	r31, Y+11	; 0x0b
    45ec:	89 81       	ldd	r24, Y+1	; 0x01
    45ee:	9a 81       	ldd	r25, Y+2	; 0x02
    45f0:	93 8b       	std	Z+19, r25	; 0x13
    45f2:	82 8b       	std	Z+18, r24	; 0x12
    45f4:	e9 81       	ldd	r30, Y+1	; 0x01
    45f6:	fa 81       	ldd	r31, Y+2	; 0x02
    45f8:	86 81       	ldd	r24, Z+6	; 0x06
    45fa:	97 81       	ldd	r25, Z+7	; 0x07
    45fc:	ea 85       	ldd	r30, Y+10	; 0x0a
    45fe:	fb 85       	ldd	r31, Y+11	; 0x0b
    4600:	95 8b       	std	Z+21, r25	; 0x15
    4602:	84 8b       	std	Z+20, r24	; 0x14
    4604:	e9 81       	ldd	r30, Y+1	; 0x01
    4606:	fa 81       	ldd	r31, Y+2	; 0x02
    4608:	06 80       	ldd	r0, Z+6	; 0x06
    460a:	f7 81       	ldd	r31, Z+7	; 0x07
    460c:	e0 2d       	mov	r30, r0
    460e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4610:	9b 85       	ldd	r25, Y+11	; 0x0b
    4612:	0e 96       	adiw	r24, 0x0e	; 14
    4614:	95 83       	std	Z+5, r25	; 0x05
    4616:	84 83       	std	Z+4, r24	; 0x04
    4618:	8a 85       	ldd	r24, Y+10	; 0x0a
    461a:	9b 85       	ldd	r25, Y+11	; 0x0b
    461c:	0e 96       	adiw	r24, 0x0e	; 14
    461e:	e9 81       	ldd	r30, Y+1	; 0x01
    4620:	fa 81       	ldd	r31, Y+2	; 0x02
    4622:	97 83       	std	Z+7, r25	; 0x07
    4624:	86 83       	std	Z+6, r24	; 0x06
    4626:	ea 85       	ldd	r30, Y+10	; 0x0a
    4628:	fb 85       	ldd	r31, Y+11	; 0x0b
    462a:	8a e9       	ldi	r24, 0x9A	; 154
    462c:	95 e1       	ldi	r25, 0x15	; 21
    462e:	91 8f       	std	Z+25, r25	; 0x19
    4630:	80 8f       	std	Z+24, r24	; 0x18
    4632:	80 91 9a 15 	lds	r24, 0x159A
    4636:	8f 5f       	subi	r24, 0xFF	; 255
    4638:	80 93 9a 15 	sts	0x159A, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    463c:	ea 85       	ldd	r30, Y+10	; 0x0a
    463e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4640:	92 8d       	ldd	r25, Z+26	; 0x1a
    4642:	e0 91 32 15 	lds	r30, 0x1532
    4646:	f0 91 33 15 	lds	r31, 0x1533
    464a:	82 8d       	ldd	r24, Z+26	; 0x1a
    464c:	89 17       	cp	r24, r25
    464e:	30 f4       	brcc	.+12     	; 0x465c <xTaskRemoveFromEventList+0x290>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    4650:	81 e0       	ldi	r24, 0x01	; 1
    4652:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    4654:	81 e0       	ldi	r24, 0x01	; 1
    4656:	80 93 3f 15 	sts	0x153F, r24
    465a:	01 c0       	rjmp	.+2      	; 0x465e <xTaskRemoveFromEventList+0x292>
    }
    else
    {
        xReturn = pdFALSE;
    465c:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    465e:	89 85       	ldd	r24, Y+9	; 0x09
}
    4660:	2d 96       	adiw	r28, 0x0d	; 13
    4662:	0f b6       	in	r0, 0x3f	; 63
    4664:	f8 94       	cli
    4666:	de bf       	out	0x3e, r29	; 62
    4668:	0f be       	out	0x3f, r0	; 63
    466a:	cd bf       	out	0x3d, r28	; 61
    466c:	cf 91       	pop	r28
    466e:	df 91       	pop	r29
    4670:	08 95       	ret

00004672 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    4672:	df 93       	push	r29
    4674:	cf 93       	push	r28
    4676:	cd b7       	in	r28, 0x3d	; 61
    4678:	de b7       	in	r29, 0x3e	; 62
    467a:	2e 97       	sbiw	r28, 0x0e	; 14
    467c:	0f b6       	in	r0, 0x3f	; 63
    467e:	f8 94       	cli
    4680:	de bf       	out	0x3e, r29	; 62
    4682:	0f be       	out	0x3f, r0	; 63
    4684:	cd bf       	out	0x3d, r28	; 61
    4686:	9a 87       	std	Y+10, r25	; 0x0a
    4688:	89 87       	std	Y+9, r24	; 0x09
    468a:	4b 87       	std	Y+11, r20	; 0x0b
    468c:	5c 87       	std	Y+12, r21	; 0x0c
    468e:	6d 87       	std	Y+13, r22	; 0x0d
    4690:	7e 87       	std	Y+14, r23	; 0x0e
    TCB_t * pxUnblockedTCB;

    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );
    4692:	80 91 48 15 	lds	r24, 0x1548
    4696:	88 23       	and	r24, r24
    4698:	11 f4       	brne	.+4      	; 0x469e <vTaskRemoveFromUnorderedEventList+0x2c>
    469a:	f8 94       	cli
    469c:	ff cf       	rjmp	.-2      	; 0x469c <vTaskRemoveFromUnorderedEventList+0x2a>

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    469e:	8b 85       	ldd	r24, Y+11	; 0x0b
    46a0:	9c 85       	ldd	r25, Y+12	; 0x0c
    46a2:	ad 85       	ldd	r26, Y+13	; 0x0d
    46a4:	be 85       	ldd	r27, Y+14	; 0x0e
    46a6:	b0 68       	ori	r27, 0x80	; 128
    46a8:	e9 85       	ldd	r30, Y+9	; 0x09
    46aa:	fa 85       	ldd	r31, Y+10	; 0x0a
    46ac:	80 83       	st	Z, r24
    46ae:	91 83       	std	Z+1, r25	; 0x01
    46b0:	a2 83       	std	Z+2, r26	; 0x02
    46b2:	b3 83       	std	Z+3, r27	; 0x03

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    46b4:	e9 85       	ldd	r30, Y+9	; 0x09
    46b6:	fa 85       	ldd	r31, Y+10	; 0x0a
    46b8:	80 85       	ldd	r24, Z+8	; 0x08
    46ba:	91 85       	ldd	r25, Z+9	; 0x09
    46bc:	98 87       	std	Y+8, r25	; 0x08
    46be:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    46c0:	8f 81       	ldd	r24, Y+7	; 0x07
    46c2:	98 85       	ldd	r25, Y+8	; 0x08
    46c4:	00 97       	sbiw	r24, 0x00	; 0
    46c6:	11 f4       	brne	.+4      	; 0x46cc <vTaskRemoveFromUnorderedEventList+0x5a>
    46c8:	f8 94       	cli
    46ca:	ff cf       	rjmp	.-2      	; 0x46ca <vTaskRemoveFromUnorderedEventList+0x58>
    listREMOVE_ITEM( pxEventListItem );
    46cc:	e9 85       	ldd	r30, Y+9	; 0x09
    46ce:	fa 85       	ldd	r31, Y+10	; 0x0a
    46d0:	82 85       	ldd	r24, Z+10	; 0x0a
    46d2:	93 85       	ldd	r25, Z+11	; 0x0b
    46d4:	9e 83       	std	Y+6, r25	; 0x06
    46d6:	8d 83       	std	Y+5, r24	; 0x05
    46d8:	e9 85       	ldd	r30, Y+9	; 0x09
    46da:	fa 85       	ldd	r31, Y+10	; 0x0a
    46dc:	a4 81       	ldd	r26, Z+4	; 0x04
    46de:	b5 81       	ldd	r27, Z+5	; 0x05
    46e0:	e9 85       	ldd	r30, Y+9	; 0x09
    46e2:	fa 85       	ldd	r31, Y+10	; 0x0a
    46e4:	86 81       	ldd	r24, Z+6	; 0x06
    46e6:	97 81       	ldd	r25, Z+7	; 0x07
    46e8:	17 96       	adiw	r26, 0x07	; 7
    46ea:	9c 93       	st	X, r25
    46ec:	8e 93       	st	-X, r24
    46ee:	16 97       	sbiw	r26, 0x06	; 6
    46f0:	e9 85       	ldd	r30, Y+9	; 0x09
    46f2:	fa 85       	ldd	r31, Y+10	; 0x0a
    46f4:	a6 81       	ldd	r26, Z+6	; 0x06
    46f6:	b7 81       	ldd	r27, Z+7	; 0x07
    46f8:	e9 85       	ldd	r30, Y+9	; 0x09
    46fa:	fa 85       	ldd	r31, Y+10	; 0x0a
    46fc:	84 81       	ldd	r24, Z+4	; 0x04
    46fe:	95 81       	ldd	r25, Z+5	; 0x05
    4700:	15 96       	adiw	r26, 0x05	; 5
    4702:	9c 93       	st	X, r25
    4704:	8e 93       	st	-X, r24
    4706:	14 97       	sbiw	r26, 0x04	; 4
    4708:	ed 81       	ldd	r30, Y+5	; 0x05
    470a:	fe 81       	ldd	r31, Y+6	; 0x06
    470c:	21 81       	ldd	r18, Z+1	; 0x01
    470e:	32 81       	ldd	r19, Z+2	; 0x02
    4710:	89 85       	ldd	r24, Y+9	; 0x09
    4712:	9a 85       	ldd	r25, Y+10	; 0x0a
    4714:	28 17       	cp	r18, r24
    4716:	39 07       	cpc	r19, r25
    4718:	41 f4       	brne	.+16     	; 0x472a <vTaskRemoveFromUnorderedEventList+0xb8>
    471a:	e9 85       	ldd	r30, Y+9	; 0x09
    471c:	fa 85       	ldd	r31, Y+10	; 0x0a
    471e:	86 81       	ldd	r24, Z+6	; 0x06
    4720:	97 81       	ldd	r25, Z+7	; 0x07
    4722:	ed 81       	ldd	r30, Y+5	; 0x05
    4724:	fe 81       	ldd	r31, Y+6	; 0x06
    4726:	92 83       	std	Z+2, r25	; 0x02
    4728:	81 83       	std	Z+1, r24	; 0x01
    472a:	e9 85       	ldd	r30, Y+9	; 0x09
    472c:	fa 85       	ldd	r31, Y+10	; 0x0a
    472e:	13 86       	std	Z+11, r1	; 0x0b
    4730:	12 86       	std	Z+10, r1	; 0x0a
    4732:	ed 81       	ldd	r30, Y+5	; 0x05
    4734:	fe 81       	ldd	r31, Y+6	; 0x06
    4736:	80 81       	ld	r24, Z
    4738:	81 50       	subi	r24, 0x01	; 1
    473a:	ed 81       	ldd	r30, Y+5	; 0x05
    473c:	fe 81       	ldd	r31, Y+6	; 0x06
    473e:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4740:	ef 81       	ldd	r30, Y+7	; 0x07
    4742:	f8 85       	ldd	r31, Y+8	; 0x08
    4744:	84 85       	ldd	r24, Z+12	; 0x0c
    4746:	95 85       	ldd	r25, Z+13	; 0x0d
    4748:	9c 83       	std	Y+4, r25	; 0x04
    474a:	8b 83       	std	Y+3, r24	; 0x03
    474c:	ef 81       	ldd	r30, Y+7	; 0x07
    474e:	f8 85       	ldd	r31, Y+8	; 0x08
    4750:	a6 81       	ldd	r26, Z+6	; 0x06
    4752:	b7 81       	ldd	r27, Z+7	; 0x07
    4754:	ef 81       	ldd	r30, Y+7	; 0x07
    4756:	f8 85       	ldd	r31, Y+8	; 0x08
    4758:	80 85       	ldd	r24, Z+8	; 0x08
    475a:	91 85       	ldd	r25, Z+9	; 0x09
    475c:	17 96       	adiw	r26, 0x07	; 7
    475e:	9c 93       	st	X, r25
    4760:	8e 93       	st	-X, r24
    4762:	16 97       	sbiw	r26, 0x06	; 6
    4764:	ef 81       	ldd	r30, Y+7	; 0x07
    4766:	f8 85       	ldd	r31, Y+8	; 0x08
    4768:	a0 85       	ldd	r26, Z+8	; 0x08
    476a:	b1 85       	ldd	r27, Z+9	; 0x09
    476c:	ef 81       	ldd	r30, Y+7	; 0x07
    476e:	f8 85       	ldd	r31, Y+8	; 0x08
    4770:	86 81       	ldd	r24, Z+6	; 0x06
    4772:	97 81       	ldd	r25, Z+7	; 0x07
    4774:	15 96       	adiw	r26, 0x05	; 5
    4776:	9c 93       	st	X, r25
    4778:	8e 93       	st	-X, r24
    477a:	14 97       	sbiw	r26, 0x04	; 4
    477c:	eb 81       	ldd	r30, Y+3	; 0x03
    477e:	fc 81       	ldd	r31, Y+4	; 0x04
    4780:	21 81       	ldd	r18, Z+1	; 0x01
    4782:	32 81       	ldd	r19, Z+2	; 0x02
    4784:	8f 81       	ldd	r24, Y+7	; 0x07
    4786:	98 85       	ldd	r25, Y+8	; 0x08
    4788:	02 96       	adiw	r24, 0x02	; 2
    478a:	28 17       	cp	r18, r24
    478c:	39 07       	cpc	r19, r25
    478e:	41 f4       	brne	.+16     	; 0x47a0 <vTaskRemoveFromUnorderedEventList+0x12e>
    4790:	ef 81       	ldd	r30, Y+7	; 0x07
    4792:	f8 85       	ldd	r31, Y+8	; 0x08
    4794:	80 85       	ldd	r24, Z+8	; 0x08
    4796:	91 85       	ldd	r25, Z+9	; 0x09
    4798:	eb 81       	ldd	r30, Y+3	; 0x03
    479a:	fc 81       	ldd	r31, Y+4	; 0x04
    479c:	92 83       	std	Z+2, r25	; 0x02
    479e:	81 83       	std	Z+1, r24	; 0x01
    47a0:	ef 81       	ldd	r30, Y+7	; 0x07
    47a2:	f8 85       	ldd	r31, Y+8	; 0x08
    47a4:	15 86       	std	Z+13, r1	; 0x0d
    47a6:	14 86       	std	Z+12, r1	; 0x0c
    47a8:	eb 81       	ldd	r30, Y+3	; 0x03
    47aa:	fc 81       	ldd	r31, Y+4	; 0x04
    47ac:	80 81       	ld	r24, Z
    47ae:	81 50       	subi	r24, 0x01	; 1
    47b0:	eb 81       	ldd	r30, Y+3	; 0x03
    47b2:	fc 81       	ldd	r31, Y+4	; 0x04
    47b4:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    47b6:	ef 81       	ldd	r30, Y+7	; 0x07
    47b8:	f8 85       	ldd	r31, Y+8	; 0x08
    47ba:	92 8d       	ldd	r25, Z+26	; 0x1a
    47bc:	80 91 39 15 	lds	r24, 0x1539
    47c0:	89 17       	cp	r24, r25
    47c2:	28 f4       	brcc	.+10     	; 0x47ce <vTaskRemoveFromUnorderedEventList+0x15c>
    47c4:	ef 81       	ldd	r30, Y+7	; 0x07
    47c6:	f8 85       	ldd	r31, Y+8	; 0x08
    47c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    47ca:	80 93 39 15 	sts	0x1539, r24
    47ce:	ef 81       	ldd	r30, Y+7	; 0x07
    47d0:	f8 85       	ldd	r31, Y+8	; 0x08
    47d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    47d4:	48 2f       	mov	r20, r24
    47d6:	50 e0       	ldi	r21, 0x00	; 0
    47d8:	ca 01       	movw	r24, r20
    47da:	88 0f       	add	r24, r24
    47dc:	99 1f       	adc	r25, r25
    47de:	9c 01       	movw	r18, r24
    47e0:	22 0f       	add	r18, r18
    47e2:	33 1f       	adc	r19, r19
    47e4:	22 0f       	add	r18, r18
    47e6:	33 1f       	adc	r19, r19
    47e8:	82 0f       	add	r24, r18
    47ea:	93 1f       	adc	r25, r19
    47ec:	84 0f       	add	r24, r20
    47ee:	95 1f       	adc	r25, r21
    47f0:	fc 01       	movw	r30, r24
    47f2:	e7 5b       	subi	r30, 0xB7	; 183
    47f4:	fa 4e       	sbci	r31, 0xEA	; 234
    47f6:	81 81       	ldd	r24, Z+1	; 0x01
    47f8:	92 81       	ldd	r25, Z+2	; 0x02
    47fa:	9a 83       	std	Y+2, r25	; 0x02
    47fc:	89 83       	std	Y+1, r24	; 0x01
    47fe:	ef 81       	ldd	r30, Y+7	; 0x07
    4800:	f8 85       	ldd	r31, Y+8	; 0x08
    4802:	89 81       	ldd	r24, Y+1	; 0x01
    4804:	9a 81       	ldd	r25, Y+2	; 0x02
    4806:	97 83       	std	Z+7, r25	; 0x07
    4808:	86 83       	std	Z+6, r24	; 0x06
    480a:	e9 81       	ldd	r30, Y+1	; 0x01
    480c:	fa 81       	ldd	r31, Y+2	; 0x02
    480e:	86 81       	ldd	r24, Z+6	; 0x06
    4810:	97 81       	ldd	r25, Z+7	; 0x07
    4812:	ef 81       	ldd	r30, Y+7	; 0x07
    4814:	f8 85       	ldd	r31, Y+8	; 0x08
    4816:	91 87       	std	Z+9, r25	; 0x09
    4818:	80 87       	std	Z+8, r24	; 0x08
    481a:	e9 81       	ldd	r30, Y+1	; 0x01
    481c:	fa 81       	ldd	r31, Y+2	; 0x02
    481e:	06 80       	ldd	r0, Z+6	; 0x06
    4820:	f7 81       	ldd	r31, Z+7	; 0x07
    4822:	e0 2d       	mov	r30, r0
    4824:	8f 81       	ldd	r24, Y+7	; 0x07
    4826:	98 85       	ldd	r25, Y+8	; 0x08
    4828:	02 96       	adiw	r24, 0x02	; 2
    482a:	95 83       	std	Z+5, r25	; 0x05
    482c:	84 83       	std	Z+4, r24	; 0x04
    482e:	8f 81       	ldd	r24, Y+7	; 0x07
    4830:	98 85       	ldd	r25, Y+8	; 0x08
    4832:	02 96       	adiw	r24, 0x02	; 2
    4834:	e9 81       	ldd	r30, Y+1	; 0x01
    4836:	fa 81       	ldd	r31, Y+2	; 0x02
    4838:	97 83       	std	Z+7, r25	; 0x07
    483a:	86 83       	std	Z+6, r24	; 0x06
    483c:	ef 81       	ldd	r30, Y+7	; 0x07
    483e:	f8 85       	ldd	r31, Y+8	; 0x08
    4840:	82 8d       	ldd	r24, Z+26	; 0x1a
    4842:	48 2f       	mov	r20, r24
    4844:	50 e0       	ldi	r21, 0x00	; 0
    4846:	ca 01       	movw	r24, r20
    4848:	88 0f       	add	r24, r24
    484a:	99 1f       	adc	r25, r25
    484c:	9c 01       	movw	r18, r24
    484e:	22 0f       	add	r18, r18
    4850:	33 1f       	adc	r19, r19
    4852:	22 0f       	add	r18, r18
    4854:	33 1f       	adc	r19, r19
    4856:	82 0f       	add	r24, r18
    4858:	93 1f       	adc	r25, r19
    485a:	84 0f       	add	r24, r20
    485c:	95 1f       	adc	r25, r21
    485e:	87 5b       	subi	r24, 0xB7	; 183
    4860:	9a 4e       	sbci	r25, 0xEA	; 234
    4862:	ef 81       	ldd	r30, Y+7	; 0x07
    4864:	f8 85       	ldd	r31, Y+8	; 0x08
    4866:	95 87       	std	Z+13, r25	; 0x0d
    4868:	84 87       	std	Z+12, r24	; 0x0c
    486a:	ef 81       	ldd	r30, Y+7	; 0x07
    486c:	f8 85       	ldd	r31, Y+8	; 0x08
    486e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4870:	48 2f       	mov	r20, r24
    4872:	50 e0       	ldi	r21, 0x00	; 0
    4874:	ca 01       	movw	r24, r20
    4876:	88 0f       	add	r24, r24
    4878:	99 1f       	adc	r25, r25
    487a:	9c 01       	movw	r18, r24
    487c:	22 0f       	add	r18, r18
    487e:	33 1f       	adc	r19, r19
    4880:	22 0f       	add	r18, r18
    4882:	33 1f       	adc	r19, r19
    4884:	82 0f       	add	r24, r18
    4886:	93 1f       	adc	r25, r19
    4888:	84 0f       	add	r24, r20
    488a:	95 1f       	adc	r25, r21
    488c:	fc 01       	movw	r30, r24
    488e:	e7 5b       	subi	r30, 0xB7	; 183
    4890:	fa 4e       	sbci	r31, 0xEA	; 234
    4892:	80 81       	ld	r24, Z
    4894:	8f 5f       	subi	r24, 0xFF	; 255
    4896:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4898:	ef 81       	ldd	r30, Y+7	; 0x07
    489a:	f8 85       	ldd	r31, Y+8	; 0x08
    489c:	92 8d       	ldd	r25, Z+26	; 0x1a
    489e:	e0 91 32 15 	lds	r30, 0x1532
    48a2:	f0 91 33 15 	lds	r31, 0x1533
    48a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    48a8:	89 17       	cp	r24, r25
    48aa:	18 f4       	brcc	.+6      	; 0x48b2 <vTaskRemoveFromUnorderedEventList+0x240>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    48ac:	81 e0       	ldi	r24, 0x01	; 1
    48ae:	80 93 3f 15 	sts	0x153F, r24
    }
}
    48b2:	2e 96       	adiw	r28, 0x0e	; 14
    48b4:	0f b6       	in	r0, 0x3f	; 63
    48b6:	f8 94       	cli
    48b8:	de bf       	out	0x3e, r29	; 62
    48ba:	0f be       	out	0x3f, r0	; 63
    48bc:	cd bf       	out	0x3d, r28	; 61
    48be:	cf 91       	pop	r28
    48c0:	df 91       	pop	r29
    48c2:	08 95       	ret

000048c4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    48c4:	df 93       	push	r29
    48c6:	cf 93       	push	r28
    48c8:	00 d0       	rcall	.+0      	; 0x48ca <vTaskSetTimeOutState+0x6>
    48ca:	cd b7       	in	r28, 0x3d	; 61
    48cc:	de b7       	in	r29, 0x3e	; 62
    48ce:	9a 83       	std	Y+2, r25	; 0x02
    48d0:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    48d2:	89 81       	ldd	r24, Y+1	; 0x01
    48d4:	9a 81       	ldd	r25, Y+2	; 0x02
    48d6:	00 97       	sbiw	r24, 0x00	; 0
    48d8:	11 f4       	brne	.+4      	; 0x48de <vTaskSetTimeOutState+0x1a>
    48da:	f8 94       	cli
    48dc:	ff cf       	rjmp	.-2      	; 0x48dc <vTaskSetTimeOutState+0x18>
    taskENTER_CRITICAL();
    48de:	0f b6       	in	r0, 0x3f	; 63
    48e0:	f8 94       	cli
    48e2:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    48e4:	80 91 40 15 	lds	r24, 0x1540
    48e8:	e9 81       	ldd	r30, Y+1	; 0x01
    48ea:	fa 81       	ldd	r31, Y+2	; 0x02
    48ec:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    48ee:	80 91 35 15 	lds	r24, 0x1535
    48f2:	90 91 36 15 	lds	r25, 0x1536
    48f6:	a0 91 37 15 	lds	r26, 0x1537
    48fa:	b0 91 38 15 	lds	r27, 0x1538
    48fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4900:	fa 81       	ldd	r31, Y+2	; 0x02
    4902:	81 83       	std	Z+1, r24	; 0x01
    4904:	92 83       	std	Z+2, r25	; 0x02
    4906:	a3 83       	std	Z+3, r26	; 0x03
    4908:	b4 83       	std	Z+4, r27	; 0x04
    }
    taskEXIT_CRITICAL();
    490a:	0f 90       	pop	r0
    490c:	0f be       	out	0x3f, r0	; 63
}
    490e:	0f 90       	pop	r0
    4910:	0f 90       	pop	r0
    4912:	cf 91       	pop	r28
    4914:	df 91       	pop	r29
    4916:	08 95       	ret

00004918 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4918:	df 93       	push	r29
    491a:	cf 93       	push	r28
    491c:	00 d0       	rcall	.+0      	; 0x491e <vTaskInternalSetTimeOutState+0x6>
    491e:	cd b7       	in	r28, 0x3d	; 61
    4920:	de b7       	in	r29, 0x3e	; 62
    4922:	9a 83       	std	Y+2, r25	; 0x02
    4924:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4926:	80 91 40 15 	lds	r24, 0x1540
    492a:	e9 81       	ldd	r30, Y+1	; 0x01
    492c:	fa 81       	ldd	r31, Y+2	; 0x02
    492e:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    4930:	80 91 35 15 	lds	r24, 0x1535
    4934:	90 91 36 15 	lds	r25, 0x1536
    4938:	a0 91 37 15 	lds	r26, 0x1537
    493c:	b0 91 38 15 	lds	r27, 0x1538
    4940:	e9 81       	ldd	r30, Y+1	; 0x01
    4942:	fa 81       	ldd	r31, Y+2	; 0x02
    4944:	81 83       	std	Z+1, r24	; 0x01
    4946:	92 83       	std	Z+2, r25	; 0x02
    4948:	a3 83       	std	Z+3, r26	; 0x03
    494a:	b4 83       	std	Z+4, r27	; 0x04
}
    494c:	0f 90       	pop	r0
    494e:	0f 90       	pop	r0
    4950:	cf 91       	pop	r28
    4952:	df 91       	pop	r29
    4954:	08 95       	ret

00004956 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    4956:	ef 92       	push	r14
    4958:	ff 92       	push	r15
    495a:	0f 93       	push	r16
    495c:	1f 93       	push	r17
    495e:	df 93       	push	r29
    4960:	cf 93       	push	r28
    4962:	cd b7       	in	r28, 0x3d	; 61
    4964:	de b7       	in	r29, 0x3e	; 62
    4966:	2d 97       	sbiw	r28, 0x0d	; 13
    4968:	0f b6       	in	r0, 0x3f	; 63
    496a:	f8 94       	cli
    496c:	de bf       	out	0x3e, r29	; 62
    496e:	0f be       	out	0x3f, r0	; 63
    4970:	cd bf       	out	0x3d, r28	; 61
    4972:	9b 87       	std	Y+11, r25	; 0x0b
    4974:	8a 87       	std	Y+10, r24	; 0x0a
    4976:	7d 87       	std	Y+13, r23	; 0x0d
    4978:	6c 87       	std	Y+12, r22	; 0x0c
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    497a:	8a 85       	ldd	r24, Y+10	; 0x0a
    497c:	9b 85       	ldd	r25, Y+11	; 0x0b
    497e:	00 97       	sbiw	r24, 0x00	; 0
    4980:	11 f4       	brne	.+4      	; 0x4986 <xTaskCheckForTimeOut+0x30>
    4982:	f8 94       	cli
    4984:	ff cf       	rjmp	.-2      	; 0x4984 <xTaskCheckForTimeOut+0x2e>
    configASSERT( pxTicksToWait );
    4986:	8c 85       	ldd	r24, Y+12	; 0x0c
    4988:	9d 85       	ldd	r25, Y+13	; 0x0d
    498a:	00 97       	sbiw	r24, 0x00	; 0
    498c:	11 f4       	brne	.+4      	; 0x4992 <xTaskCheckForTimeOut+0x3c>
    498e:	f8 94       	cli
    4990:	ff cf       	rjmp	.-2      	; 0x4990 <xTaskCheckForTimeOut+0x3a>

    taskENTER_CRITICAL();
    4992:	0f b6       	in	r0, 0x3f	; 63
    4994:	f8 94       	cli
    4996:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    4998:	80 91 35 15 	lds	r24, 0x1535
    499c:	90 91 36 15 	lds	r25, 0x1536
    49a0:	a0 91 37 15 	lds	r26, 0x1537
    49a4:	b0 91 38 15 	lds	r27, 0x1538
    49a8:	8d 83       	std	Y+5, r24	; 0x05
    49aa:	9e 83       	std	Y+6, r25	; 0x06
    49ac:	af 83       	std	Y+7, r26	; 0x07
    49ae:	b8 87       	std	Y+8, r27	; 0x08
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    49b0:	ea 85       	ldd	r30, Y+10	; 0x0a
    49b2:	fb 85       	ldd	r31, Y+11	; 0x0b
    49b4:	21 81       	ldd	r18, Z+1	; 0x01
    49b6:	32 81       	ldd	r19, Z+2	; 0x02
    49b8:	43 81       	ldd	r20, Z+3	; 0x03
    49ba:	54 81       	ldd	r21, Z+4	; 0x04
    49bc:	8d 81       	ldd	r24, Y+5	; 0x05
    49be:	9e 81       	ldd	r25, Y+6	; 0x06
    49c0:	af 81       	ldd	r26, Y+7	; 0x07
    49c2:	b8 85       	ldd	r27, Y+8	; 0x08
    49c4:	82 1b       	sub	r24, r18
    49c6:	93 0b       	sbc	r25, r19
    49c8:	a4 0b       	sbc	r26, r20
    49ca:	b5 0b       	sbc	r27, r21
    49cc:	89 83       	std	Y+1, r24	; 0x01
    49ce:	9a 83       	std	Y+2, r25	; 0x02
    49d0:	ab 83       	std	Y+3, r26	; 0x03
    49d2:	bc 83       	std	Y+4, r27	; 0x04
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    49d4:	ea 85       	ldd	r30, Y+10	; 0x0a
    49d6:	fb 85       	ldd	r31, Y+11	; 0x0b
    49d8:	90 81       	ld	r25, Z
    49da:	80 91 40 15 	lds	r24, 0x1540
    49de:	98 17       	cp	r25, r24
    49e0:	c1 f0       	breq	.+48     	; 0x4a12 <xTaskCheckForTimeOut+0xbc>
    49e2:	ea 85       	ldd	r30, Y+10	; 0x0a
    49e4:	fb 85       	ldd	r31, Y+11	; 0x0b
    49e6:	21 81       	ldd	r18, Z+1	; 0x01
    49e8:	32 81       	ldd	r19, Z+2	; 0x02
    49ea:	43 81       	ldd	r20, Z+3	; 0x03
    49ec:	54 81       	ldd	r21, Z+4	; 0x04
    49ee:	8d 81       	ldd	r24, Y+5	; 0x05
    49f0:	9e 81       	ldd	r25, Y+6	; 0x06
    49f2:	af 81       	ldd	r26, Y+7	; 0x07
    49f4:	b8 85       	ldd	r27, Y+8	; 0x08
    49f6:	82 17       	cp	r24, r18
    49f8:	93 07       	cpc	r25, r19
    49fa:	a4 07       	cpc	r26, r20
    49fc:	b5 07       	cpc	r27, r21
    49fe:	48 f0       	brcs	.+18     	; 0x4a12 <xTaskCheckForTimeOut+0xbc>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    4a00:	81 e0       	ldi	r24, 0x01	; 1
    4a02:	89 87       	std	Y+9, r24	; 0x09
            *pxTicksToWait = ( TickType_t ) 0;
    4a04:	ec 85       	ldd	r30, Y+12	; 0x0c
    4a06:	fd 85       	ldd	r31, Y+13	; 0x0d
    4a08:	10 82       	st	Z, r1
    4a0a:	11 82       	std	Z+1, r1	; 0x01
    4a0c:	12 82       	std	Z+2, r1	; 0x02
    4a0e:	13 82       	std	Z+3, r1	; 0x03
    4a10:	35 c0       	rjmp	.+106    	; 0x4a7c <xTaskCheckForTimeOut+0x126>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4a12:	ec 85       	ldd	r30, Y+12	; 0x0c
    4a14:	fd 85       	ldd	r31, Y+13	; 0x0d
    4a16:	20 81       	ld	r18, Z
    4a18:	31 81       	ldd	r19, Z+1	; 0x01
    4a1a:	42 81       	ldd	r20, Z+2	; 0x02
    4a1c:	53 81       	ldd	r21, Z+3	; 0x03
    4a1e:	89 81       	ldd	r24, Y+1	; 0x01
    4a20:	9a 81       	ldd	r25, Y+2	; 0x02
    4a22:	ab 81       	ldd	r26, Y+3	; 0x03
    4a24:	bc 81       	ldd	r27, Y+4	; 0x04
    4a26:	82 17       	cp	r24, r18
    4a28:	93 07       	cpc	r25, r19
    4a2a:	a4 07       	cpc	r26, r20
    4a2c:	b5 07       	cpc	r27, r21
    4a2e:	f0 f4       	brcc	.+60     	; 0x4a6c <xTaskCheckForTimeOut+0x116>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    4a30:	ec 85       	ldd	r30, Y+12	; 0x0c
    4a32:	fd 85       	ldd	r31, Y+13	; 0x0d
    4a34:	20 81       	ld	r18, Z
    4a36:	31 81       	ldd	r19, Z+1	; 0x01
    4a38:	42 81       	ldd	r20, Z+2	; 0x02
    4a3a:	53 81       	ldd	r21, Z+3	; 0x03
    4a3c:	89 81       	ldd	r24, Y+1	; 0x01
    4a3e:	9a 81       	ldd	r25, Y+2	; 0x02
    4a40:	ab 81       	ldd	r26, Y+3	; 0x03
    4a42:	bc 81       	ldd	r27, Y+4	; 0x04
    4a44:	79 01       	movw	r14, r18
    4a46:	8a 01       	movw	r16, r20
    4a48:	e8 1a       	sub	r14, r24
    4a4a:	f9 0a       	sbc	r15, r25
    4a4c:	0a 0b       	sbc	r16, r26
    4a4e:	1b 0b       	sbc	r17, r27
    4a50:	d8 01       	movw	r26, r16
    4a52:	c7 01       	movw	r24, r14
    4a54:	ec 85       	ldd	r30, Y+12	; 0x0c
    4a56:	fd 85       	ldd	r31, Y+13	; 0x0d
    4a58:	80 83       	st	Z, r24
    4a5a:	91 83       	std	Z+1, r25	; 0x01
    4a5c:	a2 83       	std	Z+2, r26	; 0x02
    4a5e:	b3 83       	std	Z+3, r27	; 0x03
            vTaskInternalSetTimeOutState( pxTimeOut );
    4a60:	8a 85       	ldd	r24, Y+10	; 0x0a
    4a62:	9b 85       	ldd	r25, Y+11	; 0x0b
    4a64:	0e 94 8c 24 	call	0x4918	; 0x4918 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    4a68:	19 86       	std	Y+9, r1	; 0x09
    4a6a:	08 c0       	rjmp	.+16     	; 0x4a7c <xTaskCheckForTimeOut+0x126>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    4a6c:	ec 85       	ldd	r30, Y+12	; 0x0c
    4a6e:	fd 85       	ldd	r31, Y+13	; 0x0d
    4a70:	10 82       	st	Z, r1
    4a72:	11 82       	std	Z+1, r1	; 0x01
    4a74:	12 82       	std	Z+2, r1	; 0x02
    4a76:	13 82       	std	Z+3, r1	; 0x03
            xReturn = pdTRUE;
    4a78:	81 e0       	ldi	r24, 0x01	; 1
    4a7a:	89 87       	std	Y+9, r24	; 0x09
        }
    }
    taskEXIT_CRITICAL();
    4a7c:	0f 90       	pop	r0
    4a7e:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4a80:	89 85       	ldd	r24, Y+9	; 0x09
}
    4a82:	2d 96       	adiw	r28, 0x0d	; 13
    4a84:	0f b6       	in	r0, 0x3f	; 63
    4a86:	f8 94       	cli
    4a88:	de bf       	out	0x3e, r29	; 62
    4a8a:	0f be       	out	0x3f, r0	; 63
    4a8c:	cd bf       	out	0x3d, r28	; 61
    4a8e:	cf 91       	pop	r28
    4a90:	df 91       	pop	r29
    4a92:	1f 91       	pop	r17
    4a94:	0f 91       	pop	r16
    4a96:	ff 90       	pop	r15
    4a98:	ef 90       	pop	r14
    4a9a:	08 95       	ret

00004a9c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4a9c:	df 93       	push	r29
    4a9e:	cf 93       	push	r28
    4aa0:	cd b7       	in	r28, 0x3d	; 61
    4aa2:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    4aa4:	81 e0       	ldi	r24, 0x01	; 1
    4aa6:	80 93 3f 15 	sts	0x153F, r24
}
    4aaa:	cf 91       	pop	r28
    4aac:	df 91       	pop	r29
    4aae:	08 95       	ret

00004ab0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4ab0:	df 93       	push	r29
    4ab2:	cf 93       	push	r28
    4ab4:	00 d0       	rcall	.+0      	; 0x4ab6 <prvIdleTask+0x6>
    4ab6:	cd b7       	in	r28, 0x3d	; 61
    4ab8:	de b7       	in	r29, 0x3e	; 62
    4aba:	9a 83       	std	Y+2, r25	; 0x02
    4abc:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    4abe:	0e 94 a4 25 	call	0x4b48	; 0x4b48 <prvCheckTasksWaitingTermination>
             *
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains more than one task
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    4ac2:	80 91 49 15 	lds	r24, 0x1549
    4ac6:	82 30       	cpi	r24, 0x02	; 2
    4ac8:	d0 f3       	brcs	.-12     	; 0x4abe <prvIdleTask+0xe>
            {
                taskYIELD();
    4aca:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
    4ace:	f7 cf       	rjmp	.-18     	; 0x4abe <prvIdleTask+0xe>

00004ad0 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4ad0:	df 93       	push	r29
    4ad2:	cf 93       	push	r28
    4ad4:	0f 92       	push	r0
    4ad6:	cd b7       	in	r28, 0x3d	; 61
    4ad8:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4ada:	19 82       	std	Y+1, r1	; 0x01
    4adc:	16 c0       	rjmp	.+44     	; 0x4b0a <prvInitialiseTaskLists+0x3a>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4ade:	89 81       	ldd	r24, Y+1	; 0x01
    4ae0:	48 2f       	mov	r20, r24
    4ae2:	50 e0       	ldi	r21, 0x00	; 0
    4ae4:	ca 01       	movw	r24, r20
    4ae6:	88 0f       	add	r24, r24
    4ae8:	99 1f       	adc	r25, r25
    4aea:	9c 01       	movw	r18, r24
    4aec:	22 0f       	add	r18, r18
    4aee:	33 1f       	adc	r19, r19
    4af0:	22 0f       	add	r18, r18
    4af2:	33 1f       	adc	r19, r19
    4af4:	82 0f       	add	r24, r18
    4af6:	93 1f       	adc	r25, r19
    4af8:	84 0f       	add	r24, r20
    4afa:	95 1f       	adc	r25, r21
    4afc:	87 5b       	subi	r24, 0xB7	; 183
    4afe:	9a 4e       	sbci	r25, 0xEA	; 234
    4b00:	0e 94 ce 0f 	call	0x1f9c	; 0x1f9c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4b04:	89 81       	ldd	r24, Y+1	; 0x01
    4b06:	8f 5f       	subi	r24, 0xFF	; 255
    4b08:	89 83       	std	Y+1, r24	; 0x01
    4b0a:	89 81       	ldd	r24, Y+1	; 0x01
    4b0c:	85 30       	cpi	r24, 0x05	; 5
    4b0e:	38 f3       	brcs	.-50     	; 0x4ade <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    4b10:	80 e8       	ldi	r24, 0x80	; 128
    4b12:	95 e1       	ldi	r25, 0x15	; 21
    4b14:	0e 94 ce 0f 	call	0x1f9c	; 0x1f9c <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    4b18:	8b e8       	ldi	r24, 0x8B	; 139
    4b1a:	95 e1       	ldi	r25, 0x15	; 21
    4b1c:	0e 94 ce 0f 	call	0x1f9c	; 0x1f9c <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4b20:	8a e9       	ldi	r24, 0x9A	; 154
    4b22:	95 e1       	ldi	r25, 0x15	; 21
    4b24:	0e 94 ce 0f 	call	0x1f9c	; 0x1f9c <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    4b28:	80 e8       	ldi	r24, 0x80	; 128
    4b2a:	95 e1       	ldi	r25, 0x15	; 21
    4b2c:	90 93 97 15 	sts	0x1597, r25
    4b30:	80 93 96 15 	sts	0x1596, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4b34:	8b e8       	ldi	r24, 0x8B	; 139
    4b36:	95 e1       	ldi	r25, 0x15	; 21
    4b38:	90 93 99 15 	sts	0x1599, r25
    4b3c:	80 93 98 15 	sts	0x1598, r24
}
    4b40:	0f 90       	pop	r0
    4b42:	cf 91       	pop	r28
    4b44:	df 91       	pop	r29
    4b46:	08 95       	ret

00004b48 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4b48:	df 93       	push	r29
    4b4a:	cf 93       	push	r28
    4b4c:	cd b7       	in	r28, 0x3d	; 61
    4b4e:	de b7       	in	r29, 0x3e	; 62

            prvDeleteTCB( pxTCB );
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
    4b50:	cf 91       	pop	r28
    4b52:	df 91       	pop	r29
    4b54:	08 95       	ret

00004b56 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4b56:	df 93       	push	r29
    4b58:	cf 93       	push	r28
    4b5a:	cd b7       	in	r28, 0x3d	; 61
    4b5c:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4b5e:	e0 91 96 15 	lds	r30, 0x1596
    4b62:	f0 91 97 15 	lds	r31, 0x1597
    4b66:	80 81       	ld	r24, Z
    4b68:	88 23       	and	r24, r24
    4b6a:	69 f4       	brne	.+26     	; 0x4b86 <prvResetNextTaskUnblockTime+0x30>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    4b6c:	8f ef       	ldi	r24, 0xFF	; 255
    4b6e:	9f ef       	ldi	r25, 0xFF	; 255
    4b70:	af ef       	ldi	r26, 0xFF	; 255
    4b72:	bf ef       	ldi	r27, 0xFF	; 255
    4b74:	80 93 42 15 	sts	0x1542, r24
    4b78:	90 93 43 15 	sts	0x1543, r25
    4b7c:	a0 93 44 15 	sts	0x1544, r26
    4b80:	b0 93 45 15 	sts	0x1545, r27
    4b84:	13 c0       	rjmp	.+38     	; 0x4bac <prvResetNextTaskUnblockTime+0x56>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4b86:	e0 91 96 15 	lds	r30, 0x1596
    4b8a:	f0 91 97 15 	lds	r31, 0x1597
    4b8e:	07 80       	ldd	r0, Z+7	; 0x07
    4b90:	f0 85       	ldd	r31, Z+8	; 0x08
    4b92:	e0 2d       	mov	r30, r0
    4b94:	80 81       	ld	r24, Z
    4b96:	91 81       	ldd	r25, Z+1	; 0x01
    4b98:	a2 81       	ldd	r26, Z+2	; 0x02
    4b9a:	b3 81       	ldd	r27, Z+3	; 0x03
    4b9c:	80 93 42 15 	sts	0x1542, r24
    4ba0:	90 93 43 15 	sts	0x1543, r25
    4ba4:	a0 93 44 15 	sts	0x1544, r26
    4ba8:	b0 93 45 15 	sts	0x1545, r27
    }
}
    4bac:	cf 91       	pop	r28
    4bae:	df 91       	pop	r29
    4bb0:	08 95       	ret

00004bb2 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
    4bb2:	df 93       	push	r29
    4bb4:	cf 93       	push	r28
    4bb6:	00 d0       	rcall	.+0      	; 0x4bb8 <xTaskGetCurrentTaskHandle+0x6>
    4bb8:	cd b7       	in	r28, 0x3d	; 61
    4bba:	de b7       	in	r29, 0x3e	; 62
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    4bbc:	80 91 32 15 	lds	r24, 0x1532
    4bc0:	90 91 33 15 	lds	r25, 0x1533
    4bc4:	9a 83       	std	Y+2, r25	; 0x02
    4bc6:	89 83       	std	Y+1, r24	; 0x01

        return xReturn;
    4bc8:	89 81       	ldd	r24, Y+1	; 0x01
    4bca:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    4bcc:	0f 90       	pop	r0
    4bce:	0f 90       	pop	r0
    4bd0:	cf 91       	pop	r28
    4bd2:	df 91       	pop	r29
    4bd4:	08 95       	ret

00004bd6 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4bd6:	df 93       	push	r29
    4bd8:	cf 93       	push	r28
    4bda:	00 d0       	rcall	.+0      	; 0x4bdc <uxTaskResetEventItemValue+0x6>
    4bdc:	00 d0       	rcall	.+0      	; 0x4bde <uxTaskResetEventItemValue+0x8>
    4bde:	cd b7       	in	r28, 0x3d	; 61
    4be0:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4be2:	e0 91 32 15 	lds	r30, 0x1532
    4be6:	f0 91 33 15 	lds	r31, 0x1533
    4bea:	86 85       	ldd	r24, Z+14	; 0x0e
    4bec:	97 85       	ldd	r25, Z+15	; 0x0f
    4bee:	a0 89       	ldd	r26, Z+16	; 0x10
    4bf0:	b1 89       	ldd	r27, Z+17	; 0x11
    4bf2:	89 83       	std	Y+1, r24	; 0x01
    4bf4:	9a 83       	std	Y+2, r25	; 0x02
    4bf6:	ab 83       	std	Y+3, r26	; 0x03
    4bf8:	bc 83       	std	Y+4, r27	; 0x04

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4bfa:	60 91 32 15 	lds	r22, 0x1532
    4bfe:	70 91 33 15 	lds	r23, 0x1533
    4c02:	e0 91 32 15 	lds	r30, 0x1532
    4c06:	f0 91 33 15 	lds	r31, 0x1533
    4c0a:	82 8d       	ldd	r24, Z+26	; 0x1a
    4c0c:	28 2f       	mov	r18, r24
    4c0e:	30 e0       	ldi	r19, 0x00	; 0
    4c10:	40 e0       	ldi	r20, 0x00	; 0
    4c12:	50 e0       	ldi	r21, 0x00	; 0
    4c14:	85 e0       	ldi	r24, 0x05	; 5
    4c16:	90 e0       	ldi	r25, 0x00	; 0
    4c18:	a0 e0       	ldi	r26, 0x00	; 0
    4c1a:	b0 e0       	ldi	r27, 0x00	; 0
    4c1c:	82 1b       	sub	r24, r18
    4c1e:	93 0b       	sbc	r25, r19
    4c20:	a4 0b       	sbc	r26, r20
    4c22:	b5 0b       	sbc	r27, r21
    4c24:	fb 01       	movw	r30, r22
    4c26:	86 87       	std	Z+14, r24	; 0x0e
    4c28:	97 87       	std	Z+15, r25	; 0x0f
    4c2a:	a0 8b       	std	Z+16, r26	; 0x10
    4c2c:	b1 8b       	std	Z+17, r27	; 0x11

    return uxReturn;
    4c2e:	89 81       	ldd	r24, Y+1	; 0x01
    4c30:	9a 81       	ldd	r25, Y+2	; 0x02
    4c32:	ab 81       	ldd	r26, Y+3	; 0x03
    4c34:	bc 81       	ldd	r27, Y+4	; 0x04
}
    4c36:	bc 01       	movw	r22, r24
    4c38:	cd 01       	movw	r24, r26
    4c3a:	0f 90       	pop	r0
    4c3c:	0f 90       	pop	r0
    4c3e:	0f 90       	pop	r0
    4c40:	0f 90       	pop	r0
    4c42:	cf 91       	pop	r28
    4c44:	df 91       	pop	r29
    4c46:	08 95       	ret

00004c48 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    4c48:	df 93       	push	r29
    4c4a:	cf 93       	push	r28
    4c4c:	cd b7       	in	r28, 0x3d	; 61
    4c4e:	de b7       	in	r29, 0x3e	; 62
    4c50:	2a 97       	sbiw	r28, 0x0a	; 10
    4c52:	0f b6       	in	r0, 0x3f	; 63
    4c54:	f8 94       	cli
    4c56:	de bf       	out	0x3e, r29	; 62
    4c58:	0f be       	out	0x3f, r0	; 63
    4c5a:	cd bf       	out	0x3d, r28	; 61
    4c5c:	8d 83       	std	Y+5, r24	; 0x05
    4c5e:	6e 83       	std	Y+6, r22	; 0x06
    4c60:	2f 83       	std	Y+7, r18	; 0x07
    4c62:	38 87       	std	Y+8, r19	; 0x08
    4c64:	49 87       	std	Y+9, r20	; 0x09
    4c66:	5a 87       	std	Y+10, r21	; 0x0a
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
    4c68:	8d 81       	ldd	r24, Y+5	; 0x05
    4c6a:	88 23       	and	r24, r24
    4c6c:	11 f0       	breq	.+4      	; 0x4c72 <ulTaskGenericNotifyTake+0x2a>
    4c6e:	f8 94       	cli
    4c70:	ff cf       	rjmp	.-2      	; 0x4c70 <ulTaskGenericNotifyTake+0x28>

        taskENTER_CRITICAL();
    4c72:	0f b6       	in	r0, 0x3f	; 63
    4c74:	f8 94       	cli
    4c76:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    4c78:	20 91 32 15 	lds	r18, 0x1532
    4c7c:	30 91 33 15 	lds	r19, 0x1533
    4c80:	8d 81       	ldd	r24, Y+5	; 0x05
    4c82:	88 2f       	mov	r24, r24
    4c84:	90 e0       	ldi	r25, 0x00	; 0
    4c86:	88 0f       	add	r24, r24
    4c88:	99 1f       	adc	r25, r25
    4c8a:	88 0f       	add	r24, r24
    4c8c:	99 1f       	adc	r25, r25
    4c8e:	82 0f       	add	r24, r18
    4c90:	93 1f       	adc	r25, r19
    4c92:	fc 01       	movw	r30, r24
    4c94:	bd 96       	adiw	r30, 0x2d	; 45
    4c96:	80 81       	ld	r24, Z
    4c98:	91 81       	ldd	r25, Z+1	; 0x01
    4c9a:	a2 81       	ldd	r26, Z+2	; 0x02
    4c9c:	b3 81       	ldd	r27, Z+3	; 0x03
    4c9e:	00 97       	sbiw	r24, 0x00	; 0
    4ca0:	a1 05       	cpc	r26, r1
    4ca2:	b1 05       	cpc	r27, r1
    4ca4:	01 f5       	brne	.+64     	; 0x4ce6 <ulTaskGenericNotifyTake+0x9e>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4ca6:	20 91 32 15 	lds	r18, 0x1532
    4caa:	30 91 33 15 	lds	r19, 0x1533
    4cae:	8d 81       	ldd	r24, Y+5	; 0x05
    4cb0:	88 2f       	mov	r24, r24
    4cb2:	90 e0       	ldi	r25, 0x00	; 0
    4cb4:	82 0f       	add	r24, r18
    4cb6:	93 1f       	adc	r25, r19
    4cb8:	fc 01       	movw	r30, r24
    4cba:	f1 96       	adiw	r30, 0x31	; 49
    4cbc:	81 e0       	ldi	r24, 0x01	; 1
    4cbe:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4cc0:	8f 81       	ldd	r24, Y+7	; 0x07
    4cc2:	98 85       	ldd	r25, Y+8	; 0x08
    4cc4:	a9 85       	ldd	r26, Y+9	; 0x09
    4cc6:	ba 85       	ldd	r27, Y+10	; 0x0a
    4cc8:	00 97       	sbiw	r24, 0x00	; 0
    4cca:	a1 05       	cpc	r26, r1
    4ccc:	b1 05       	cpc	r27, r1
    4cce:	59 f0       	breq	.+22     	; 0x4ce6 <ulTaskGenericNotifyTake+0x9e>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4cd0:	8f 81       	ldd	r24, Y+7	; 0x07
    4cd2:	98 85       	ldd	r25, Y+8	; 0x08
    4cd4:	a9 85       	ldd	r26, Y+9	; 0x09
    4cd6:	ba 85       	ldd	r27, Y+10	; 0x0a
    4cd8:	bc 01       	movw	r22, r24
    4cda:	cd 01       	movw	r24, r26
    4cdc:	41 e0       	ldi	r20, 0x01	; 1
    4cde:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4ce2:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4ce6:	0f 90       	pop	r0
    4ce8:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4cea:	0f b6       	in	r0, 0x3f	; 63
    4cec:	f8 94       	cli
    4cee:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4cf0:	20 91 32 15 	lds	r18, 0x1532
    4cf4:	30 91 33 15 	lds	r19, 0x1533
    4cf8:	8d 81       	ldd	r24, Y+5	; 0x05
    4cfa:	88 2f       	mov	r24, r24
    4cfc:	90 e0       	ldi	r25, 0x00	; 0
    4cfe:	88 0f       	add	r24, r24
    4d00:	99 1f       	adc	r25, r25
    4d02:	88 0f       	add	r24, r24
    4d04:	99 1f       	adc	r25, r25
    4d06:	82 0f       	add	r24, r18
    4d08:	93 1f       	adc	r25, r19
    4d0a:	fc 01       	movw	r30, r24
    4d0c:	bd 96       	adiw	r30, 0x2d	; 45
    4d0e:	80 81       	ld	r24, Z
    4d10:	91 81       	ldd	r25, Z+1	; 0x01
    4d12:	a2 81       	ldd	r26, Z+2	; 0x02
    4d14:	b3 81       	ldd	r27, Z+3	; 0x03
    4d16:	89 83       	std	Y+1, r24	; 0x01
    4d18:	9a 83       	std	Y+2, r25	; 0x02
    4d1a:	ab 83       	std	Y+3, r26	; 0x03
    4d1c:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    4d1e:	89 81       	ldd	r24, Y+1	; 0x01
    4d20:	9a 81       	ldd	r25, Y+2	; 0x02
    4d22:	ab 81       	ldd	r26, Y+3	; 0x03
    4d24:	bc 81       	ldd	r27, Y+4	; 0x04
    4d26:	00 97       	sbiw	r24, 0x00	; 0
    4d28:	a1 05       	cpc	r26, r1
    4d2a:	b1 05       	cpc	r27, r1
    4d2c:	a9 f1       	breq	.+106    	; 0x4d98 <ulTaskGenericNotifyTake+0x150>
            {
                if( xClearCountOnExit != pdFALSE )
    4d2e:	8e 81       	ldd	r24, Y+6	; 0x06
    4d30:	88 23       	and	r24, r24
    4d32:	a1 f0       	breq	.+40     	; 0x4d5c <ulTaskGenericNotifyTake+0x114>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    4d34:	20 91 32 15 	lds	r18, 0x1532
    4d38:	30 91 33 15 	lds	r19, 0x1533
    4d3c:	8d 81       	ldd	r24, Y+5	; 0x05
    4d3e:	88 2f       	mov	r24, r24
    4d40:	90 e0       	ldi	r25, 0x00	; 0
    4d42:	88 0f       	add	r24, r24
    4d44:	99 1f       	adc	r25, r25
    4d46:	88 0f       	add	r24, r24
    4d48:	99 1f       	adc	r25, r25
    4d4a:	82 0f       	add	r24, r18
    4d4c:	93 1f       	adc	r25, r19
    4d4e:	fc 01       	movw	r30, r24
    4d50:	bd 96       	adiw	r30, 0x2d	; 45
    4d52:	10 82       	st	Z, r1
    4d54:	11 82       	std	Z+1, r1	; 0x01
    4d56:	12 82       	std	Z+2, r1	; 0x02
    4d58:	13 82       	std	Z+3, r1	; 0x03
    4d5a:	1e c0       	rjmp	.+60     	; 0x4d98 <ulTaskGenericNotifyTake+0x150>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    4d5c:	e0 91 32 15 	lds	r30, 0x1532
    4d60:	f0 91 33 15 	lds	r31, 0x1533
    4d64:	8d 81       	ldd	r24, Y+5	; 0x05
    4d66:	68 2f       	mov	r22, r24
    4d68:	70 e0       	ldi	r23, 0x00	; 0
    4d6a:	89 81       	ldd	r24, Y+1	; 0x01
    4d6c:	9a 81       	ldd	r25, Y+2	; 0x02
    4d6e:	ab 81       	ldd	r26, Y+3	; 0x03
    4d70:	bc 81       	ldd	r27, Y+4	; 0x04
    4d72:	9c 01       	movw	r18, r24
    4d74:	ad 01       	movw	r20, r26
    4d76:	21 50       	subi	r18, 0x01	; 1
    4d78:	30 40       	sbci	r19, 0x00	; 0
    4d7a:	40 40       	sbci	r20, 0x00	; 0
    4d7c:	50 40       	sbci	r21, 0x00	; 0
    4d7e:	cb 01       	movw	r24, r22
    4d80:	88 0f       	add	r24, r24
    4d82:	99 1f       	adc	r25, r25
    4d84:	88 0f       	add	r24, r24
    4d86:	99 1f       	adc	r25, r25
    4d88:	8e 0f       	add	r24, r30
    4d8a:	9f 1f       	adc	r25, r31
    4d8c:	fc 01       	movw	r30, r24
    4d8e:	bd 96       	adiw	r30, 0x2d	; 45
    4d90:	20 83       	st	Z, r18
    4d92:	31 83       	std	Z+1, r19	; 0x01
    4d94:	42 83       	std	Z+2, r20	; 0x02
    4d96:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4d98:	20 91 32 15 	lds	r18, 0x1532
    4d9c:	30 91 33 15 	lds	r19, 0x1533
    4da0:	8d 81       	ldd	r24, Y+5	; 0x05
    4da2:	88 2f       	mov	r24, r24
    4da4:	90 e0       	ldi	r25, 0x00	; 0
    4da6:	82 0f       	add	r24, r18
    4da8:	93 1f       	adc	r25, r19
    4daa:	fc 01       	movw	r30, r24
    4dac:	f1 96       	adiw	r30, 0x31	; 49
    4dae:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4db0:	0f 90       	pop	r0
    4db2:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    4db4:	89 81       	ldd	r24, Y+1	; 0x01
    4db6:	9a 81       	ldd	r25, Y+2	; 0x02
    4db8:	ab 81       	ldd	r26, Y+3	; 0x03
    4dba:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    4dbc:	bc 01       	movw	r22, r24
    4dbe:	cd 01       	movw	r24, r26
    4dc0:	2a 96       	adiw	r28, 0x0a	; 10
    4dc2:	0f b6       	in	r0, 0x3f	; 63
    4dc4:	f8 94       	cli
    4dc6:	de bf       	out	0x3e, r29	; 62
    4dc8:	0f be       	out	0x3f, r0	; 63
    4dca:	cd bf       	out	0x3d, r28	; 61
    4dcc:	cf 91       	pop	r28
    4dce:	df 91       	pop	r29
    4dd0:	08 95       	ret

00004dd2 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    4dd2:	af 92       	push	r10
    4dd4:	bf 92       	push	r11
    4dd6:	cf 92       	push	r12
    4dd8:	df 92       	push	r13
    4dda:	ef 92       	push	r14
    4ddc:	ff 92       	push	r15
    4dde:	0f 93       	push	r16
    4de0:	1f 93       	push	r17
    4de2:	df 93       	push	r29
    4de4:	cf 93       	push	r28
    4de6:	cd b7       	in	r28, 0x3d	; 61
    4de8:	de b7       	in	r29, 0x3e	; 62
    4dea:	60 97       	sbiw	r28, 0x10	; 16
    4dec:	0f b6       	in	r0, 0x3f	; 63
    4dee:	f8 94       	cli
    4df0:	de bf       	out	0x3e, r29	; 62
    4df2:	0f be       	out	0x3f, r0	; 63
    4df4:	cd bf       	out	0x3d, r28	; 61
    4df6:	8a 83       	std	Y+2, r24	; 0x02
    4df8:	4b 83       	std	Y+3, r20	; 0x03
    4dfa:	5c 83       	std	Y+4, r21	; 0x04
    4dfc:	6d 83       	std	Y+5, r22	; 0x05
    4dfe:	7e 83       	std	Y+6, r23	; 0x06
    4e00:	0f 83       	std	Y+7, r16	; 0x07
    4e02:	18 87       	std	Y+8, r17	; 0x08
    4e04:	29 87       	std	Y+9, r18	; 0x09
    4e06:	3a 87       	std	Y+10, r19	; 0x0a
    4e08:	fc 86       	std	Y+12, r15	; 0x0c
    4e0a:	eb 86       	std	Y+11, r14	; 0x0b
    4e0c:	ad 86       	std	Y+13, r10	; 0x0d
    4e0e:	be 86       	std	Y+14, r11	; 0x0e
    4e10:	cf 86       	std	Y+15, r12	; 0x0f
    4e12:	d8 8a       	std	Y+16, r13	; 0x10
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
    4e14:	8a 81       	ldd	r24, Y+2	; 0x02
    4e16:	88 23       	and	r24, r24
    4e18:	11 f0       	breq	.+4      	; 0x4e1e <xTaskGenericNotifyWait+0x4c>
    4e1a:	f8 94       	cli
    4e1c:	ff cf       	rjmp	.-2      	; 0x4e1c <xTaskGenericNotifyWait+0x4a>

        taskENTER_CRITICAL();
    4e1e:	0f b6       	in	r0, 0x3f	; 63
    4e20:	f8 94       	cli
    4e22:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4e24:	20 91 32 15 	lds	r18, 0x1532
    4e28:	30 91 33 15 	lds	r19, 0x1533
    4e2c:	8a 81       	ldd	r24, Y+2	; 0x02
    4e2e:	88 2f       	mov	r24, r24
    4e30:	90 e0       	ldi	r25, 0x00	; 0
    4e32:	82 0f       	add	r24, r18
    4e34:	93 1f       	adc	r25, r19
    4e36:	fc 01       	movw	r30, r24
    4e38:	f1 96       	adiw	r30, 0x31	; 49
    4e3a:	80 81       	ld	r24, Z
    4e3c:	82 30       	cpi	r24, 0x02	; 2
    4e3e:	09 f4       	brne	.+2      	; 0x4e42 <xTaskGenericNotifyWait+0x70>
    4e40:	4f c0       	rjmp	.+158    	; 0x4ee0 <xTaskGenericNotifyWait+0x10e>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    4e42:	60 91 32 15 	lds	r22, 0x1532
    4e46:	70 91 33 15 	lds	r23, 0x1533
    4e4a:	8a 81       	ldd	r24, Y+2	; 0x02
    4e4c:	08 2f       	mov	r16, r24
    4e4e:	10 e0       	ldi	r17, 0x00	; 0
    4e50:	8a 81       	ldd	r24, Y+2	; 0x02
    4e52:	88 2f       	mov	r24, r24
    4e54:	90 e0       	ldi	r25, 0x00	; 0
    4e56:	88 0f       	add	r24, r24
    4e58:	99 1f       	adc	r25, r25
    4e5a:	88 0f       	add	r24, r24
    4e5c:	99 1f       	adc	r25, r25
    4e5e:	86 0f       	add	r24, r22
    4e60:	97 1f       	adc	r25, r23
    4e62:	fc 01       	movw	r30, r24
    4e64:	bd 96       	adiw	r30, 0x2d	; 45
    4e66:	20 81       	ld	r18, Z
    4e68:	31 81       	ldd	r19, Z+1	; 0x01
    4e6a:	42 81       	ldd	r20, Z+2	; 0x02
    4e6c:	53 81       	ldd	r21, Z+3	; 0x03
    4e6e:	8b 81       	ldd	r24, Y+3	; 0x03
    4e70:	9c 81       	ldd	r25, Y+4	; 0x04
    4e72:	ad 81       	ldd	r26, Y+5	; 0x05
    4e74:	be 81       	ldd	r27, Y+6	; 0x06
    4e76:	80 95       	com	r24
    4e78:	90 95       	com	r25
    4e7a:	a0 95       	com	r26
    4e7c:	b0 95       	com	r27
    4e7e:	28 23       	and	r18, r24
    4e80:	39 23       	and	r19, r25
    4e82:	4a 23       	and	r20, r26
    4e84:	5b 23       	and	r21, r27
    4e86:	c8 01       	movw	r24, r16
    4e88:	88 0f       	add	r24, r24
    4e8a:	99 1f       	adc	r25, r25
    4e8c:	88 0f       	add	r24, r24
    4e8e:	99 1f       	adc	r25, r25
    4e90:	86 0f       	add	r24, r22
    4e92:	97 1f       	adc	r25, r23
    4e94:	fc 01       	movw	r30, r24
    4e96:	bd 96       	adiw	r30, 0x2d	; 45
    4e98:	20 83       	st	Z, r18
    4e9a:	31 83       	std	Z+1, r19	; 0x01
    4e9c:	42 83       	std	Z+2, r20	; 0x02
    4e9e:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4ea0:	20 91 32 15 	lds	r18, 0x1532
    4ea4:	30 91 33 15 	lds	r19, 0x1533
    4ea8:	8a 81       	ldd	r24, Y+2	; 0x02
    4eaa:	88 2f       	mov	r24, r24
    4eac:	90 e0       	ldi	r25, 0x00	; 0
    4eae:	82 0f       	add	r24, r18
    4eb0:	93 1f       	adc	r25, r19
    4eb2:	fc 01       	movw	r30, r24
    4eb4:	f1 96       	adiw	r30, 0x31	; 49
    4eb6:	81 e0       	ldi	r24, 0x01	; 1
    4eb8:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4eba:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ebc:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ebe:	af 85       	ldd	r26, Y+15	; 0x0f
    4ec0:	b8 89       	ldd	r27, Y+16	; 0x10
    4ec2:	00 97       	sbiw	r24, 0x00	; 0
    4ec4:	a1 05       	cpc	r26, r1
    4ec6:	b1 05       	cpc	r27, r1
    4ec8:	59 f0       	breq	.+22     	; 0x4ee0 <xTaskGenericNotifyWait+0x10e>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4eca:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ecc:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ece:	af 85       	ldd	r26, Y+15	; 0x0f
    4ed0:	b8 89       	ldd	r27, Y+16	; 0x10
    4ed2:	bc 01       	movw	r22, r24
    4ed4:	cd 01       	movw	r24, r26
    4ed6:	41 e0       	ldi	r20, 0x01	; 1
    4ed8:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4edc:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4ee0:	0f 90       	pop	r0
    4ee2:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4ee4:	0f b6       	in	r0, 0x3f	; 63
    4ee6:	f8 94       	cli
    4ee8:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    4eea:	8b 85       	ldd	r24, Y+11	; 0x0b
    4eec:	9c 85       	ldd	r25, Y+12	; 0x0c
    4eee:	00 97       	sbiw	r24, 0x00	; 0
    4ef0:	c9 f0       	breq	.+50     	; 0x4f24 <xTaskGenericNotifyWait+0x152>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4ef2:	20 91 32 15 	lds	r18, 0x1532
    4ef6:	30 91 33 15 	lds	r19, 0x1533
    4efa:	8a 81       	ldd	r24, Y+2	; 0x02
    4efc:	88 2f       	mov	r24, r24
    4efe:	90 e0       	ldi	r25, 0x00	; 0
    4f00:	88 0f       	add	r24, r24
    4f02:	99 1f       	adc	r25, r25
    4f04:	88 0f       	add	r24, r24
    4f06:	99 1f       	adc	r25, r25
    4f08:	82 0f       	add	r24, r18
    4f0a:	93 1f       	adc	r25, r19
    4f0c:	fc 01       	movw	r30, r24
    4f0e:	bd 96       	adiw	r30, 0x2d	; 45
    4f10:	80 81       	ld	r24, Z
    4f12:	91 81       	ldd	r25, Z+1	; 0x01
    4f14:	a2 81       	ldd	r26, Z+2	; 0x02
    4f16:	b3 81       	ldd	r27, Z+3	; 0x03
    4f18:	eb 85       	ldd	r30, Y+11	; 0x0b
    4f1a:	fc 85       	ldd	r31, Y+12	; 0x0c
    4f1c:	80 83       	st	Z, r24
    4f1e:	91 83       	std	Z+1, r25	; 0x01
    4f20:	a2 83       	std	Z+2, r26	; 0x02
    4f22:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4f24:	20 91 32 15 	lds	r18, 0x1532
    4f28:	30 91 33 15 	lds	r19, 0x1533
    4f2c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f2e:	88 2f       	mov	r24, r24
    4f30:	90 e0       	ldi	r25, 0x00	; 0
    4f32:	82 0f       	add	r24, r18
    4f34:	93 1f       	adc	r25, r19
    4f36:	fc 01       	movw	r30, r24
    4f38:	f1 96       	adiw	r30, 0x31	; 49
    4f3a:	80 81       	ld	r24, Z
    4f3c:	82 30       	cpi	r24, 0x02	; 2
    4f3e:	11 f0       	breq	.+4      	; 0x4f44 <xTaskGenericNotifyWait+0x172>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    4f40:	19 82       	std	Y+1, r1	; 0x01
    4f42:	31 c0       	rjmp	.+98     	; 0x4fa6 <xTaskGenericNotifyWait+0x1d4>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    4f44:	60 91 32 15 	lds	r22, 0x1532
    4f48:	70 91 33 15 	lds	r23, 0x1533
    4f4c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f4e:	08 2f       	mov	r16, r24
    4f50:	10 e0       	ldi	r17, 0x00	; 0
    4f52:	8a 81       	ldd	r24, Y+2	; 0x02
    4f54:	88 2f       	mov	r24, r24
    4f56:	90 e0       	ldi	r25, 0x00	; 0
    4f58:	88 0f       	add	r24, r24
    4f5a:	99 1f       	adc	r25, r25
    4f5c:	88 0f       	add	r24, r24
    4f5e:	99 1f       	adc	r25, r25
    4f60:	86 0f       	add	r24, r22
    4f62:	97 1f       	adc	r25, r23
    4f64:	fc 01       	movw	r30, r24
    4f66:	bd 96       	adiw	r30, 0x2d	; 45
    4f68:	20 81       	ld	r18, Z
    4f6a:	31 81       	ldd	r19, Z+1	; 0x01
    4f6c:	42 81       	ldd	r20, Z+2	; 0x02
    4f6e:	53 81       	ldd	r21, Z+3	; 0x03
    4f70:	8f 81       	ldd	r24, Y+7	; 0x07
    4f72:	98 85       	ldd	r25, Y+8	; 0x08
    4f74:	a9 85       	ldd	r26, Y+9	; 0x09
    4f76:	ba 85       	ldd	r27, Y+10	; 0x0a
    4f78:	80 95       	com	r24
    4f7a:	90 95       	com	r25
    4f7c:	a0 95       	com	r26
    4f7e:	b0 95       	com	r27
    4f80:	28 23       	and	r18, r24
    4f82:	39 23       	and	r19, r25
    4f84:	4a 23       	and	r20, r26
    4f86:	5b 23       	and	r21, r27
    4f88:	c8 01       	movw	r24, r16
    4f8a:	88 0f       	add	r24, r24
    4f8c:	99 1f       	adc	r25, r25
    4f8e:	88 0f       	add	r24, r24
    4f90:	99 1f       	adc	r25, r25
    4f92:	86 0f       	add	r24, r22
    4f94:	97 1f       	adc	r25, r23
    4f96:	fc 01       	movw	r30, r24
    4f98:	bd 96       	adiw	r30, 0x2d	; 45
    4f9a:	20 83       	st	Z, r18
    4f9c:	31 83       	std	Z+1, r19	; 0x01
    4f9e:	42 83       	std	Z+2, r20	; 0x02
    4fa0:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    4fa2:	81 e0       	ldi	r24, 0x01	; 1
    4fa4:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4fa6:	20 91 32 15 	lds	r18, 0x1532
    4faa:	30 91 33 15 	lds	r19, 0x1533
    4fae:	8a 81       	ldd	r24, Y+2	; 0x02
    4fb0:	88 2f       	mov	r24, r24
    4fb2:	90 e0       	ldi	r25, 0x00	; 0
    4fb4:	82 0f       	add	r24, r18
    4fb6:	93 1f       	adc	r25, r19
    4fb8:	fc 01       	movw	r30, r24
    4fba:	f1 96       	adiw	r30, 0x31	; 49
    4fbc:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4fbe:	0f 90       	pop	r0
    4fc0:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4fc2:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4fc4:	60 96       	adiw	r28, 0x10	; 16
    4fc6:	0f b6       	in	r0, 0x3f	; 63
    4fc8:	f8 94       	cli
    4fca:	de bf       	out	0x3e, r29	; 62
    4fcc:	0f be       	out	0x3f, r0	; 63
    4fce:	cd bf       	out	0x3d, r28	; 61
    4fd0:	cf 91       	pop	r28
    4fd2:	df 91       	pop	r29
    4fd4:	1f 91       	pop	r17
    4fd6:	0f 91       	pop	r16
    4fd8:	ff 90       	pop	r15
    4fda:	ef 90       	pop	r14
    4fdc:	df 90       	pop	r13
    4fde:	cf 90       	pop	r12
    4fe0:	bf 90       	pop	r11
    4fe2:	af 90       	pop	r10
    4fe4:	08 95       	ret

00004fe6 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    4fe6:	ef 92       	push	r14
    4fe8:	ff 92       	push	r15
    4fea:	0f 93       	push	r16
    4fec:	1f 93       	push	r17
    4fee:	df 93       	push	r29
    4ff0:	cf 93       	push	r28
    4ff2:	cd b7       	in	r28, 0x3d	; 61
    4ff4:	de b7       	in	r29, 0x3e	; 62
    4ff6:	64 97       	sbiw	r28, 0x14	; 20
    4ff8:	0f b6       	in	r0, 0x3f	; 63
    4ffa:	f8 94       	cli
    4ffc:	de bf       	out	0x3e, r29	; 62
    4ffe:	0f be       	out	0x3f, r0	; 63
    5000:	cd bf       	out	0x3d, r28	; 61
    5002:	9a 87       	std	Y+10, r25	; 0x0a
    5004:	89 87       	std	Y+9, r24	; 0x09
    5006:	6b 87       	std	Y+11, r22	; 0x0b
    5008:	2c 87       	std	Y+12, r18	; 0x0c
    500a:	3d 87       	std	Y+13, r19	; 0x0d
    500c:	4e 87       	std	Y+14, r20	; 0x0e
    500e:	5f 87       	std	Y+15, r21	; 0x0f
    5010:	08 8b       	std	Y+16, r16	; 0x10
    5012:	fa 8a       	std	Y+18, r15	; 0x12
    5014:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    5016:	81 e0       	ldi	r24, 0x01	; 1
    5018:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
    501a:	8b 85       	ldd	r24, Y+11	; 0x0b
    501c:	88 23       	and	r24, r24
    501e:	11 f0       	breq	.+4      	; 0x5024 <xTaskGenericNotify+0x3e>
    5020:	f8 94       	cli
    5022:	ff cf       	rjmp	.-2      	; 0x5022 <xTaskGenericNotify+0x3c>
        configASSERT( xTaskToNotify );
    5024:	89 85       	ldd	r24, Y+9	; 0x09
    5026:	9a 85       	ldd	r25, Y+10	; 0x0a
    5028:	00 97       	sbiw	r24, 0x00	; 0
    502a:	11 f4       	brne	.+4      	; 0x5030 <xTaskGenericNotify+0x4a>
    502c:	f8 94       	cli
    502e:	ff cf       	rjmp	.-2      	; 0x502e <xTaskGenericNotify+0x48>
        pxTCB = xTaskToNotify;
    5030:	89 85       	ldd	r24, Y+9	; 0x09
    5032:	9a 85       	ldd	r25, Y+10	; 0x0a
    5034:	98 87       	std	Y+8, r25	; 0x08
    5036:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    5038:	0f b6       	in	r0, 0x3f	; 63
    503a:	f8 94       	cli
    503c:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    503e:	89 89       	ldd	r24, Y+17	; 0x11
    5040:	9a 89       	ldd	r25, Y+18	; 0x12
    5042:	00 97       	sbiw	r24, 0x00	; 0
    5044:	b9 f0       	breq	.+46     	; 0x5074 <xTaskGenericNotify+0x8e>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    5046:	8b 85       	ldd	r24, Y+11	; 0x0b
    5048:	88 2f       	mov	r24, r24
    504a:	90 e0       	ldi	r25, 0x00	; 0
    504c:	2f 81       	ldd	r18, Y+7	; 0x07
    504e:	38 85       	ldd	r19, Y+8	; 0x08
    5050:	88 0f       	add	r24, r24
    5052:	99 1f       	adc	r25, r25
    5054:	88 0f       	add	r24, r24
    5056:	99 1f       	adc	r25, r25
    5058:	82 0f       	add	r24, r18
    505a:	93 1f       	adc	r25, r19
    505c:	fc 01       	movw	r30, r24
    505e:	bd 96       	adiw	r30, 0x2d	; 45
    5060:	80 81       	ld	r24, Z
    5062:	91 81       	ldd	r25, Z+1	; 0x01
    5064:	a2 81       	ldd	r26, Z+2	; 0x02
    5066:	b3 81       	ldd	r27, Z+3	; 0x03
    5068:	e9 89       	ldd	r30, Y+17	; 0x11
    506a:	fa 89       	ldd	r31, Y+18	; 0x12
    506c:	80 83       	st	Z, r24
    506e:	91 83       	std	Z+1, r25	; 0x01
    5070:	a2 83       	std	Z+2, r26	; 0x02
    5072:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5074:	8b 85       	ldd	r24, Y+11	; 0x0b
    5076:	28 2f       	mov	r18, r24
    5078:	30 e0       	ldi	r19, 0x00	; 0
    507a:	8f 81       	ldd	r24, Y+7	; 0x07
    507c:	98 85       	ldd	r25, Y+8	; 0x08
    507e:	82 0f       	add	r24, r18
    5080:	93 1f       	adc	r25, r19
    5082:	fc 01       	movw	r30, r24
    5084:	f1 96       	adiw	r30, 0x31	; 49
    5086:	80 81       	ld	r24, Z
    5088:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    508a:	8b 85       	ldd	r24, Y+11	; 0x0b
    508c:	28 2f       	mov	r18, r24
    508e:	30 e0       	ldi	r19, 0x00	; 0
    5090:	8f 81       	ldd	r24, Y+7	; 0x07
    5092:	98 85       	ldd	r25, Y+8	; 0x08
    5094:	82 0f       	add	r24, r18
    5096:	93 1f       	adc	r25, r19
    5098:	fc 01       	movw	r30, r24
    509a:	f1 96       	adiw	r30, 0x31	; 49
    509c:	82 e0       	ldi	r24, 0x02	; 2
    509e:	80 83       	st	Z, r24

            switch( eAction )
    50a0:	88 89       	ldd	r24, Y+16	; 0x10
    50a2:	28 2f       	mov	r18, r24
    50a4:	30 e0       	ldi	r19, 0x00	; 0
    50a6:	3c 8b       	std	Y+20, r19	; 0x14
    50a8:	2b 8b       	std	Y+19, r18	; 0x13
    50aa:	8b 89       	ldd	r24, Y+19	; 0x13
    50ac:	9c 89       	ldd	r25, Y+20	; 0x14
    50ae:	82 30       	cpi	r24, 0x02	; 2
    50b0:	91 05       	cpc	r25, r1
    50b2:	09 f4       	brne	.+2      	; 0x50b6 <xTaskGenericNotify+0xd0>
    50b4:	4b c0       	rjmp	.+150    	; 0x514c <xTaskGenericNotify+0x166>
    50b6:	2b 89       	ldd	r18, Y+19	; 0x13
    50b8:	3c 89       	ldd	r19, Y+20	; 0x14
    50ba:	23 30       	cpi	r18, 0x03	; 3
    50bc:	31 05       	cpc	r19, r1
    50be:	5c f4       	brge	.+22     	; 0x50d6 <xTaskGenericNotify+0xf0>
    50c0:	8b 89       	ldd	r24, Y+19	; 0x13
    50c2:	9c 89       	ldd	r25, Y+20	; 0x14
    50c4:	00 97       	sbiw	r24, 0x00	; 0
    50c6:	09 f4       	brne	.+2      	; 0x50ca <xTaskGenericNotify+0xe4>
    50c8:	a8 c0       	rjmp	.+336    	; 0x521a <xTaskGenericNotify+0x234>
    50ca:	2b 89       	ldd	r18, Y+19	; 0x13
    50cc:	3c 89       	ldd	r19, Y+20	; 0x14
    50ce:	21 30       	cpi	r18, 0x01	; 1
    50d0:	31 05       	cpc	r19, r1
    50d2:	71 f0       	breq	.+28     	; 0x50f0 <xTaskGenericNotify+0x10a>
    50d4:	94 c0       	rjmp	.+296    	; 0x51fe <xTaskGenericNotify+0x218>
    50d6:	8b 89       	ldd	r24, Y+19	; 0x13
    50d8:	9c 89       	ldd	r25, Y+20	; 0x14
    50da:	83 30       	cpi	r24, 0x03	; 3
    50dc:	91 05       	cpc	r25, r1
    50de:	09 f4       	brne	.+2      	; 0x50e2 <xTaskGenericNotify+0xfc>
    50e0:	5d c0       	rjmp	.+186    	; 0x519c <xTaskGenericNotify+0x1b6>
    50e2:	2b 89       	ldd	r18, Y+19	; 0x13
    50e4:	3c 89       	ldd	r19, Y+20	; 0x14
    50e6:	24 30       	cpi	r18, 0x04	; 4
    50e8:	31 05       	cpc	r19, r1
    50ea:	09 f4       	brne	.+2      	; 0x50ee <xTaskGenericNotify+0x108>
    50ec:	6d c0       	rjmp	.+218    	; 0x51c8 <xTaskGenericNotify+0x1e2>
    50ee:	87 c0       	rjmp	.+270    	; 0x51fe <xTaskGenericNotify+0x218>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    50f0:	8b 85       	ldd	r24, Y+11	; 0x0b
    50f2:	08 2f       	mov	r16, r24
    50f4:	10 e0       	ldi	r17, 0x00	; 0
    50f6:	8b 85       	ldd	r24, Y+11	; 0x0b
    50f8:	88 2f       	mov	r24, r24
    50fa:	90 e0       	ldi	r25, 0x00	; 0
    50fc:	2f 81       	ldd	r18, Y+7	; 0x07
    50fe:	38 85       	ldd	r19, Y+8	; 0x08
    5100:	88 0f       	add	r24, r24
    5102:	99 1f       	adc	r25, r25
    5104:	88 0f       	add	r24, r24
    5106:	99 1f       	adc	r25, r25
    5108:	82 0f       	add	r24, r18
    510a:	93 1f       	adc	r25, r19
    510c:	fc 01       	movw	r30, r24
    510e:	bd 96       	adiw	r30, 0x2d	; 45
    5110:	20 81       	ld	r18, Z
    5112:	31 81       	ldd	r19, Z+1	; 0x01
    5114:	42 81       	ldd	r20, Z+2	; 0x02
    5116:	53 81       	ldd	r21, Z+3	; 0x03
    5118:	8c 85       	ldd	r24, Y+12	; 0x0c
    511a:	9d 85       	ldd	r25, Y+13	; 0x0d
    511c:	ae 85       	ldd	r26, Y+14	; 0x0e
    511e:	bf 85       	ldd	r27, Y+15	; 0x0f
    5120:	ba 01       	movw	r22, r20
    5122:	a9 01       	movw	r20, r18
    5124:	48 2b       	or	r20, r24
    5126:	59 2b       	or	r21, r25
    5128:	6a 2b       	or	r22, r26
    512a:	7b 2b       	or	r23, r27
    512c:	2f 81       	ldd	r18, Y+7	; 0x07
    512e:	38 85       	ldd	r19, Y+8	; 0x08
    5130:	c8 01       	movw	r24, r16
    5132:	88 0f       	add	r24, r24
    5134:	99 1f       	adc	r25, r25
    5136:	88 0f       	add	r24, r24
    5138:	99 1f       	adc	r25, r25
    513a:	82 0f       	add	r24, r18
    513c:	93 1f       	adc	r25, r19
    513e:	fc 01       	movw	r30, r24
    5140:	bd 96       	adiw	r30, 0x2d	; 45
    5142:	40 83       	st	Z, r20
    5144:	51 83       	std	Z+1, r21	; 0x01
    5146:	62 83       	std	Z+2, r22	; 0x02
    5148:	73 83       	std	Z+3, r23	; 0x03
    514a:	67 c0       	rjmp	.+206    	; 0x521a <xTaskGenericNotify+0x234>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    514c:	8b 85       	ldd	r24, Y+11	; 0x0b
    514e:	08 2f       	mov	r16, r24
    5150:	10 e0       	ldi	r17, 0x00	; 0
    5152:	2f 81       	ldd	r18, Y+7	; 0x07
    5154:	38 85       	ldd	r19, Y+8	; 0x08
    5156:	c8 01       	movw	r24, r16
    5158:	88 0f       	add	r24, r24
    515a:	99 1f       	adc	r25, r25
    515c:	88 0f       	add	r24, r24
    515e:	99 1f       	adc	r25, r25
    5160:	82 0f       	add	r24, r18
    5162:	93 1f       	adc	r25, r19
    5164:	fc 01       	movw	r30, r24
    5166:	bd 96       	adiw	r30, 0x2d	; 45
    5168:	80 81       	ld	r24, Z
    516a:	91 81       	ldd	r25, Z+1	; 0x01
    516c:	a2 81       	ldd	r26, Z+2	; 0x02
    516e:	b3 81       	ldd	r27, Z+3	; 0x03
    5170:	ac 01       	movw	r20, r24
    5172:	bd 01       	movw	r22, r26
    5174:	4f 5f       	subi	r20, 0xFF	; 255
    5176:	5f 4f       	sbci	r21, 0xFF	; 255
    5178:	6f 4f       	sbci	r22, 0xFF	; 255
    517a:	7f 4f       	sbci	r23, 0xFF	; 255
    517c:	2f 81       	ldd	r18, Y+7	; 0x07
    517e:	38 85       	ldd	r19, Y+8	; 0x08
    5180:	c8 01       	movw	r24, r16
    5182:	88 0f       	add	r24, r24
    5184:	99 1f       	adc	r25, r25
    5186:	88 0f       	add	r24, r24
    5188:	99 1f       	adc	r25, r25
    518a:	82 0f       	add	r24, r18
    518c:	93 1f       	adc	r25, r19
    518e:	fc 01       	movw	r30, r24
    5190:	bd 96       	adiw	r30, 0x2d	; 45
    5192:	40 83       	st	Z, r20
    5194:	51 83       	std	Z+1, r21	; 0x01
    5196:	62 83       	std	Z+2, r22	; 0x02
    5198:	73 83       	std	Z+3, r23	; 0x03
    519a:	3f c0       	rjmp	.+126    	; 0x521a <xTaskGenericNotify+0x234>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    519c:	8b 85       	ldd	r24, Y+11	; 0x0b
    519e:	88 2f       	mov	r24, r24
    51a0:	90 e0       	ldi	r25, 0x00	; 0
    51a2:	2f 81       	ldd	r18, Y+7	; 0x07
    51a4:	38 85       	ldd	r19, Y+8	; 0x08
    51a6:	88 0f       	add	r24, r24
    51a8:	99 1f       	adc	r25, r25
    51aa:	88 0f       	add	r24, r24
    51ac:	99 1f       	adc	r25, r25
    51ae:	82 0f       	add	r24, r18
    51b0:	93 1f       	adc	r25, r19
    51b2:	fc 01       	movw	r30, r24
    51b4:	bd 96       	adiw	r30, 0x2d	; 45
    51b6:	8c 85       	ldd	r24, Y+12	; 0x0c
    51b8:	9d 85       	ldd	r25, Y+13	; 0x0d
    51ba:	ae 85       	ldd	r26, Y+14	; 0x0e
    51bc:	bf 85       	ldd	r27, Y+15	; 0x0f
    51be:	80 83       	st	Z, r24
    51c0:	91 83       	std	Z+1, r25	; 0x01
    51c2:	a2 83       	std	Z+2, r26	; 0x02
    51c4:	b3 83       	std	Z+3, r27	; 0x03
    51c6:	29 c0       	rjmp	.+82     	; 0x521a <xTaskGenericNotify+0x234>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    51c8:	8d 81       	ldd	r24, Y+5	; 0x05
    51ca:	82 30       	cpi	r24, 0x02	; 2
    51cc:	b1 f0       	breq	.+44     	; 0x51fa <xTaskGenericNotify+0x214>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    51ce:	8b 85       	ldd	r24, Y+11	; 0x0b
    51d0:	88 2f       	mov	r24, r24
    51d2:	90 e0       	ldi	r25, 0x00	; 0
    51d4:	2f 81       	ldd	r18, Y+7	; 0x07
    51d6:	38 85       	ldd	r19, Y+8	; 0x08
    51d8:	88 0f       	add	r24, r24
    51da:	99 1f       	adc	r25, r25
    51dc:	88 0f       	add	r24, r24
    51de:	99 1f       	adc	r25, r25
    51e0:	82 0f       	add	r24, r18
    51e2:	93 1f       	adc	r25, r19
    51e4:	fc 01       	movw	r30, r24
    51e6:	bd 96       	adiw	r30, 0x2d	; 45
    51e8:	8c 85       	ldd	r24, Y+12	; 0x0c
    51ea:	9d 85       	ldd	r25, Y+13	; 0x0d
    51ec:	ae 85       	ldd	r26, Y+14	; 0x0e
    51ee:	bf 85       	ldd	r27, Y+15	; 0x0f
    51f0:	80 83       	st	Z, r24
    51f2:	91 83       	std	Z+1, r25	; 0x01
    51f4:	a2 83       	std	Z+2, r26	; 0x02
    51f6:	b3 83       	std	Z+3, r27	; 0x03
    51f8:	10 c0       	rjmp	.+32     	; 0x521a <xTaskGenericNotify+0x234>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    51fa:	1e 82       	std	Y+6, r1	; 0x06
    51fc:	0e c0       	rjmp	.+28     	; 0x521a <xTaskGenericNotify+0x234>
                default:

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
    51fe:	80 91 35 15 	lds	r24, 0x1535
    5202:	90 91 36 15 	lds	r25, 0x1536
    5206:	a0 91 37 15 	lds	r26, 0x1537
    520a:	b0 91 38 15 	lds	r27, 0x1538
    520e:	00 97       	sbiw	r24, 0x00	; 0
    5210:	a1 05       	cpc	r26, r1
    5212:	b1 05       	cpc	r27, r1
    5214:	11 f0       	breq	.+4      	; 0x521a <xTaskGenericNotify+0x234>
    5216:	f8 94       	cli
    5218:	ff cf       	rjmp	.-2      	; 0x5218 <xTaskGenericNotify+0x232>

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    521a:	8d 81       	ldd	r24, Y+5	; 0x05
    521c:	81 30       	cpi	r24, 0x01	; 1
    521e:	09 f0       	breq	.+2      	; 0x5222 <xTaskGenericNotify+0x23c>
    5220:	c0 c0       	rjmp	.+384    	; 0x53a2 <xTaskGenericNotify+0x3bc>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5222:	ef 81       	ldd	r30, Y+7	; 0x07
    5224:	f8 85       	ldd	r31, Y+8	; 0x08
    5226:	84 85       	ldd	r24, Z+12	; 0x0c
    5228:	95 85       	ldd	r25, Z+13	; 0x0d
    522a:	9c 83       	std	Y+4, r25	; 0x04
    522c:	8b 83       	std	Y+3, r24	; 0x03
    522e:	ef 81       	ldd	r30, Y+7	; 0x07
    5230:	f8 85       	ldd	r31, Y+8	; 0x08
    5232:	a6 81       	ldd	r26, Z+6	; 0x06
    5234:	b7 81       	ldd	r27, Z+7	; 0x07
    5236:	ef 81       	ldd	r30, Y+7	; 0x07
    5238:	f8 85       	ldd	r31, Y+8	; 0x08
    523a:	80 85       	ldd	r24, Z+8	; 0x08
    523c:	91 85       	ldd	r25, Z+9	; 0x09
    523e:	17 96       	adiw	r26, 0x07	; 7
    5240:	9c 93       	st	X, r25
    5242:	8e 93       	st	-X, r24
    5244:	16 97       	sbiw	r26, 0x06	; 6
    5246:	ef 81       	ldd	r30, Y+7	; 0x07
    5248:	f8 85       	ldd	r31, Y+8	; 0x08
    524a:	a0 85       	ldd	r26, Z+8	; 0x08
    524c:	b1 85       	ldd	r27, Z+9	; 0x09
    524e:	ef 81       	ldd	r30, Y+7	; 0x07
    5250:	f8 85       	ldd	r31, Y+8	; 0x08
    5252:	86 81       	ldd	r24, Z+6	; 0x06
    5254:	97 81       	ldd	r25, Z+7	; 0x07
    5256:	15 96       	adiw	r26, 0x05	; 5
    5258:	9c 93       	st	X, r25
    525a:	8e 93       	st	-X, r24
    525c:	14 97       	sbiw	r26, 0x04	; 4
    525e:	eb 81       	ldd	r30, Y+3	; 0x03
    5260:	fc 81       	ldd	r31, Y+4	; 0x04
    5262:	21 81       	ldd	r18, Z+1	; 0x01
    5264:	32 81       	ldd	r19, Z+2	; 0x02
    5266:	8f 81       	ldd	r24, Y+7	; 0x07
    5268:	98 85       	ldd	r25, Y+8	; 0x08
    526a:	02 96       	adiw	r24, 0x02	; 2
    526c:	28 17       	cp	r18, r24
    526e:	39 07       	cpc	r19, r25
    5270:	41 f4       	brne	.+16     	; 0x5282 <xTaskGenericNotify+0x29c>
    5272:	ef 81       	ldd	r30, Y+7	; 0x07
    5274:	f8 85       	ldd	r31, Y+8	; 0x08
    5276:	80 85       	ldd	r24, Z+8	; 0x08
    5278:	91 85       	ldd	r25, Z+9	; 0x09
    527a:	eb 81       	ldd	r30, Y+3	; 0x03
    527c:	fc 81       	ldd	r31, Y+4	; 0x04
    527e:	92 83       	std	Z+2, r25	; 0x02
    5280:	81 83       	std	Z+1, r24	; 0x01
    5282:	ef 81       	ldd	r30, Y+7	; 0x07
    5284:	f8 85       	ldd	r31, Y+8	; 0x08
    5286:	15 86       	std	Z+13, r1	; 0x0d
    5288:	14 86       	std	Z+12, r1	; 0x0c
    528a:	eb 81       	ldd	r30, Y+3	; 0x03
    528c:	fc 81       	ldd	r31, Y+4	; 0x04
    528e:	80 81       	ld	r24, Z
    5290:	81 50       	subi	r24, 0x01	; 1
    5292:	eb 81       	ldd	r30, Y+3	; 0x03
    5294:	fc 81       	ldd	r31, Y+4	; 0x04
    5296:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    5298:	ef 81       	ldd	r30, Y+7	; 0x07
    529a:	f8 85       	ldd	r31, Y+8	; 0x08
    529c:	92 8d       	ldd	r25, Z+26	; 0x1a
    529e:	80 91 39 15 	lds	r24, 0x1539
    52a2:	89 17       	cp	r24, r25
    52a4:	28 f4       	brcc	.+10     	; 0x52b0 <xTaskGenericNotify+0x2ca>
    52a6:	ef 81       	ldd	r30, Y+7	; 0x07
    52a8:	f8 85       	ldd	r31, Y+8	; 0x08
    52aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    52ac:	80 93 39 15 	sts	0x1539, r24
    52b0:	ef 81       	ldd	r30, Y+7	; 0x07
    52b2:	f8 85       	ldd	r31, Y+8	; 0x08
    52b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    52b6:	48 2f       	mov	r20, r24
    52b8:	50 e0       	ldi	r21, 0x00	; 0
    52ba:	ca 01       	movw	r24, r20
    52bc:	88 0f       	add	r24, r24
    52be:	99 1f       	adc	r25, r25
    52c0:	9c 01       	movw	r18, r24
    52c2:	22 0f       	add	r18, r18
    52c4:	33 1f       	adc	r19, r19
    52c6:	22 0f       	add	r18, r18
    52c8:	33 1f       	adc	r19, r19
    52ca:	82 0f       	add	r24, r18
    52cc:	93 1f       	adc	r25, r19
    52ce:	84 0f       	add	r24, r20
    52d0:	95 1f       	adc	r25, r21
    52d2:	fc 01       	movw	r30, r24
    52d4:	e7 5b       	subi	r30, 0xB7	; 183
    52d6:	fa 4e       	sbci	r31, 0xEA	; 234
    52d8:	81 81       	ldd	r24, Z+1	; 0x01
    52da:	92 81       	ldd	r25, Z+2	; 0x02
    52dc:	9a 83       	std	Y+2, r25	; 0x02
    52de:	89 83       	std	Y+1, r24	; 0x01
    52e0:	ef 81       	ldd	r30, Y+7	; 0x07
    52e2:	f8 85       	ldd	r31, Y+8	; 0x08
    52e4:	89 81       	ldd	r24, Y+1	; 0x01
    52e6:	9a 81       	ldd	r25, Y+2	; 0x02
    52e8:	97 83       	std	Z+7, r25	; 0x07
    52ea:	86 83       	std	Z+6, r24	; 0x06
    52ec:	e9 81       	ldd	r30, Y+1	; 0x01
    52ee:	fa 81       	ldd	r31, Y+2	; 0x02
    52f0:	86 81       	ldd	r24, Z+6	; 0x06
    52f2:	97 81       	ldd	r25, Z+7	; 0x07
    52f4:	ef 81       	ldd	r30, Y+7	; 0x07
    52f6:	f8 85       	ldd	r31, Y+8	; 0x08
    52f8:	91 87       	std	Z+9, r25	; 0x09
    52fa:	80 87       	std	Z+8, r24	; 0x08
    52fc:	e9 81       	ldd	r30, Y+1	; 0x01
    52fe:	fa 81       	ldd	r31, Y+2	; 0x02
    5300:	06 80       	ldd	r0, Z+6	; 0x06
    5302:	f7 81       	ldd	r31, Z+7	; 0x07
    5304:	e0 2d       	mov	r30, r0
    5306:	8f 81       	ldd	r24, Y+7	; 0x07
    5308:	98 85       	ldd	r25, Y+8	; 0x08
    530a:	02 96       	adiw	r24, 0x02	; 2
    530c:	95 83       	std	Z+5, r25	; 0x05
    530e:	84 83       	std	Z+4, r24	; 0x04
    5310:	8f 81       	ldd	r24, Y+7	; 0x07
    5312:	98 85       	ldd	r25, Y+8	; 0x08
    5314:	02 96       	adiw	r24, 0x02	; 2
    5316:	e9 81       	ldd	r30, Y+1	; 0x01
    5318:	fa 81       	ldd	r31, Y+2	; 0x02
    531a:	97 83       	std	Z+7, r25	; 0x07
    531c:	86 83       	std	Z+6, r24	; 0x06
    531e:	ef 81       	ldd	r30, Y+7	; 0x07
    5320:	f8 85       	ldd	r31, Y+8	; 0x08
    5322:	82 8d       	ldd	r24, Z+26	; 0x1a
    5324:	48 2f       	mov	r20, r24
    5326:	50 e0       	ldi	r21, 0x00	; 0
    5328:	ca 01       	movw	r24, r20
    532a:	88 0f       	add	r24, r24
    532c:	99 1f       	adc	r25, r25
    532e:	9c 01       	movw	r18, r24
    5330:	22 0f       	add	r18, r18
    5332:	33 1f       	adc	r19, r19
    5334:	22 0f       	add	r18, r18
    5336:	33 1f       	adc	r19, r19
    5338:	82 0f       	add	r24, r18
    533a:	93 1f       	adc	r25, r19
    533c:	84 0f       	add	r24, r20
    533e:	95 1f       	adc	r25, r21
    5340:	87 5b       	subi	r24, 0xB7	; 183
    5342:	9a 4e       	sbci	r25, 0xEA	; 234
    5344:	ef 81       	ldd	r30, Y+7	; 0x07
    5346:	f8 85       	ldd	r31, Y+8	; 0x08
    5348:	95 87       	std	Z+13, r25	; 0x0d
    534a:	84 87       	std	Z+12, r24	; 0x0c
    534c:	ef 81       	ldd	r30, Y+7	; 0x07
    534e:	f8 85       	ldd	r31, Y+8	; 0x08
    5350:	82 8d       	ldd	r24, Z+26	; 0x1a
    5352:	48 2f       	mov	r20, r24
    5354:	50 e0       	ldi	r21, 0x00	; 0
    5356:	ca 01       	movw	r24, r20
    5358:	88 0f       	add	r24, r24
    535a:	99 1f       	adc	r25, r25
    535c:	9c 01       	movw	r18, r24
    535e:	22 0f       	add	r18, r18
    5360:	33 1f       	adc	r19, r19
    5362:	22 0f       	add	r18, r18
    5364:	33 1f       	adc	r19, r19
    5366:	82 0f       	add	r24, r18
    5368:	93 1f       	adc	r25, r19
    536a:	84 0f       	add	r24, r20
    536c:	95 1f       	adc	r25, r21
    536e:	fc 01       	movw	r30, r24
    5370:	e7 5b       	subi	r30, 0xB7	; 183
    5372:	fa 4e       	sbci	r31, 0xEA	; 234
    5374:	80 81       	ld	r24, Z
    5376:	8f 5f       	subi	r24, 0xFF	; 255
    5378:	80 83       	st	Z, r24

                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
    537a:	ef 81       	ldd	r30, Y+7	; 0x07
    537c:	f8 85       	ldd	r31, Y+8	; 0x08
    537e:	80 8d       	ldd	r24, Z+24	; 0x18
    5380:	91 8d       	ldd	r25, Z+25	; 0x19
    5382:	00 97       	sbiw	r24, 0x00	; 0
    5384:	11 f0       	breq	.+4      	; 0x538a <xTaskGenericNotify+0x3a4>
    5386:	f8 94       	cli
    5388:	ff cf       	rjmp	.-2      	; 0x5388 <xTaskGenericNotify+0x3a2>
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    538a:	ef 81       	ldd	r30, Y+7	; 0x07
    538c:	f8 85       	ldd	r31, Y+8	; 0x08
    538e:	92 8d       	ldd	r25, Z+26	; 0x1a
    5390:	e0 91 32 15 	lds	r30, 0x1532
    5394:	f0 91 33 15 	lds	r31, 0x1533
    5398:	82 8d       	ldd	r24, Z+26	; 0x1a
    539a:	89 17       	cp	r24, r25
    539c:	10 f4       	brcc	.+4      	; 0x53a2 <xTaskGenericNotify+0x3bc>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    539e:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    53a2:	0f 90       	pop	r0
    53a4:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    53a6:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    53a8:	64 96       	adiw	r28, 0x14	; 20
    53aa:	0f b6       	in	r0, 0x3f	; 63
    53ac:	f8 94       	cli
    53ae:	de bf       	out	0x3e, r29	; 62
    53b0:	0f be       	out	0x3f, r0	; 63
    53b2:	cd bf       	out	0x3d, r28	; 61
    53b4:	cf 91       	pop	r28
    53b6:	df 91       	pop	r29
    53b8:	1f 91       	pop	r17
    53ba:	0f 91       	pop	r16
    53bc:	ff 90       	pop	r15
    53be:	ef 90       	pop	r14
    53c0:	08 95       	ret

000053c2 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    53c2:	cf 92       	push	r12
    53c4:	df 92       	push	r13
    53c6:	ef 92       	push	r14
    53c8:	ff 92       	push	r15
    53ca:	0f 93       	push	r16
    53cc:	1f 93       	push	r17
    53ce:	df 93       	push	r29
    53d0:	cf 93       	push	r28
    53d2:	cd b7       	in	r28, 0x3d	; 61
    53d4:	de b7       	in	r29, 0x3e	; 62
    53d6:	69 97       	sbiw	r28, 0x19	; 25
    53d8:	0f b6       	in	r0, 0x3f	; 63
    53da:	f8 94       	cli
    53dc:	de bf       	out	0x3e, r29	; 62
    53de:	0f be       	out	0x3f, r0	; 63
    53e0:	cd bf       	out	0x3d, r28	; 61
    53e2:	9d 87       	std	Y+13, r25	; 0x0d
    53e4:	8c 87       	std	Y+12, r24	; 0x0c
    53e6:	6e 87       	std	Y+14, r22	; 0x0e
    53e8:	2f 87       	std	Y+15, r18	; 0x0f
    53ea:	38 8b       	std	Y+16, r19	; 0x10
    53ec:	49 8b       	std	Y+17, r20	; 0x11
    53ee:	5a 8b       	std	Y+18, r21	; 0x12
    53f0:	0b 8b       	std	Y+19, r16	; 0x13
    53f2:	fd 8a       	std	Y+21, r15	; 0x15
    53f4:	ec 8a       	std	Y+20, r14	; 0x14
    53f6:	df 8a       	std	Y+23, r13	; 0x17
    53f8:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    53fa:	81 e0       	ldi	r24, 0x01	; 1
    53fc:	88 87       	std	Y+8, r24	; 0x08
        UBaseType_t uxSavedInterruptStatus;

        configASSERT( xTaskToNotify );
    53fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    5400:	9d 85       	ldd	r25, Y+13	; 0x0d
    5402:	00 97       	sbiw	r24, 0x00	; 0
    5404:	11 f4       	brne	.+4      	; 0x540a <xTaskGenericNotifyFromISR+0x48>
    5406:	f8 94       	cli
    5408:	ff cf       	rjmp	.-2      	; 0x5408 <xTaskGenericNotifyFromISR+0x46>
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
    540a:	8e 85       	ldd	r24, Y+14	; 0x0e
    540c:	88 23       	and	r24, r24
    540e:	11 f0       	breq	.+4      	; 0x5414 <xTaskGenericNotifyFromISR+0x52>
    5410:	f8 94       	cli
    5412:	ff cf       	rjmp	.-2      	; 0x5412 <xTaskGenericNotifyFromISR+0x50>
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    5414:	8c 85       	ldd	r24, Y+12	; 0x0c
    5416:	9d 85       	ldd	r25, Y+13	; 0x0d
    5418:	9b 87       	std	Y+11, r25	; 0x0b
    541a:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    541c:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    541e:	8c 89       	ldd	r24, Y+20	; 0x14
    5420:	9d 89       	ldd	r25, Y+21	; 0x15
    5422:	00 97       	sbiw	r24, 0x00	; 0
    5424:	b9 f0       	breq	.+46     	; 0x5454 <xTaskGenericNotifyFromISR+0x92>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    5426:	8e 85       	ldd	r24, Y+14	; 0x0e
    5428:	88 2f       	mov	r24, r24
    542a:	90 e0       	ldi	r25, 0x00	; 0
    542c:	2a 85       	ldd	r18, Y+10	; 0x0a
    542e:	3b 85       	ldd	r19, Y+11	; 0x0b
    5430:	88 0f       	add	r24, r24
    5432:	99 1f       	adc	r25, r25
    5434:	88 0f       	add	r24, r24
    5436:	99 1f       	adc	r25, r25
    5438:	82 0f       	add	r24, r18
    543a:	93 1f       	adc	r25, r19
    543c:	fc 01       	movw	r30, r24
    543e:	bd 96       	adiw	r30, 0x2d	; 45
    5440:	80 81       	ld	r24, Z
    5442:	91 81       	ldd	r25, Z+1	; 0x01
    5444:	a2 81       	ldd	r26, Z+2	; 0x02
    5446:	b3 81       	ldd	r27, Z+3	; 0x03
    5448:	ec 89       	ldd	r30, Y+20	; 0x14
    544a:	fd 89       	ldd	r31, Y+21	; 0x15
    544c:	80 83       	st	Z, r24
    544e:	91 83       	std	Z+1, r25	; 0x01
    5450:	a2 83       	std	Z+2, r26	; 0x02
    5452:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5454:	8e 85       	ldd	r24, Y+14	; 0x0e
    5456:	28 2f       	mov	r18, r24
    5458:	30 e0       	ldi	r19, 0x00	; 0
    545a:	8a 85       	ldd	r24, Y+10	; 0x0a
    545c:	9b 85       	ldd	r25, Y+11	; 0x0b
    545e:	82 0f       	add	r24, r18
    5460:	93 1f       	adc	r25, r19
    5462:	fc 01       	movw	r30, r24
    5464:	f1 96       	adiw	r30, 0x31	; 49
    5466:	80 81       	ld	r24, Z
    5468:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    546a:	8e 85       	ldd	r24, Y+14	; 0x0e
    546c:	28 2f       	mov	r18, r24
    546e:	30 e0       	ldi	r19, 0x00	; 0
    5470:	8a 85       	ldd	r24, Y+10	; 0x0a
    5472:	9b 85       	ldd	r25, Y+11	; 0x0b
    5474:	82 0f       	add	r24, r18
    5476:	93 1f       	adc	r25, r19
    5478:	fc 01       	movw	r30, r24
    547a:	f1 96       	adiw	r30, 0x31	; 49
    547c:	82 e0       	ldi	r24, 0x02	; 2
    547e:	80 83       	st	Z, r24

            switch( eAction )
    5480:	8b 89       	ldd	r24, Y+19	; 0x13
    5482:	28 2f       	mov	r18, r24
    5484:	30 e0       	ldi	r19, 0x00	; 0
    5486:	39 8f       	std	Y+25, r19	; 0x19
    5488:	28 8f       	std	Y+24, r18	; 0x18
    548a:	88 8d       	ldd	r24, Y+24	; 0x18
    548c:	99 8d       	ldd	r25, Y+25	; 0x19
    548e:	82 30       	cpi	r24, 0x02	; 2
    5490:	91 05       	cpc	r25, r1
    5492:	09 f4       	brne	.+2      	; 0x5496 <xTaskGenericNotifyFromISR+0xd4>
    5494:	4b c0       	rjmp	.+150    	; 0x552c <xTaskGenericNotifyFromISR+0x16a>
    5496:	28 8d       	ldd	r18, Y+24	; 0x18
    5498:	39 8d       	ldd	r19, Y+25	; 0x19
    549a:	23 30       	cpi	r18, 0x03	; 3
    549c:	31 05       	cpc	r19, r1
    549e:	5c f4       	brge	.+22     	; 0x54b6 <xTaskGenericNotifyFromISR+0xf4>
    54a0:	88 8d       	ldd	r24, Y+24	; 0x18
    54a2:	99 8d       	ldd	r25, Y+25	; 0x19
    54a4:	00 97       	sbiw	r24, 0x00	; 0
    54a6:	09 f4       	brne	.+2      	; 0x54aa <xTaskGenericNotifyFromISR+0xe8>
    54a8:	a8 c0       	rjmp	.+336    	; 0x55fa <xTaskGenericNotifyFromISR+0x238>
    54aa:	28 8d       	ldd	r18, Y+24	; 0x18
    54ac:	39 8d       	ldd	r19, Y+25	; 0x19
    54ae:	21 30       	cpi	r18, 0x01	; 1
    54b0:	31 05       	cpc	r19, r1
    54b2:	71 f0       	breq	.+28     	; 0x54d0 <xTaskGenericNotifyFromISR+0x10e>
    54b4:	94 c0       	rjmp	.+296    	; 0x55de <xTaskGenericNotifyFromISR+0x21c>
    54b6:	88 8d       	ldd	r24, Y+24	; 0x18
    54b8:	99 8d       	ldd	r25, Y+25	; 0x19
    54ba:	83 30       	cpi	r24, 0x03	; 3
    54bc:	91 05       	cpc	r25, r1
    54be:	09 f4       	brne	.+2      	; 0x54c2 <xTaskGenericNotifyFromISR+0x100>
    54c0:	5d c0       	rjmp	.+186    	; 0x557c <xTaskGenericNotifyFromISR+0x1ba>
    54c2:	28 8d       	ldd	r18, Y+24	; 0x18
    54c4:	39 8d       	ldd	r19, Y+25	; 0x19
    54c6:	24 30       	cpi	r18, 0x04	; 4
    54c8:	31 05       	cpc	r19, r1
    54ca:	09 f4       	brne	.+2      	; 0x54ce <xTaskGenericNotifyFromISR+0x10c>
    54cc:	6d c0       	rjmp	.+218    	; 0x55a8 <xTaskGenericNotifyFromISR+0x1e6>
    54ce:	87 c0       	rjmp	.+270    	; 0x55de <xTaskGenericNotifyFromISR+0x21c>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    54d0:	8e 85       	ldd	r24, Y+14	; 0x0e
    54d2:	08 2f       	mov	r16, r24
    54d4:	10 e0       	ldi	r17, 0x00	; 0
    54d6:	8e 85       	ldd	r24, Y+14	; 0x0e
    54d8:	88 2f       	mov	r24, r24
    54da:	90 e0       	ldi	r25, 0x00	; 0
    54dc:	2a 85       	ldd	r18, Y+10	; 0x0a
    54de:	3b 85       	ldd	r19, Y+11	; 0x0b
    54e0:	88 0f       	add	r24, r24
    54e2:	99 1f       	adc	r25, r25
    54e4:	88 0f       	add	r24, r24
    54e6:	99 1f       	adc	r25, r25
    54e8:	82 0f       	add	r24, r18
    54ea:	93 1f       	adc	r25, r19
    54ec:	fc 01       	movw	r30, r24
    54ee:	bd 96       	adiw	r30, 0x2d	; 45
    54f0:	20 81       	ld	r18, Z
    54f2:	31 81       	ldd	r19, Z+1	; 0x01
    54f4:	42 81       	ldd	r20, Z+2	; 0x02
    54f6:	53 81       	ldd	r21, Z+3	; 0x03
    54f8:	8f 85       	ldd	r24, Y+15	; 0x0f
    54fa:	98 89       	ldd	r25, Y+16	; 0x10
    54fc:	a9 89       	ldd	r26, Y+17	; 0x11
    54fe:	ba 89       	ldd	r27, Y+18	; 0x12
    5500:	ba 01       	movw	r22, r20
    5502:	a9 01       	movw	r20, r18
    5504:	48 2b       	or	r20, r24
    5506:	59 2b       	or	r21, r25
    5508:	6a 2b       	or	r22, r26
    550a:	7b 2b       	or	r23, r27
    550c:	2a 85       	ldd	r18, Y+10	; 0x0a
    550e:	3b 85       	ldd	r19, Y+11	; 0x0b
    5510:	c8 01       	movw	r24, r16
    5512:	88 0f       	add	r24, r24
    5514:	99 1f       	adc	r25, r25
    5516:	88 0f       	add	r24, r24
    5518:	99 1f       	adc	r25, r25
    551a:	82 0f       	add	r24, r18
    551c:	93 1f       	adc	r25, r19
    551e:	fc 01       	movw	r30, r24
    5520:	bd 96       	adiw	r30, 0x2d	; 45
    5522:	40 83       	st	Z, r20
    5524:	51 83       	std	Z+1, r21	; 0x01
    5526:	62 83       	std	Z+2, r22	; 0x02
    5528:	73 83       	std	Z+3, r23	; 0x03
    552a:	67 c0       	rjmp	.+206    	; 0x55fa <xTaskGenericNotifyFromISR+0x238>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    552c:	8e 85       	ldd	r24, Y+14	; 0x0e
    552e:	08 2f       	mov	r16, r24
    5530:	10 e0       	ldi	r17, 0x00	; 0
    5532:	2a 85       	ldd	r18, Y+10	; 0x0a
    5534:	3b 85       	ldd	r19, Y+11	; 0x0b
    5536:	c8 01       	movw	r24, r16
    5538:	88 0f       	add	r24, r24
    553a:	99 1f       	adc	r25, r25
    553c:	88 0f       	add	r24, r24
    553e:	99 1f       	adc	r25, r25
    5540:	82 0f       	add	r24, r18
    5542:	93 1f       	adc	r25, r19
    5544:	fc 01       	movw	r30, r24
    5546:	bd 96       	adiw	r30, 0x2d	; 45
    5548:	80 81       	ld	r24, Z
    554a:	91 81       	ldd	r25, Z+1	; 0x01
    554c:	a2 81       	ldd	r26, Z+2	; 0x02
    554e:	b3 81       	ldd	r27, Z+3	; 0x03
    5550:	ac 01       	movw	r20, r24
    5552:	bd 01       	movw	r22, r26
    5554:	4f 5f       	subi	r20, 0xFF	; 255
    5556:	5f 4f       	sbci	r21, 0xFF	; 255
    5558:	6f 4f       	sbci	r22, 0xFF	; 255
    555a:	7f 4f       	sbci	r23, 0xFF	; 255
    555c:	2a 85       	ldd	r18, Y+10	; 0x0a
    555e:	3b 85       	ldd	r19, Y+11	; 0x0b
    5560:	c8 01       	movw	r24, r16
    5562:	88 0f       	add	r24, r24
    5564:	99 1f       	adc	r25, r25
    5566:	88 0f       	add	r24, r24
    5568:	99 1f       	adc	r25, r25
    556a:	82 0f       	add	r24, r18
    556c:	93 1f       	adc	r25, r19
    556e:	fc 01       	movw	r30, r24
    5570:	bd 96       	adiw	r30, 0x2d	; 45
    5572:	40 83       	st	Z, r20
    5574:	51 83       	std	Z+1, r21	; 0x01
    5576:	62 83       	std	Z+2, r22	; 0x02
    5578:	73 83       	std	Z+3, r23	; 0x03
    557a:	3f c0       	rjmp	.+126    	; 0x55fa <xTaskGenericNotifyFromISR+0x238>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    557c:	8e 85       	ldd	r24, Y+14	; 0x0e
    557e:	88 2f       	mov	r24, r24
    5580:	90 e0       	ldi	r25, 0x00	; 0
    5582:	2a 85       	ldd	r18, Y+10	; 0x0a
    5584:	3b 85       	ldd	r19, Y+11	; 0x0b
    5586:	88 0f       	add	r24, r24
    5588:	99 1f       	adc	r25, r25
    558a:	88 0f       	add	r24, r24
    558c:	99 1f       	adc	r25, r25
    558e:	82 0f       	add	r24, r18
    5590:	93 1f       	adc	r25, r19
    5592:	fc 01       	movw	r30, r24
    5594:	bd 96       	adiw	r30, 0x2d	; 45
    5596:	8f 85       	ldd	r24, Y+15	; 0x0f
    5598:	98 89       	ldd	r25, Y+16	; 0x10
    559a:	a9 89       	ldd	r26, Y+17	; 0x11
    559c:	ba 89       	ldd	r27, Y+18	; 0x12
    559e:	80 83       	st	Z, r24
    55a0:	91 83       	std	Z+1, r25	; 0x01
    55a2:	a2 83       	std	Z+2, r26	; 0x02
    55a4:	b3 83       	std	Z+3, r27	; 0x03
    55a6:	29 c0       	rjmp	.+82     	; 0x55fa <xTaskGenericNotifyFromISR+0x238>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    55a8:	89 85       	ldd	r24, Y+9	; 0x09
    55aa:	82 30       	cpi	r24, 0x02	; 2
    55ac:	b1 f0       	breq	.+44     	; 0x55da <xTaskGenericNotifyFromISR+0x218>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    55ae:	8e 85       	ldd	r24, Y+14	; 0x0e
    55b0:	88 2f       	mov	r24, r24
    55b2:	90 e0       	ldi	r25, 0x00	; 0
    55b4:	2a 85       	ldd	r18, Y+10	; 0x0a
    55b6:	3b 85       	ldd	r19, Y+11	; 0x0b
    55b8:	88 0f       	add	r24, r24
    55ba:	99 1f       	adc	r25, r25
    55bc:	88 0f       	add	r24, r24
    55be:	99 1f       	adc	r25, r25
    55c0:	82 0f       	add	r24, r18
    55c2:	93 1f       	adc	r25, r19
    55c4:	fc 01       	movw	r30, r24
    55c6:	bd 96       	adiw	r30, 0x2d	; 45
    55c8:	8f 85       	ldd	r24, Y+15	; 0x0f
    55ca:	98 89       	ldd	r25, Y+16	; 0x10
    55cc:	a9 89       	ldd	r26, Y+17	; 0x11
    55ce:	ba 89       	ldd	r27, Y+18	; 0x12
    55d0:	80 83       	st	Z, r24
    55d2:	91 83       	std	Z+1, r25	; 0x01
    55d4:	a2 83       	std	Z+2, r26	; 0x02
    55d6:	b3 83       	std	Z+3, r27	; 0x03
    55d8:	10 c0       	rjmp	.+32     	; 0x55fa <xTaskGenericNotifyFromISR+0x238>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    55da:	18 86       	std	Y+8, r1	; 0x08
    55dc:	0e c0       	rjmp	.+28     	; 0x55fa <xTaskGenericNotifyFromISR+0x238>
                default:

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
    55de:	80 91 35 15 	lds	r24, 0x1535
    55e2:	90 91 36 15 	lds	r25, 0x1536
    55e6:	a0 91 37 15 	lds	r26, 0x1537
    55ea:	b0 91 38 15 	lds	r27, 0x1538
    55ee:	00 97       	sbiw	r24, 0x00	; 0
    55f0:	a1 05       	cpc	r26, r1
    55f2:	b1 05       	cpc	r27, r1
    55f4:	11 f0       	breq	.+4      	; 0x55fa <xTaskGenericNotifyFromISR+0x238>
    55f6:	f8 94       	cli
    55f8:	ff cf       	rjmp	.-2      	; 0x55f8 <xTaskGenericNotifyFromISR+0x236>

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    55fa:	89 85       	ldd	r24, Y+9	; 0x09
    55fc:	81 30       	cpi	r24, 0x01	; 1
    55fe:	09 f0       	breq	.+2      	; 0x5602 <xTaskGenericNotifyFromISR+0x240>
    5600:	ff c0       	rjmp	.+510    	; 0x5800 <xTaskGenericNotifyFromISR+0x43e>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
    5602:	ea 85       	ldd	r30, Y+10	; 0x0a
    5604:	fb 85       	ldd	r31, Y+11	; 0x0b
    5606:	80 8d       	ldd	r24, Z+24	; 0x18
    5608:	91 8d       	ldd	r25, Z+25	; 0x19
    560a:	00 97       	sbiw	r24, 0x00	; 0
    560c:	11 f0       	breq	.+4      	; 0x5612 <xTaskGenericNotifyFromISR+0x250>
    560e:	f8 94       	cli
    5610:	ff cf       	rjmp	.-2      	; 0x5610 <xTaskGenericNotifyFromISR+0x24e>

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5612:	80 91 48 15 	lds	r24, 0x1548
    5616:	88 23       	and	r24, r24
    5618:	09 f0       	breq	.+2      	; 0x561c <xTaskGenericNotifyFromISR+0x25a>
    561a:	ad c0       	rjmp	.+346    	; 0x5776 <xTaskGenericNotifyFromISR+0x3b4>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    561c:	ea 85       	ldd	r30, Y+10	; 0x0a
    561e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5620:	84 85       	ldd	r24, Z+12	; 0x0c
    5622:	95 85       	ldd	r25, Z+13	; 0x0d
    5624:	9e 83       	std	Y+6, r25	; 0x06
    5626:	8d 83       	std	Y+5, r24	; 0x05
    5628:	ea 85       	ldd	r30, Y+10	; 0x0a
    562a:	fb 85       	ldd	r31, Y+11	; 0x0b
    562c:	a6 81       	ldd	r26, Z+6	; 0x06
    562e:	b7 81       	ldd	r27, Z+7	; 0x07
    5630:	ea 85       	ldd	r30, Y+10	; 0x0a
    5632:	fb 85       	ldd	r31, Y+11	; 0x0b
    5634:	80 85       	ldd	r24, Z+8	; 0x08
    5636:	91 85       	ldd	r25, Z+9	; 0x09
    5638:	17 96       	adiw	r26, 0x07	; 7
    563a:	9c 93       	st	X, r25
    563c:	8e 93       	st	-X, r24
    563e:	16 97       	sbiw	r26, 0x06	; 6
    5640:	ea 85       	ldd	r30, Y+10	; 0x0a
    5642:	fb 85       	ldd	r31, Y+11	; 0x0b
    5644:	a0 85       	ldd	r26, Z+8	; 0x08
    5646:	b1 85       	ldd	r27, Z+9	; 0x09
    5648:	ea 85       	ldd	r30, Y+10	; 0x0a
    564a:	fb 85       	ldd	r31, Y+11	; 0x0b
    564c:	86 81       	ldd	r24, Z+6	; 0x06
    564e:	97 81       	ldd	r25, Z+7	; 0x07
    5650:	15 96       	adiw	r26, 0x05	; 5
    5652:	9c 93       	st	X, r25
    5654:	8e 93       	st	-X, r24
    5656:	14 97       	sbiw	r26, 0x04	; 4
    5658:	ed 81       	ldd	r30, Y+5	; 0x05
    565a:	fe 81       	ldd	r31, Y+6	; 0x06
    565c:	21 81       	ldd	r18, Z+1	; 0x01
    565e:	32 81       	ldd	r19, Z+2	; 0x02
    5660:	8a 85       	ldd	r24, Y+10	; 0x0a
    5662:	9b 85       	ldd	r25, Y+11	; 0x0b
    5664:	02 96       	adiw	r24, 0x02	; 2
    5666:	28 17       	cp	r18, r24
    5668:	39 07       	cpc	r19, r25
    566a:	41 f4       	brne	.+16     	; 0x567c <xTaskGenericNotifyFromISR+0x2ba>
    566c:	ea 85       	ldd	r30, Y+10	; 0x0a
    566e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5670:	80 85       	ldd	r24, Z+8	; 0x08
    5672:	91 85       	ldd	r25, Z+9	; 0x09
    5674:	ed 81       	ldd	r30, Y+5	; 0x05
    5676:	fe 81       	ldd	r31, Y+6	; 0x06
    5678:	92 83       	std	Z+2, r25	; 0x02
    567a:	81 83       	std	Z+1, r24	; 0x01
    567c:	ea 85       	ldd	r30, Y+10	; 0x0a
    567e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5680:	15 86       	std	Z+13, r1	; 0x0d
    5682:	14 86       	std	Z+12, r1	; 0x0c
    5684:	ed 81       	ldd	r30, Y+5	; 0x05
    5686:	fe 81       	ldd	r31, Y+6	; 0x06
    5688:	80 81       	ld	r24, Z
    568a:	81 50       	subi	r24, 0x01	; 1
    568c:	ed 81       	ldd	r30, Y+5	; 0x05
    568e:	fe 81       	ldd	r31, Y+6	; 0x06
    5690:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5692:	ea 85       	ldd	r30, Y+10	; 0x0a
    5694:	fb 85       	ldd	r31, Y+11	; 0x0b
    5696:	92 8d       	ldd	r25, Z+26	; 0x1a
    5698:	80 91 39 15 	lds	r24, 0x1539
    569c:	89 17       	cp	r24, r25
    569e:	28 f4       	brcc	.+10     	; 0x56aa <xTaskGenericNotifyFromISR+0x2e8>
    56a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    56a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    56a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    56a6:	80 93 39 15 	sts	0x1539, r24
    56aa:	ea 85       	ldd	r30, Y+10	; 0x0a
    56ac:	fb 85       	ldd	r31, Y+11	; 0x0b
    56ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    56b0:	48 2f       	mov	r20, r24
    56b2:	50 e0       	ldi	r21, 0x00	; 0
    56b4:	ca 01       	movw	r24, r20
    56b6:	88 0f       	add	r24, r24
    56b8:	99 1f       	adc	r25, r25
    56ba:	9c 01       	movw	r18, r24
    56bc:	22 0f       	add	r18, r18
    56be:	33 1f       	adc	r19, r19
    56c0:	22 0f       	add	r18, r18
    56c2:	33 1f       	adc	r19, r19
    56c4:	82 0f       	add	r24, r18
    56c6:	93 1f       	adc	r25, r19
    56c8:	84 0f       	add	r24, r20
    56ca:	95 1f       	adc	r25, r21
    56cc:	fc 01       	movw	r30, r24
    56ce:	e7 5b       	subi	r30, 0xB7	; 183
    56d0:	fa 4e       	sbci	r31, 0xEA	; 234
    56d2:	81 81       	ldd	r24, Z+1	; 0x01
    56d4:	92 81       	ldd	r25, Z+2	; 0x02
    56d6:	9c 83       	std	Y+4, r25	; 0x04
    56d8:	8b 83       	std	Y+3, r24	; 0x03
    56da:	ea 85       	ldd	r30, Y+10	; 0x0a
    56dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    56de:	8b 81       	ldd	r24, Y+3	; 0x03
    56e0:	9c 81       	ldd	r25, Y+4	; 0x04
    56e2:	97 83       	std	Z+7, r25	; 0x07
    56e4:	86 83       	std	Z+6, r24	; 0x06
    56e6:	eb 81       	ldd	r30, Y+3	; 0x03
    56e8:	fc 81       	ldd	r31, Y+4	; 0x04
    56ea:	86 81       	ldd	r24, Z+6	; 0x06
    56ec:	97 81       	ldd	r25, Z+7	; 0x07
    56ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    56f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    56f2:	91 87       	std	Z+9, r25	; 0x09
    56f4:	80 87       	std	Z+8, r24	; 0x08
    56f6:	eb 81       	ldd	r30, Y+3	; 0x03
    56f8:	fc 81       	ldd	r31, Y+4	; 0x04
    56fa:	06 80       	ldd	r0, Z+6	; 0x06
    56fc:	f7 81       	ldd	r31, Z+7	; 0x07
    56fe:	e0 2d       	mov	r30, r0
    5700:	8a 85       	ldd	r24, Y+10	; 0x0a
    5702:	9b 85       	ldd	r25, Y+11	; 0x0b
    5704:	02 96       	adiw	r24, 0x02	; 2
    5706:	95 83       	std	Z+5, r25	; 0x05
    5708:	84 83       	std	Z+4, r24	; 0x04
    570a:	8a 85       	ldd	r24, Y+10	; 0x0a
    570c:	9b 85       	ldd	r25, Y+11	; 0x0b
    570e:	02 96       	adiw	r24, 0x02	; 2
    5710:	eb 81       	ldd	r30, Y+3	; 0x03
    5712:	fc 81       	ldd	r31, Y+4	; 0x04
    5714:	97 83       	std	Z+7, r25	; 0x07
    5716:	86 83       	std	Z+6, r24	; 0x06
    5718:	ea 85       	ldd	r30, Y+10	; 0x0a
    571a:	fb 85       	ldd	r31, Y+11	; 0x0b
    571c:	82 8d       	ldd	r24, Z+26	; 0x1a
    571e:	48 2f       	mov	r20, r24
    5720:	50 e0       	ldi	r21, 0x00	; 0
    5722:	ca 01       	movw	r24, r20
    5724:	88 0f       	add	r24, r24
    5726:	99 1f       	adc	r25, r25
    5728:	9c 01       	movw	r18, r24
    572a:	22 0f       	add	r18, r18
    572c:	33 1f       	adc	r19, r19
    572e:	22 0f       	add	r18, r18
    5730:	33 1f       	adc	r19, r19
    5732:	82 0f       	add	r24, r18
    5734:	93 1f       	adc	r25, r19
    5736:	84 0f       	add	r24, r20
    5738:	95 1f       	adc	r25, r21
    573a:	87 5b       	subi	r24, 0xB7	; 183
    573c:	9a 4e       	sbci	r25, 0xEA	; 234
    573e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5740:	fb 85       	ldd	r31, Y+11	; 0x0b
    5742:	95 87       	std	Z+13, r25	; 0x0d
    5744:	84 87       	std	Z+12, r24	; 0x0c
    5746:	ea 85       	ldd	r30, Y+10	; 0x0a
    5748:	fb 85       	ldd	r31, Y+11	; 0x0b
    574a:	82 8d       	ldd	r24, Z+26	; 0x1a
    574c:	48 2f       	mov	r20, r24
    574e:	50 e0       	ldi	r21, 0x00	; 0
    5750:	ca 01       	movw	r24, r20
    5752:	88 0f       	add	r24, r24
    5754:	99 1f       	adc	r25, r25
    5756:	9c 01       	movw	r18, r24
    5758:	22 0f       	add	r18, r18
    575a:	33 1f       	adc	r19, r19
    575c:	22 0f       	add	r18, r18
    575e:	33 1f       	adc	r19, r19
    5760:	82 0f       	add	r24, r18
    5762:	93 1f       	adc	r25, r19
    5764:	84 0f       	add	r24, r20
    5766:	95 1f       	adc	r25, r21
    5768:	fc 01       	movw	r30, r24
    576a:	e7 5b       	subi	r30, 0xB7	; 183
    576c:	fa 4e       	sbci	r31, 0xEA	; 234
    576e:	80 81       	ld	r24, Z
    5770:	8f 5f       	subi	r24, 0xFF	; 255
    5772:	80 83       	st	Z, r24
    5774:	30 c0       	rjmp	.+96     	; 0x57d6 <xTaskGenericNotifyFromISR+0x414>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5776:	80 91 9b 15 	lds	r24, 0x159B
    577a:	90 91 9c 15 	lds	r25, 0x159C
    577e:	9a 83       	std	Y+2, r25	; 0x02
    5780:	89 83       	std	Y+1, r24	; 0x01
    5782:	ea 85       	ldd	r30, Y+10	; 0x0a
    5784:	fb 85       	ldd	r31, Y+11	; 0x0b
    5786:	89 81       	ldd	r24, Y+1	; 0x01
    5788:	9a 81       	ldd	r25, Y+2	; 0x02
    578a:	93 8b       	std	Z+19, r25	; 0x13
    578c:	82 8b       	std	Z+18, r24	; 0x12
    578e:	e9 81       	ldd	r30, Y+1	; 0x01
    5790:	fa 81       	ldd	r31, Y+2	; 0x02
    5792:	86 81       	ldd	r24, Z+6	; 0x06
    5794:	97 81       	ldd	r25, Z+7	; 0x07
    5796:	ea 85       	ldd	r30, Y+10	; 0x0a
    5798:	fb 85       	ldd	r31, Y+11	; 0x0b
    579a:	95 8b       	std	Z+21, r25	; 0x15
    579c:	84 8b       	std	Z+20, r24	; 0x14
    579e:	e9 81       	ldd	r30, Y+1	; 0x01
    57a0:	fa 81       	ldd	r31, Y+2	; 0x02
    57a2:	06 80       	ldd	r0, Z+6	; 0x06
    57a4:	f7 81       	ldd	r31, Z+7	; 0x07
    57a6:	e0 2d       	mov	r30, r0
    57a8:	8a 85       	ldd	r24, Y+10	; 0x0a
    57aa:	9b 85       	ldd	r25, Y+11	; 0x0b
    57ac:	0e 96       	adiw	r24, 0x0e	; 14
    57ae:	95 83       	std	Z+5, r25	; 0x05
    57b0:	84 83       	std	Z+4, r24	; 0x04
    57b2:	8a 85       	ldd	r24, Y+10	; 0x0a
    57b4:	9b 85       	ldd	r25, Y+11	; 0x0b
    57b6:	0e 96       	adiw	r24, 0x0e	; 14
    57b8:	e9 81       	ldd	r30, Y+1	; 0x01
    57ba:	fa 81       	ldd	r31, Y+2	; 0x02
    57bc:	97 83       	std	Z+7, r25	; 0x07
    57be:	86 83       	std	Z+6, r24	; 0x06
    57c0:	ea 85       	ldd	r30, Y+10	; 0x0a
    57c2:	fb 85       	ldd	r31, Y+11	; 0x0b
    57c4:	8a e9       	ldi	r24, 0x9A	; 154
    57c6:	95 e1       	ldi	r25, 0x15	; 21
    57c8:	91 8f       	std	Z+25, r25	; 0x19
    57ca:	80 8f       	std	Z+24, r24	; 0x18
    57cc:	80 91 9a 15 	lds	r24, 0x159A
    57d0:	8f 5f       	subi	r24, 0xFF	; 255
    57d2:	80 93 9a 15 	sts	0x159A, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    57d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    57d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    57da:	92 8d       	ldd	r25, Z+26	; 0x1a
    57dc:	e0 91 32 15 	lds	r30, 0x1532
    57e0:	f0 91 33 15 	lds	r31, 0x1533
    57e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    57e6:	89 17       	cp	r24, r25
    57e8:	58 f4       	brcc	.+22     	; 0x5800 <xTaskGenericNotifyFromISR+0x43e>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    57ea:	8e 89       	ldd	r24, Y+22	; 0x16
    57ec:	9f 89       	ldd	r25, Y+23	; 0x17
    57ee:	00 97       	sbiw	r24, 0x00	; 0
    57f0:	21 f0       	breq	.+8      	; 0x57fa <xTaskGenericNotifyFromISR+0x438>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    57f2:	ee 89       	ldd	r30, Y+22	; 0x16
    57f4:	ff 89       	ldd	r31, Y+23	; 0x17
    57f6:	81 e0       	ldi	r24, 0x01	; 1
    57f8:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    57fa:	81 e0       	ldi	r24, 0x01	; 1
    57fc:	80 93 3f 15 	sts	0x153F, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    5800:	88 85       	ldd	r24, Y+8	; 0x08
    }
    5802:	69 96       	adiw	r28, 0x19	; 25
    5804:	0f b6       	in	r0, 0x3f	; 63
    5806:	f8 94       	cli
    5808:	de bf       	out	0x3e, r29	; 62
    580a:	0f be       	out	0x3f, r0	; 63
    580c:	cd bf       	out	0x3d, r28	; 61
    580e:	cf 91       	pop	r28
    5810:	df 91       	pop	r29
    5812:	1f 91       	pop	r17
    5814:	0f 91       	pop	r16
    5816:	ff 90       	pop	r15
    5818:	ef 90       	pop	r14
    581a:	df 90       	pop	r13
    581c:	cf 90       	pop	r12
    581e:	08 95       	ret

00005820 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    5820:	0f 93       	push	r16
    5822:	1f 93       	push	r17
    5824:	df 93       	push	r29
    5826:	cf 93       	push	r28
    5828:	cd b7       	in	r28, 0x3d	; 61
    582a:	de b7       	in	r29, 0x3e	; 62
    582c:	2f 97       	sbiw	r28, 0x0f	; 15
    582e:	0f b6       	in	r0, 0x3f	; 63
    5830:	f8 94       	cli
    5832:	de bf       	out	0x3e, r29	; 62
    5834:	0f be       	out	0x3f, r0	; 63
    5836:	cd bf       	out	0x3d, r28	; 61
    5838:	9c 87       	std	Y+12, r25	; 0x0c
    583a:	8b 87       	std	Y+11, r24	; 0x0b
    583c:	6d 87       	std	Y+13, r22	; 0x0d
    583e:	5f 87       	std	Y+15, r21	; 0x0f
    5840:	4e 87       	std	Y+14, r20	; 0x0e
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        UBaseType_t uxSavedInterruptStatus;

        configASSERT( xTaskToNotify );
    5842:	8b 85       	ldd	r24, Y+11	; 0x0b
    5844:	9c 85       	ldd	r25, Y+12	; 0x0c
    5846:	00 97       	sbiw	r24, 0x00	; 0
    5848:	11 f4       	brne	.+4      	; 0x584e <vTaskGenericNotifyGiveFromISR+0x2e>
    584a:	f8 94       	cli
    584c:	ff cf       	rjmp	.-2      	; 0x584c <vTaskGenericNotifyGiveFromISR+0x2c>
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
    584e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5850:	88 23       	and	r24, r24
    5852:	11 f0       	breq	.+4      	; 0x5858 <vTaskGenericNotifyGiveFromISR+0x38>
    5854:	f8 94       	cli
    5856:	ff cf       	rjmp	.-2      	; 0x5856 <vTaskGenericNotifyGiveFromISR+0x36>
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    5858:	8b 85       	ldd	r24, Y+11	; 0x0b
    585a:	9c 85       	ldd	r25, Y+12	; 0x0c
    585c:	9a 87       	std	Y+10, r25	; 0x0a
    585e:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5860:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5862:	8d 85       	ldd	r24, Y+13	; 0x0d
    5864:	28 2f       	mov	r18, r24
    5866:	30 e0       	ldi	r19, 0x00	; 0
    5868:	89 85       	ldd	r24, Y+9	; 0x09
    586a:	9a 85       	ldd	r25, Y+10	; 0x0a
    586c:	82 0f       	add	r24, r18
    586e:	93 1f       	adc	r25, r19
    5870:	fc 01       	movw	r30, r24
    5872:	f1 96       	adiw	r30, 0x31	; 49
    5874:	80 81       	ld	r24, Z
    5876:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5878:	8d 85       	ldd	r24, Y+13	; 0x0d
    587a:	28 2f       	mov	r18, r24
    587c:	30 e0       	ldi	r19, 0x00	; 0
    587e:	89 85       	ldd	r24, Y+9	; 0x09
    5880:	9a 85       	ldd	r25, Y+10	; 0x0a
    5882:	82 0f       	add	r24, r18
    5884:	93 1f       	adc	r25, r19
    5886:	fc 01       	movw	r30, r24
    5888:	f1 96       	adiw	r30, 0x31	; 49
    588a:	82 e0       	ldi	r24, 0x02	; 2
    588c:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    588e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5890:	08 2f       	mov	r16, r24
    5892:	10 e0       	ldi	r17, 0x00	; 0
    5894:	29 85       	ldd	r18, Y+9	; 0x09
    5896:	3a 85       	ldd	r19, Y+10	; 0x0a
    5898:	c8 01       	movw	r24, r16
    589a:	88 0f       	add	r24, r24
    589c:	99 1f       	adc	r25, r25
    589e:	88 0f       	add	r24, r24
    58a0:	99 1f       	adc	r25, r25
    58a2:	82 0f       	add	r24, r18
    58a4:	93 1f       	adc	r25, r19
    58a6:	fc 01       	movw	r30, r24
    58a8:	bd 96       	adiw	r30, 0x2d	; 45
    58aa:	80 81       	ld	r24, Z
    58ac:	91 81       	ldd	r25, Z+1	; 0x01
    58ae:	a2 81       	ldd	r26, Z+2	; 0x02
    58b0:	b3 81       	ldd	r27, Z+3	; 0x03
    58b2:	ac 01       	movw	r20, r24
    58b4:	bd 01       	movw	r22, r26
    58b6:	4f 5f       	subi	r20, 0xFF	; 255
    58b8:	5f 4f       	sbci	r21, 0xFF	; 255
    58ba:	6f 4f       	sbci	r22, 0xFF	; 255
    58bc:	7f 4f       	sbci	r23, 0xFF	; 255
    58be:	29 85       	ldd	r18, Y+9	; 0x09
    58c0:	3a 85       	ldd	r19, Y+10	; 0x0a
    58c2:	c8 01       	movw	r24, r16
    58c4:	88 0f       	add	r24, r24
    58c6:	99 1f       	adc	r25, r25
    58c8:	88 0f       	add	r24, r24
    58ca:	99 1f       	adc	r25, r25
    58cc:	82 0f       	add	r24, r18
    58ce:	93 1f       	adc	r25, r19
    58d0:	fc 01       	movw	r30, r24
    58d2:	bd 96       	adiw	r30, 0x2d	; 45
    58d4:	40 83       	st	Z, r20
    58d6:	51 83       	std	Z+1, r21	; 0x01
    58d8:	62 83       	std	Z+2, r22	; 0x02
    58da:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    58dc:	88 85       	ldd	r24, Y+8	; 0x08
    58de:	81 30       	cpi	r24, 0x01	; 1
    58e0:	09 f0       	breq	.+2      	; 0x58e4 <vTaskGenericNotifyGiveFromISR+0xc4>
    58e2:	ff c0       	rjmp	.+510    	; 0x5ae2 <vTaskGenericNotifyGiveFromISR+0x2c2>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
    58e4:	e9 85       	ldd	r30, Y+9	; 0x09
    58e6:	fa 85       	ldd	r31, Y+10	; 0x0a
    58e8:	80 8d       	ldd	r24, Z+24	; 0x18
    58ea:	91 8d       	ldd	r25, Z+25	; 0x19
    58ec:	00 97       	sbiw	r24, 0x00	; 0
    58ee:	11 f0       	breq	.+4      	; 0x58f4 <vTaskGenericNotifyGiveFromISR+0xd4>
    58f0:	f8 94       	cli
    58f2:	ff cf       	rjmp	.-2      	; 0x58f2 <vTaskGenericNotifyGiveFromISR+0xd2>

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    58f4:	80 91 48 15 	lds	r24, 0x1548
    58f8:	88 23       	and	r24, r24
    58fa:	09 f0       	breq	.+2      	; 0x58fe <vTaskGenericNotifyGiveFromISR+0xde>
    58fc:	ad c0       	rjmp	.+346    	; 0x5a58 <vTaskGenericNotifyGiveFromISR+0x238>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    58fe:	e9 85       	ldd	r30, Y+9	; 0x09
    5900:	fa 85       	ldd	r31, Y+10	; 0x0a
    5902:	84 85       	ldd	r24, Z+12	; 0x0c
    5904:	95 85       	ldd	r25, Z+13	; 0x0d
    5906:	9e 83       	std	Y+6, r25	; 0x06
    5908:	8d 83       	std	Y+5, r24	; 0x05
    590a:	e9 85       	ldd	r30, Y+9	; 0x09
    590c:	fa 85       	ldd	r31, Y+10	; 0x0a
    590e:	a6 81       	ldd	r26, Z+6	; 0x06
    5910:	b7 81       	ldd	r27, Z+7	; 0x07
    5912:	e9 85       	ldd	r30, Y+9	; 0x09
    5914:	fa 85       	ldd	r31, Y+10	; 0x0a
    5916:	80 85       	ldd	r24, Z+8	; 0x08
    5918:	91 85       	ldd	r25, Z+9	; 0x09
    591a:	17 96       	adiw	r26, 0x07	; 7
    591c:	9c 93       	st	X, r25
    591e:	8e 93       	st	-X, r24
    5920:	16 97       	sbiw	r26, 0x06	; 6
    5922:	e9 85       	ldd	r30, Y+9	; 0x09
    5924:	fa 85       	ldd	r31, Y+10	; 0x0a
    5926:	a0 85       	ldd	r26, Z+8	; 0x08
    5928:	b1 85       	ldd	r27, Z+9	; 0x09
    592a:	e9 85       	ldd	r30, Y+9	; 0x09
    592c:	fa 85       	ldd	r31, Y+10	; 0x0a
    592e:	86 81       	ldd	r24, Z+6	; 0x06
    5930:	97 81       	ldd	r25, Z+7	; 0x07
    5932:	15 96       	adiw	r26, 0x05	; 5
    5934:	9c 93       	st	X, r25
    5936:	8e 93       	st	-X, r24
    5938:	14 97       	sbiw	r26, 0x04	; 4
    593a:	ed 81       	ldd	r30, Y+5	; 0x05
    593c:	fe 81       	ldd	r31, Y+6	; 0x06
    593e:	21 81       	ldd	r18, Z+1	; 0x01
    5940:	32 81       	ldd	r19, Z+2	; 0x02
    5942:	89 85       	ldd	r24, Y+9	; 0x09
    5944:	9a 85       	ldd	r25, Y+10	; 0x0a
    5946:	02 96       	adiw	r24, 0x02	; 2
    5948:	28 17       	cp	r18, r24
    594a:	39 07       	cpc	r19, r25
    594c:	41 f4       	brne	.+16     	; 0x595e <vTaskGenericNotifyGiveFromISR+0x13e>
    594e:	e9 85       	ldd	r30, Y+9	; 0x09
    5950:	fa 85       	ldd	r31, Y+10	; 0x0a
    5952:	80 85       	ldd	r24, Z+8	; 0x08
    5954:	91 85       	ldd	r25, Z+9	; 0x09
    5956:	ed 81       	ldd	r30, Y+5	; 0x05
    5958:	fe 81       	ldd	r31, Y+6	; 0x06
    595a:	92 83       	std	Z+2, r25	; 0x02
    595c:	81 83       	std	Z+1, r24	; 0x01
    595e:	e9 85       	ldd	r30, Y+9	; 0x09
    5960:	fa 85       	ldd	r31, Y+10	; 0x0a
    5962:	15 86       	std	Z+13, r1	; 0x0d
    5964:	14 86       	std	Z+12, r1	; 0x0c
    5966:	ed 81       	ldd	r30, Y+5	; 0x05
    5968:	fe 81       	ldd	r31, Y+6	; 0x06
    596a:	80 81       	ld	r24, Z
    596c:	81 50       	subi	r24, 0x01	; 1
    596e:	ed 81       	ldd	r30, Y+5	; 0x05
    5970:	fe 81       	ldd	r31, Y+6	; 0x06
    5972:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5974:	e9 85       	ldd	r30, Y+9	; 0x09
    5976:	fa 85       	ldd	r31, Y+10	; 0x0a
    5978:	92 8d       	ldd	r25, Z+26	; 0x1a
    597a:	80 91 39 15 	lds	r24, 0x1539
    597e:	89 17       	cp	r24, r25
    5980:	28 f4       	brcc	.+10     	; 0x598c <vTaskGenericNotifyGiveFromISR+0x16c>
    5982:	e9 85       	ldd	r30, Y+9	; 0x09
    5984:	fa 85       	ldd	r31, Y+10	; 0x0a
    5986:	82 8d       	ldd	r24, Z+26	; 0x1a
    5988:	80 93 39 15 	sts	0x1539, r24
    598c:	e9 85       	ldd	r30, Y+9	; 0x09
    598e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5990:	82 8d       	ldd	r24, Z+26	; 0x1a
    5992:	48 2f       	mov	r20, r24
    5994:	50 e0       	ldi	r21, 0x00	; 0
    5996:	ca 01       	movw	r24, r20
    5998:	88 0f       	add	r24, r24
    599a:	99 1f       	adc	r25, r25
    599c:	9c 01       	movw	r18, r24
    599e:	22 0f       	add	r18, r18
    59a0:	33 1f       	adc	r19, r19
    59a2:	22 0f       	add	r18, r18
    59a4:	33 1f       	adc	r19, r19
    59a6:	82 0f       	add	r24, r18
    59a8:	93 1f       	adc	r25, r19
    59aa:	84 0f       	add	r24, r20
    59ac:	95 1f       	adc	r25, r21
    59ae:	fc 01       	movw	r30, r24
    59b0:	e7 5b       	subi	r30, 0xB7	; 183
    59b2:	fa 4e       	sbci	r31, 0xEA	; 234
    59b4:	81 81       	ldd	r24, Z+1	; 0x01
    59b6:	92 81       	ldd	r25, Z+2	; 0x02
    59b8:	9c 83       	std	Y+4, r25	; 0x04
    59ba:	8b 83       	std	Y+3, r24	; 0x03
    59bc:	e9 85       	ldd	r30, Y+9	; 0x09
    59be:	fa 85       	ldd	r31, Y+10	; 0x0a
    59c0:	8b 81       	ldd	r24, Y+3	; 0x03
    59c2:	9c 81       	ldd	r25, Y+4	; 0x04
    59c4:	97 83       	std	Z+7, r25	; 0x07
    59c6:	86 83       	std	Z+6, r24	; 0x06
    59c8:	eb 81       	ldd	r30, Y+3	; 0x03
    59ca:	fc 81       	ldd	r31, Y+4	; 0x04
    59cc:	86 81       	ldd	r24, Z+6	; 0x06
    59ce:	97 81       	ldd	r25, Z+7	; 0x07
    59d0:	e9 85       	ldd	r30, Y+9	; 0x09
    59d2:	fa 85       	ldd	r31, Y+10	; 0x0a
    59d4:	91 87       	std	Z+9, r25	; 0x09
    59d6:	80 87       	std	Z+8, r24	; 0x08
    59d8:	eb 81       	ldd	r30, Y+3	; 0x03
    59da:	fc 81       	ldd	r31, Y+4	; 0x04
    59dc:	06 80       	ldd	r0, Z+6	; 0x06
    59de:	f7 81       	ldd	r31, Z+7	; 0x07
    59e0:	e0 2d       	mov	r30, r0
    59e2:	89 85       	ldd	r24, Y+9	; 0x09
    59e4:	9a 85       	ldd	r25, Y+10	; 0x0a
    59e6:	02 96       	adiw	r24, 0x02	; 2
    59e8:	95 83       	std	Z+5, r25	; 0x05
    59ea:	84 83       	std	Z+4, r24	; 0x04
    59ec:	89 85       	ldd	r24, Y+9	; 0x09
    59ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    59f0:	02 96       	adiw	r24, 0x02	; 2
    59f2:	eb 81       	ldd	r30, Y+3	; 0x03
    59f4:	fc 81       	ldd	r31, Y+4	; 0x04
    59f6:	97 83       	std	Z+7, r25	; 0x07
    59f8:	86 83       	std	Z+6, r24	; 0x06
    59fa:	e9 85       	ldd	r30, Y+9	; 0x09
    59fc:	fa 85       	ldd	r31, Y+10	; 0x0a
    59fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    5a00:	48 2f       	mov	r20, r24
    5a02:	50 e0       	ldi	r21, 0x00	; 0
    5a04:	ca 01       	movw	r24, r20
    5a06:	88 0f       	add	r24, r24
    5a08:	99 1f       	adc	r25, r25
    5a0a:	9c 01       	movw	r18, r24
    5a0c:	22 0f       	add	r18, r18
    5a0e:	33 1f       	adc	r19, r19
    5a10:	22 0f       	add	r18, r18
    5a12:	33 1f       	adc	r19, r19
    5a14:	82 0f       	add	r24, r18
    5a16:	93 1f       	adc	r25, r19
    5a18:	84 0f       	add	r24, r20
    5a1a:	95 1f       	adc	r25, r21
    5a1c:	87 5b       	subi	r24, 0xB7	; 183
    5a1e:	9a 4e       	sbci	r25, 0xEA	; 234
    5a20:	e9 85       	ldd	r30, Y+9	; 0x09
    5a22:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a24:	95 87       	std	Z+13, r25	; 0x0d
    5a26:	84 87       	std	Z+12, r24	; 0x0c
    5a28:	e9 85       	ldd	r30, Y+9	; 0x09
    5a2a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a2c:	82 8d       	ldd	r24, Z+26	; 0x1a
    5a2e:	48 2f       	mov	r20, r24
    5a30:	50 e0       	ldi	r21, 0x00	; 0
    5a32:	ca 01       	movw	r24, r20
    5a34:	88 0f       	add	r24, r24
    5a36:	99 1f       	adc	r25, r25
    5a38:	9c 01       	movw	r18, r24
    5a3a:	22 0f       	add	r18, r18
    5a3c:	33 1f       	adc	r19, r19
    5a3e:	22 0f       	add	r18, r18
    5a40:	33 1f       	adc	r19, r19
    5a42:	82 0f       	add	r24, r18
    5a44:	93 1f       	adc	r25, r19
    5a46:	84 0f       	add	r24, r20
    5a48:	95 1f       	adc	r25, r21
    5a4a:	fc 01       	movw	r30, r24
    5a4c:	e7 5b       	subi	r30, 0xB7	; 183
    5a4e:	fa 4e       	sbci	r31, 0xEA	; 234
    5a50:	80 81       	ld	r24, Z
    5a52:	8f 5f       	subi	r24, 0xFF	; 255
    5a54:	80 83       	st	Z, r24
    5a56:	30 c0       	rjmp	.+96     	; 0x5ab8 <vTaskGenericNotifyGiveFromISR+0x298>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5a58:	80 91 9b 15 	lds	r24, 0x159B
    5a5c:	90 91 9c 15 	lds	r25, 0x159C
    5a60:	9a 83       	std	Y+2, r25	; 0x02
    5a62:	89 83       	std	Y+1, r24	; 0x01
    5a64:	e9 85       	ldd	r30, Y+9	; 0x09
    5a66:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a68:	89 81       	ldd	r24, Y+1	; 0x01
    5a6a:	9a 81       	ldd	r25, Y+2	; 0x02
    5a6c:	93 8b       	std	Z+19, r25	; 0x13
    5a6e:	82 8b       	std	Z+18, r24	; 0x12
    5a70:	e9 81       	ldd	r30, Y+1	; 0x01
    5a72:	fa 81       	ldd	r31, Y+2	; 0x02
    5a74:	86 81       	ldd	r24, Z+6	; 0x06
    5a76:	97 81       	ldd	r25, Z+7	; 0x07
    5a78:	e9 85       	ldd	r30, Y+9	; 0x09
    5a7a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a7c:	95 8b       	std	Z+21, r25	; 0x15
    5a7e:	84 8b       	std	Z+20, r24	; 0x14
    5a80:	e9 81       	ldd	r30, Y+1	; 0x01
    5a82:	fa 81       	ldd	r31, Y+2	; 0x02
    5a84:	06 80       	ldd	r0, Z+6	; 0x06
    5a86:	f7 81       	ldd	r31, Z+7	; 0x07
    5a88:	e0 2d       	mov	r30, r0
    5a8a:	89 85       	ldd	r24, Y+9	; 0x09
    5a8c:	9a 85       	ldd	r25, Y+10	; 0x0a
    5a8e:	0e 96       	adiw	r24, 0x0e	; 14
    5a90:	95 83       	std	Z+5, r25	; 0x05
    5a92:	84 83       	std	Z+4, r24	; 0x04
    5a94:	89 85       	ldd	r24, Y+9	; 0x09
    5a96:	9a 85       	ldd	r25, Y+10	; 0x0a
    5a98:	0e 96       	adiw	r24, 0x0e	; 14
    5a9a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a9c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a9e:	97 83       	std	Z+7, r25	; 0x07
    5aa0:	86 83       	std	Z+6, r24	; 0x06
    5aa2:	e9 85       	ldd	r30, Y+9	; 0x09
    5aa4:	fa 85       	ldd	r31, Y+10	; 0x0a
    5aa6:	8a e9       	ldi	r24, 0x9A	; 154
    5aa8:	95 e1       	ldi	r25, 0x15	; 21
    5aaa:	91 8f       	std	Z+25, r25	; 0x19
    5aac:	80 8f       	std	Z+24, r24	; 0x18
    5aae:	80 91 9a 15 	lds	r24, 0x159A
    5ab2:	8f 5f       	subi	r24, 0xFF	; 255
    5ab4:	80 93 9a 15 	sts	0x159A, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5ab8:	e9 85       	ldd	r30, Y+9	; 0x09
    5aba:	fa 85       	ldd	r31, Y+10	; 0x0a
    5abc:	92 8d       	ldd	r25, Z+26	; 0x1a
    5abe:	e0 91 32 15 	lds	r30, 0x1532
    5ac2:	f0 91 33 15 	lds	r31, 0x1533
    5ac6:	82 8d       	ldd	r24, Z+26	; 0x1a
    5ac8:	89 17       	cp	r24, r25
    5aca:	58 f4       	brcc	.+22     	; 0x5ae2 <vTaskGenericNotifyGiveFromISR+0x2c2>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5acc:	8e 85       	ldd	r24, Y+14	; 0x0e
    5ace:	9f 85       	ldd	r25, Y+15	; 0x0f
    5ad0:	00 97       	sbiw	r24, 0x00	; 0
    5ad2:	21 f0       	breq	.+8      	; 0x5adc <vTaskGenericNotifyGiveFromISR+0x2bc>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5ad4:	ee 85       	ldd	r30, Y+14	; 0x0e
    5ad6:	ff 85       	ldd	r31, Y+15	; 0x0f
    5ad8:	81 e0       	ldi	r24, 0x01	; 1
    5ada:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5adc:	81 e0       	ldi	r24, 0x01	; 1
    5ade:	80 93 3f 15 	sts	0x153F, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    5ae2:	2f 96       	adiw	r28, 0x0f	; 15
    5ae4:	0f b6       	in	r0, 0x3f	; 63
    5ae6:	f8 94       	cli
    5ae8:	de bf       	out	0x3e, r29	; 62
    5aea:	0f be       	out	0x3f, r0	; 63
    5aec:	cd bf       	out	0x3d, r28	; 61
    5aee:	cf 91       	pop	r28
    5af0:	df 91       	pop	r29
    5af2:	1f 91       	pop	r17
    5af4:	0f 91       	pop	r16
    5af6:	08 95       	ret

00005af8 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    5af8:	df 93       	push	r29
    5afa:	cf 93       	push	r28
    5afc:	cd b7       	in	r28, 0x3d	; 61
    5afe:	de b7       	in	r29, 0x3e	; 62
    5b00:	28 97       	sbiw	r28, 0x08	; 8
    5b02:	0f b6       	in	r0, 0x3f	; 63
    5b04:	f8 94       	cli
    5b06:	de bf       	out	0x3e, r29	; 62
    5b08:	0f be       	out	0x3f, r0	; 63
    5b0a:	cd bf       	out	0x3d, r28	; 61
    5b0c:	9d 83       	std	Y+5, r25	; 0x05
    5b0e:	8c 83       	std	Y+4, r24	; 0x04
    5b10:	6e 83       	std	Y+6, r22	; 0x06
        TCB_t * pxTCB;
        BaseType_t xReturn;

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
    5b12:	8e 81       	ldd	r24, Y+6	; 0x06
    5b14:	88 23       	and	r24, r24
    5b16:	11 f0       	breq	.+4      	; 0x5b1c <xTaskGenericNotifyStateClear+0x24>
    5b18:	f8 94       	cli
    5b1a:	ff cf       	rjmp	.-2      	; 0x5b1a <xTaskGenericNotifyStateClear+0x22>

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5b1c:	8c 81       	ldd	r24, Y+4	; 0x04
    5b1e:	9d 81       	ldd	r25, Y+5	; 0x05
    5b20:	00 97       	sbiw	r24, 0x00	; 0
    5b22:	39 f4       	brne	.+14     	; 0x5b32 <xTaskGenericNotifyStateClear+0x3a>
    5b24:	80 91 32 15 	lds	r24, 0x1532
    5b28:	90 91 33 15 	lds	r25, 0x1533
    5b2c:	98 87       	std	Y+8, r25	; 0x08
    5b2e:	8f 83       	std	Y+7, r24	; 0x07
    5b30:	04 c0       	rjmp	.+8      	; 0x5b3a <xTaskGenericNotifyStateClear+0x42>
    5b32:	8c 81       	ldd	r24, Y+4	; 0x04
    5b34:	9d 81       	ldd	r25, Y+5	; 0x05
    5b36:	98 87       	std	Y+8, r25	; 0x08
    5b38:	8f 83       	std	Y+7, r24	; 0x07
    5b3a:	8f 81       	ldd	r24, Y+7	; 0x07
    5b3c:	98 85       	ldd	r25, Y+8	; 0x08
    5b3e:	9b 83       	std	Y+3, r25	; 0x03
    5b40:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    5b42:	0f b6       	in	r0, 0x3f	; 63
    5b44:	f8 94       	cli
    5b46:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    5b48:	8e 81       	ldd	r24, Y+6	; 0x06
    5b4a:	28 2f       	mov	r18, r24
    5b4c:	30 e0       	ldi	r19, 0x00	; 0
    5b4e:	8a 81       	ldd	r24, Y+2	; 0x02
    5b50:	9b 81       	ldd	r25, Y+3	; 0x03
    5b52:	82 0f       	add	r24, r18
    5b54:	93 1f       	adc	r25, r19
    5b56:	fc 01       	movw	r30, r24
    5b58:	f1 96       	adiw	r30, 0x31	; 49
    5b5a:	80 81       	ld	r24, Z
    5b5c:	82 30       	cpi	r24, 0x02	; 2
    5b5e:	69 f4       	brne	.+26     	; 0x5b7a <xTaskGenericNotifyStateClear+0x82>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    5b60:	8e 81       	ldd	r24, Y+6	; 0x06
    5b62:	28 2f       	mov	r18, r24
    5b64:	30 e0       	ldi	r19, 0x00	; 0
    5b66:	8a 81       	ldd	r24, Y+2	; 0x02
    5b68:	9b 81       	ldd	r25, Y+3	; 0x03
    5b6a:	82 0f       	add	r24, r18
    5b6c:	93 1f       	adc	r25, r19
    5b6e:	fc 01       	movw	r30, r24
    5b70:	f1 96       	adiw	r30, 0x31	; 49
    5b72:	10 82       	st	Z, r1
                xReturn = pdPASS;
    5b74:	81 e0       	ldi	r24, 0x01	; 1
    5b76:	89 83       	std	Y+1, r24	; 0x01
    5b78:	01 c0       	rjmp	.+2      	; 0x5b7c <xTaskGenericNotifyStateClear+0x84>
            }
            else
            {
                xReturn = pdFAIL;
    5b7a:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5b7c:	0f 90       	pop	r0
    5b7e:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5b80:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5b82:	28 96       	adiw	r28, 0x08	; 8
    5b84:	0f b6       	in	r0, 0x3f	; 63
    5b86:	f8 94       	cli
    5b88:	de bf       	out	0x3e, r29	; 62
    5b8a:	0f be       	out	0x3f, r0	; 63
    5b8c:	cd bf       	out	0x3d, r28	; 61
    5b8e:	cf 91       	pop	r28
    5b90:	df 91       	pop	r29
    5b92:	08 95       	ret

00005b94 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    5b94:	0f 93       	push	r16
    5b96:	1f 93       	push	r17
    5b98:	df 93       	push	r29
    5b9a:	cf 93       	push	r28
    5b9c:	cd b7       	in	r28, 0x3d	; 61
    5b9e:	de b7       	in	r29, 0x3e	; 62
    5ba0:	2f 97       	sbiw	r28, 0x0f	; 15
    5ba2:	0f b6       	in	r0, 0x3f	; 63
    5ba4:	f8 94       	cli
    5ba6:	de bf       	out	0x3e, r29	; 62
    5ba8:	0f be       	out	0x3f, r0	; 63
    5baa:	cd bf       	out	0x3d, r28	; 61
    5bac:	98 87       	std	Y+8, r25	; 0x08
    5bae:	8f 83       	std	Y+7, r24	; 0x07
    5bb0:	69 87       	std	Y+9, r22	; 0x09
    5bb2:	2a 87       	std	Y+10, r18	; 0x0a
    5bb4:	3b 87       	std	Y+11, r19	; 0x0b
    5bb6:	4c 87       	std	Y+12, r20	; 0x0c
    5bb8:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5bba:	8f 81       	ldd	r24, Y+7	; 0x07
    5bbc:	98 85       	ldd	r25, Y+8	; 0x08
    5bbe:	00 97       	sbiw	r24, 0x00	; 0
    5bc0:	39 f4       	brne	.+14     	; 0x5bd0 <ulTaskGenericNotifyValueClear+0x3c>
    5bc2:	80 91 32 15 	lds	r24, 0x1532
    5bc6:	90 91 33 15 	lds	r25, 0x1533
    5bca:	9f 87       	std	Y+15, r25	; 0x0f
    5bcc:	8e 87       	std	Y+14, r24	; 0x0e
    5bce:	04 c0       	rjmp	.+8      	; 0x5bd8 <ulTaskGenericNotifyValueClear+0x44>
    5bd0:	8f 81       	ldd	r24, Y+7	; 0x07
    5bd2:	98 85       	ldd	r25, Y+8	; 0x08
    5bd4:	9f 87       	std	Y+15, r25	; 0x0f
    5bd6:	8e 87       	std	Y+14, r24	; 0x0e
    5bd8:	8e 85       	ldd	r24, Y+14	; 0x0e
    5bda:	9f 85       	ldd	r25, Y+15	; 0x0f
    5bdc:	9e 83       	std	Y+6, r25	; 0x06
    5bde:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    5be0:	0f b6       	in	r0, 0x3f	; 63
    5be2:	f8 94       	cli
    5be4:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    5be6:	89 85       	ldd	r24, Y+9	; 0x09
    5be8:	88 2f       	mov	r24, r24
    5bea:	90 e0       	ldi	r25, 0x00	; 0
    5bec:	2d 81       	ldd	r18, Y+5	; 0x05
    5bee:	3e 81       	ldd	r19, Y+6	; 0x06
    5bf0:	88 0f       	add	r24, r24
    5bf2:	99 1f       	adc	r25, r25
    5bf4:	88 0f       	add	r24, r24
    5bf6:	99 1f       	adc	r25, r25
    5bf8:	82 0f       	add	r24, r18
    5bfa:	93 1f       	adc	r25, r19
    5bfc:	fc 01       	movw	r30, r24
    5bfe:	bd 96       	adiw	r30, 0x2d	; 45
    5c00:	80 81       	ld	r24, Z
    5c02:	91 81       	ldd	r25, Z+1	; 0x01
    5c04:	a2 81       	ldd	r26, Z+2	; 0x02
    5c06:	b3 81       	ldd	r27, Z+3	; 0x03
    5c08:	89 83       	std	Y+1, r24	; 0x01
    5c0a:	9a 83       	std	Y+2, r25	; 0x02
    5c0c:	ab 83       	std	Y+3, r26	; 0x03
    5c0e:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    5c10:	89 85       	ldd	r24, Y+9	; 0x09
    5c12:	08 2f       	mov	r16, r24
    5c14:	10 e0       	ldi	r17, 0x00	; 0
    5c16:	89 85       	ldd	r24, Y+9	; 0x09
    5c18:	88 2f       	mov	r24, r24
    5c1a:	90 e0       	ldi	r25, 0x00	; 0
    5c1c:	2d 81       	ldd	r18, Y+5	; 0x05
    5c1e:	3e 81       	ldd	r19, Y+6	; 0x06
    5c20:	88 0f       	add	r24, r24
    5c22:	99 1f       	adc	r25, r25
    5c24:	88 0f       	add	r24, r24
    5c26:	99 1f       	adc	r25, r25
    5c28:	82 0f       	add	r24, r18
    5c2a:	93 1f       	adc	r25, r19
    5c2c:	fc 01       	movw	r30, r24
    5c2e:	bd 96       	adiw	r30, 0x2d	; 45
    5c30:	20 81       	ld	r18, Z
    5c32:	31 81       	ldd	r19, Z+1	; 0x01
    5c34:	42 81       	ldd	r20, Z+2	; 0x02
    5c36:	53 81       	ldd	r21, Z+3	; 0x03
    5c38:	8a 85       	ldd	r24, Y+10	; 0x0a
    5c3a:	9b 85       	ldd	r25, Y+11	; 0x0b
    5c3c:	ac 85       	ldd	r26, Y+12	; 0x0c
    5c3e:	bd 85       	ldd	r27, Y+13	; 0x0d
    5c40:	80 95       	com	r24
    5c42:	90 95       	com	r25
    5c44:	a0 95       	com	r26
    5c46:	b0 95       	com	r27
    5c48:	ba 01       	movw	r22, r20
    5c4a:	a9 01       	movw	r20, r18
    5c4c:	48 23       	and	r20, r24
    5c4e:	59 23       	and	r21, r25
    5c50:	6a 23       	and	r22, r26
    5c52:	7b 23       	and	r23, r27
    5c54:	2d 81       	ldd	r18, Y+5	; 0x05
    5c56:	3e 81       	ldd	r19, Y+6	; 0x06
    5c58:	c8 01       	movw	r24, r16
    5c5a:	88 0f       	add	r24, r24
    5c5c:	99 1f       	adc	r25, r25
    5c5e:	88 0f       	add	r24, r24
    5c60:	99 1f       	adc	r25, r25
    5c62:	82 0f       	add	r24, r18
    5c64:	93 1f       	adc	r25, r19
    5c66:	fc 01       	movw	r30, r24
    5c68:	bd 96       	adiw	r30, 0x2d	; 45
    5c6a:	40 83       	st	Z, r20
    5c6c:	51 83       	std	Z+1, r21	; 0x01
    5c6e:	62 83       	std	Z+2, r22	; 0x02
    5c70:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    5c72:	0f 90       	pop	r0
    5c74:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    5c76:	89 81       	ldd	r24, Y+1	; 0x01
    5c78:	9a 81       	ldd	r25, Y+2	; 0x02
    5c7a:	ab 81       	ldd	r26, Y+3	; 0x03
    5c7c:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    5c7e:	bc 01       	movw	r22, r24
    5c80:	cd 01       	movw	r24, r26
    5c82:	2f 96       	adiw	r28, 0x0f	; 15
    5c84:	0f b6       	in	r0, 0x3f	; 63
    5c86:	f8 94       	cli
    5c88:	de bf       	out	0x3e, r29	; 62
    5c8a:	0f be       	out	0x3f, r0	; 63
    5c8c:	cd bf       	out	0x3d, r28	; 61
    5c8e:	cf 91       	pop	r28
    5c90:	df 91       	pop	r29
    5c92:	1f 91       	pop	r17
    5c94:	0f 91       	pop	r16
    5c96:	08 95       	ret

00005c98 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    5c98:	df 93       	push	r29
    5c9a:	cf 93       	push	r28
    5c9c:	cd b7       	in	r28, 0x3d	; 61
    5c9e:	de b7       	in	r29, 0x3e	; 62
    5ca0:	2d 97       	sbiw	r28, 0x0d	; 13
    5ca2:	0f b6       	in	r0, 0x3f	; 63
    5ca4:	f8 94       	cli
    5ca6:	de bf       	out	0x3e, r29	; 62
    5ca8:	0f be       	out	0x3f, r0	; 63
    5caa:	cd bf       	out	0x3d, r28	; 61
    5cac:	69 87       	std	Y+9, r22	; 0x09
    5cae:	7a 87       	std	Y+10, r23	; 0x0a
    5cb0:	8b 87       	std	Y+11, r24	; 0x0b
    5cb2:	9c 87       	std	Y+12, r25	; 0x0c
    5cb4:	4d 87       	std	Y+13, r20	; 0x0d
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    5cb6:	80 91 35 15 	lds	r24, 0x1535
    5cba:	90 91 36 15 	lds	r25, 0x1536
    5cbe:	a0 91 37 15 	lds	r26, 0x1537
    5cc2:	b0 91 38 15 	lds	r27, 0x1538
    5cc6:	89 83       	std	Y+1, r24	; 0x01
    5cc8:	9a 83       	std	Y+2, r25	; 0x02
    5cca:	ab 83       	std	Y+3, r26	; 0x03
    5ccc:	bc 83       	std	Y+4, r27	; 0x04
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5cce:	80 91 32 15 	lds	r24, 0x1532
    5cd2:	90 91 33 15 	lds	r25, 0x1533
    5cd6:	02 96       	adiw	r24, 0x02	; 2
    5cd8:	0e 94 cc 10 	call	0x2198	; 0x2198 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
    {
        /* Calculate the time at which the task should be woken if the event
         * does not occur.  This may overflow but this doesn't matter, the kernel
         * will manage it correctly. */
        xTimeToWake = xConstTickCount + xTicksToWait;
    5cdc:	29 81       	ldd	r18, Y+1	; 0x01
    5cde:	3a 81       	ldd	r19, Y+2	; 0x02
    5ce0:	4b 81       	ldd	r20, Y+3	; 0x03
    5ce2:	5c 81       	ldd	r21, Y+4	; 0x04
    5ce4:	89 85       	ldd	r24, Y+9	; 0x09
    5ce6:	9a 85       	ldd	r25, Y+10	; 0x0a
    5ce8:	ab 85       	ldd	r26, Y+11	; 0x0b
    5cea:	bc 85       	ldd	r27, Y+12	; 0x0c
    5cec:	82 0f       	add	r24, r18
    5cee:	93 1f       	adc	r25, r19
    5cf0:	a4 1f       	adc	r26, r20
    5cf2:	b5 1f       	adc	r27, r21
    5cf4:	8d 83       	std	Y+5, r24	; 0x05
    5cf6:	9e 83       	std	Y+6, r25	; 0x06
    5cf8:	af 83       	std	Y+7, r26	; 0x07
    5cfa:	b8 87       	std	Y+8, r27	; 0x08

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5cfc:	e0 91 32 15 	lds	r30, 0x1532
    5d00:	f0 91 33 15 	lds	r31, 0x1533
    5d04:	8d 81       	ldd	r24, Y+5	; 0x05
    5d06:	9e 81       	ldd	r25, Y+6	; 0x06
    5d08:	af 81       	ldd	r26, Y+7	; 0x07
    5d0a:	b8 85       	ldd	r27, Y+8	; 0x08
    5d0c:	82 83       	std	Z+2, r24	; 0x02
    5d0e:	93 83       	std	Z+3, r25	; 0x03
    5d10:	a4 83       	std	Z+4, r26	; 0x04
    5d12:	b5 83       	std	Z+5, r27	; 0x05

        if( xTimeToWake < xConstTickCount )
    5d14:	2d 81       	ldd	r18, Y+5	; 0x05
    5d16:	3e 81       	ldd	r19, Y+6	; 0x06
    5d18:	4f 81       	ldd	r20, Y+7	; 0x07
    5d1a:	58 85       	ldd	r21, Y+8	; 0x08
    5d1c:	89 81       	ldd	r24, Y+1	; 0x01
    5d1e:	9a 81       	ldd	r25, Y+2	; 0x02
    5d20:	ab 81       	ldd	r26, Y+3	; 0x03
    5d22:	bc 81       	ldd	r27, Y+4	; 0x04
    5d24:	28 17       	cp	r18, r24
    5d26:	39 07       	cpc	r19, r25
    5d28:	4a 07       	cpc	r20, r26
    5d2a:	5b 07       	cpc	r21, r27
    5d2c:	70 f4       	brcc	.+28     	; 0x5d4a <prvAddCurrentTaskToDelayedList+0xb2>
        {
            /* Wake time has overflowed.  Place this item in the overflow list. */
            vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5d2e:	80 91 98 15 	lds	r24, 0x1598
    5d32:	90 91 99 15 	lds	r25, 0x1599
    5d36:	20 91 32 15 	lds	r18, 0x1532
    5d3a:	30 91 33 15 	lds	r19, 0x1533
    5d3e:	2e 5f       	subi	r18, 0xFE	; 254
    5d40:	3f 4f       	sbci	r19, 0xFF	; 255
    5d42:	b9 01       	movw	r22, r18
    5d44:	0e 94 50 10 	call	0x20a0	; 0x20a0 <vListInsert>
    5d48:	2c c0       	rjmp	.+88     	; 0x5da2 <prvAddCurrentTaskToDelayedList+0x10a>
        }
        else
        {
            /* The wake time has not overflowed, so the current block list is used. */
            vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5d4a:	40 91 96 15 	lds	r20, 0x1596
    5d4e:	50 91 97 15 	lds	r21, 0x1597
    5d52:	80 91 32 15 	lds	r24, 0x1532
    5d56:	90 91 33 15 	lds	r25, 0x1533
    5d5a:	9c 01       	movw	r18, r24
    5d5c:	2e 5f       	subi	r18, 0xFE	; 254
    5d5e:	3f 4f       	sbci	r19, 0xFF	; 255
    5d60:	ca 01       	movw	r24, r20
    5d62:	b9 01       	movw	r22, r18
    5d64:	0e 94 50 10 	call	0x20a0	; 0x20a0 <vListInsert>

            /* If the task entering the blocked state was placed at the head of the
             * list of blocked tasks then xNextTaskUnblockTime needs to be updated
             * too. */
            if( xTimeToWake < xNextTaskUnblockTime )
    5d68:	20 91 42 15 	lds	r18, 0x1542
    5d6c:	30 91 43 15 	lds	r19, 0x1543
    5d70:	40 91 44 15 	lds	r20, 0x1544
    5d74:	50 91 45 15 	lds	r21, 0x1545
    5d78:	8d 81       	ldd	r24, Y+5	; 0x05
    5d7a:	9e 81       	ldd	r25, Y+6	; 0x06
    5d7c:	af 81       	ldd	r26, Y+7	; 0x07
    5d7e:	b8 85       	ldd	r27, Y+8	; 0x08
    5d80:	82 17       	cp	r24, r18
    5d82:	93 07       	cpc	r25, r19
    5d84:	a4 07       	cpc	r26, r20
    5d86:	b5 07       	cpc	r27, r21
    5d88:	60 f4       	brcc	.+24     	; 0x5da2 <prvAddCurrentTaskToDelayedList+0x10a>
            {
                xNextTaskUnblockTime = xTimeToWake;
    5d8a:	8d 81       	ldd	r24, Y+5	; 0x05
    5d8c:	9e 81       	ldd	r25, Y+6	; 0x06
    5d8e:	af 81       	ldd	r26, Y+7	; 0x07
    5d90:	b8 85       	ldd	r27, Y+8	; 0x08
    5d92:	80 93 42 15 	sts	0x1542, r24
    5d96:	90 93 43 15 	sts	0x1543, r25
    5d9a:	a0 93 44 15 	sts	0x1544, r26
    5d9e:	b0 93 45 15 	sts	0x1545, r27

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
    5da2:	2d 96       	adiw	r28, 0x0d	; 13
    5da4:	0f b6       	in	r0, 0x3f	; 63
    5da6:	f8 94       	cli
    5da8:	de bf       	out	0x3e, r29	; 62
    5daa:	0f be       	out	0x3f, r0	; 63
    5dac:	cd bf       	out	0x3d, r28	; 61
    5dae:	cf 91       	pop	r28
    5db0:	df 91       	pop	r29
    5db2:	08 95       	ret

00005db4 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
    5db4:	df 93       	push	r29
    5db6:	cf 93       	push	r28
    5db8:	00 d0       	rcall	.+0      	; 0x5dba <GPIO_setupPinDirection+0x6>
    5dba:	00 d0       	rcall	.+0      	; 0x5dbc <GPIO_setupPinDirection+0x8>
    5dbc:	0f 92       	push	r0
    5dbe:	cd b7       	in	r28, 0x3d	; 61
    5dc0:	de b7       	in	r29, 0x3e	; 62
    5dc2:	89 83       	std	Y+1, r24	; 0x01
    5dc4:	6a 83       	std	Y+2, r22	; 0x02
    5dc6:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    5dc8:	8a 81       	ldd	r24, Y+2	; 0x02
    5dca:	88 30       	cpi	r24, 0x08	; 8
    5dcc:	08 f0       	brcs	.+2      	; 0x5dd0 <GPIO_setupPinDirection+0x1c>
    5dce:	d5 c0       	rjmp	.+426    	; 0x5f7a <GPIO_setupPinDirection+0x1c6>
    5dd0:	89 81       	ldd	r24, Y+1	; 0x01
    5dd2:	84 30       	cpi	r24, 0x04	; 4
    5dd4:	08 f0       	brcs	.+2      	; 0x5dd8 <GPIO_setupPinDirection+0x24>
    5dd6:	d1 c0       	rjmp	.+418    	; 0x5f7a <GPIO_setupPinDirection+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
    5dd8:	89 81       	ldd	r24, Y+1	; 0x01
    5dda:	28 2f       	mov	r18, r24
    5ddc:	30 e0       	ldi	r19, 0x00	; 0
    5dde:	3d 83       	std	Y+5, r19	; 0x05
    5de0:	2c 83       	std	Y+4, r18	; 0x04
    5de2:	8c 81       	ldd	r24, Y+4	; 0x04
    5de4:	9d 81       	ldd	r25, Y+5	; 0x05
    5de6:	81 30       	cpi	r24, 0x01	; 1
    5de8:	91 05       	cpc	r25, r1
    5dea:	09 f4       	brne	.+2      	; 0x5dee <GPIO_setupPinDirection+0x3a>
    5dec:	43 c0       	rjmp	.+134    	; 0x5e74 <GPIO_setupPinDirection+0xc0>
    5dee:	2c 81       	ldd	r18, Y+4	; 0x04
    5df0:	3d 81       	ldd	r19, Y+5	; 0x05
    5df2:	22 30       	cpi	r18, 0x02	; 2
    5df4:	31 05       	cpc	r19, r1
    5df6:	2c f4       	brge	.+10     	; 0x5e02 <GPIO_setupPinDirection+0x4e>
    5df8:	8c 81       	ldd	r24, Y+4	; 0x04
    5dfa:	9d 81       	ldd	r25, Y+5	; 0x05
    5dfc:	00 97       	sbiw	r24, 0x00	; 0
    5dfe:	71 f0       	breq	.+28     	; 0x5e1c <GPIO_setupPinDirection+0x68>
    5e00:	bc c0       	rjmp	.+376    	; 0x5f7a <GPIO_setupPinDirection+0x1c6>
    5e02:	2c 81       	ldd	r18, Y+4	; 0x04
    5e04:	3d 81       	ldd	r19, Y+5	; 0x05
    5e06:	22 30       	cpi	r18, 0x02	; 2
    5e08:	31 05       	cpc	r19, r1
    5e0a:	09 f4       	brne	.+2      	; 0x5e0e <GPIO_setupPinDirection+0x5a>
    5e0c:	5f c0       	rjmp	.+190    	; 0x5ecc <GPIO_setupPinDirection+0x118>
    5e0e:	8c 81       	ldd	r24, Y+4	; 0x04
    5e10:	9d 81       	ldd	r25, Y+5	; 0x05
    5e12:	83 30       	cpi	r24, 0x03	; 3
    5e14:	91 05       	cpc	r25, r1
    5e16:	09 f4       	brne	.+2      	; 0x5e1a <GPIO_setupPinDirection+0x66>
    5e18:	85 c0       	rjmp	.+266    	; 0x5f24 <GPIO_setupPinDirection+0x170>
    5e1a:	af c0       	rjmp	.+350    	; 0x5f7a <GPIO_setupPinDirection+0x1c6>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
    5e1c:	8b 81       	ldd	r24, Y+3	; 0x03
    5e1e:	81 30       	cpi	r24, 0x01	; 1
    5e20:	a1 f4       	brne	.+40     	; 0x5e4a <GPIO_setupPinDirection+0x96>
			{
				SET_BIT(DDRA,pin_num);
    5e22:	a1 e2       	ldi	r26, 0x21	; 33
    5e24:	b0 e0       	ldi	r27, 0x00	; 0
    5e26:	e1 e2       	ldi	r30, 0x21	; 33
    5e28:	f0 e0       	ldi	r31, 0x00	; 0
    5e2a:	80 81       	ld	r24, Z
    5e2c:	48 2f       	mov	r20, r24
    5e2e:	8a 81       	ldd	r24, Y+2	; 0x02
    5e30:	28 2f       	mov	r18, r24
    5e32:	30 e0       	ldi	r19, 0x00	; 0
    5e34:	81 e0       	ldi	r24, 0x01	; 1
    5e36:	90 e0       	ldi	r25, 0x00	; 0
    5e38:	02 2e       	mov	r0, r18
    5e3a:	02 c0       	rjmp	.+4      	; 0x5e40 <GPIO_setupPinDirection+0x8c>
    5e3c:	88 0f       	add	r24, r24
    5e3e:	99 1f       	adc	r25, r25
    5e40:	0a 94       	dec	r0
    5e42:	e2 f7       	brpl	.-8      	; 0x5e3c <GPIO_setupPinDirection+0x88>
    5e44:	84 2b       	or	r24, r20
    5e46:	8c 93       	st	X, r24
    5e48:	98 c0       	rjmp	.+304    	; 0x5f7a <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
    5e4a:	a1 e2       	ldi	r26, 0x21	; 33
    5e4c:	b0 e0       	ldi	r27, 0x00	; 0
    5e4e:	e1 e2       	ldi	r30, 0x21	; 33
    5e50:	f0 e0       	ldi	r31, 0x00	; 0
    5e52:	80 81       	ld	r24, Z
    5e54:	48 2f       	mov	r20, r24
    5e56:	8a 81       	ldd	r24, Y+2	; 0x02
    5e58:	28 2f       	mov	r18, r24
    5e5a:	30 e0       	ldi	r19, 0x00	; 0
    5e5c:	81 e0       	ldi	r24, 0x01	; 1
    5e5e:	90 e0       	ldi	r25, 0x00	; 0
    5e60:	02 2e       	mov	r0, r18
    5e62:	02 c0       	rjmp	.+4      	; 0x5e68 <GPIO_setupPinDirection+0xb4>
    5e64:	88 0f       	add	r24, r24
    5e66:	99 1f       	adc	r25, r25
    5e68:	0a 94       	dec	r0
    5e6a:	e2 f7       	brpl	.-8      	; 0x5e64 <GPIO_setupPinDirection+0xb0>
    5e6c:	80 95       	com	r24
    5e6e:	84 23       	and	r24, r20
    5e70:	8c 93       	st	X, r24
    5e72:	83 c0       	rjmp	.+262    	; 0x5f7a <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
    5e74:	8b 81       	ldd	r24, Y+3	; 0x03
    5e76:	81 30       	cpi	r24, 0x01	; 1
    5e78:	a1 f4       	brne	.+40     	; 0x5ea2 <GPIO_setupPinDirection+0xee>
			{
				SET_BIT(DDRB,pin_num);
    5e7a:	a4 e2       	ldi	r26, 0x24	; 36
    5e7c:	b0 e0       	ldi	r27, 0x00	; 0
    5e7e:	e4 e2       	ldi	r30, 0x24	; 36
    5e80:	f0 e0       	ldi	r31, 0x00	; 0
    5e82:	80 81       	ld	r24, Z
    5e84:	48 2f       	mov	r20, r24
    5e86:	8a 81       	ldd	r24, Y+2	; 0x02
    5e88:	28 2f       	mov	r18, r24
    5e8a:	30 e0       	ldi	r19, 0x00	; 0
    5e8c:	81 e0       	ldi	r24, 0x01	; 1
    5e8e:	90 e0       	ldi	r25, 0x00	; 0
    5e90:	02 2e       	mov	r0, r18
    5e92:	02 c0       	rjmp	.+4      	; 0x5e98 <GPIO_setupPinDirection+0xe4>
    5e94:	88 0f       	add	r24, r24
    5e96:	99 1f       	adc	r25, r25
    5e98:	0a 94       	dec	r0
    5e9a:	e2 f7       	brpl	.-8      	; 0x5e94 <GPIO_setupPinDirection+0xe0>
    5e9c:	84 2b       	or	r24, r20
    5e9e:	8c 93       	st	X, r24
    5ea0:	6c c0       	rjmp	.+216    	; 0x5f7a <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
    5ea2:	a4 e2       	ldi	r26, 0x24	; 36
    5ea4:	b0 e0       	ldi	r27, 0x00	; 0
    5ea6:	e4 e2       	ldi	r30, 0x24	; 36
    5ea8:	f0 e0       	ldi	r31, 0x00	; 0
    5eaa:	80 81       	ld	r24, Z
    5eac:	48 2f       	mov	r20, r24
    5eae:	8a 81       	ldd	r24, Y+2	; 0x02
    5eb0:	28 2f       	mov	r18, r24
    5eb2:	30 e0       	ldi	r19, 0x00	; 0
    5eb4:	81 e0       	ldi	r24, 0x01	; 1
    5eb6:	90 e0       	ldi	r25, 0x00	; 0
    5eb8:	02 2e       	mov	r0, r18
    5eba:	02 c0       	rjmp	.+4      	; 0x5ec0 <GPIO_setupPinDirection+0x10c>
    5ebc:	88 0f       	add	r24, r24
    5ebe:	99 1f       	adc	r25, r25
    5ec0:	0a 94       	dec	r0
    5ec2:	e2 f7       	brpl	.-8      	; 0x5ebc <GPIO_setupPinDirection+0x108>
    5ec4:	80 95       	com	r24
    5ec6:	84 23       	and	r24, r20
    5ec8:	8c 93       	st	X, r24
    5eca:	57 c0       	rjmp	.+174    	; 0x5f7a <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
    5ecc:	8b 81       	ldd	r24, Y+3	; 0x03
    5ece:	81 30       	cpi	r24, 0x01	; 1
    5ed0:	a1 f4       	brne	.+40     	; 0x5efa <GPIO_setupPinDirection+0x146>
			{
				SET_BIT(DDRC,pin_num);
    5ed2:	a7 e2       	ldi	r26, 0x27	; 39
    5ed4:	b0 e0       	ldi	r27, 0x00	; 0
    5ed6:	e7 e2       	ldi	r30, 0x27	; 39
    5ed8:	f0 e0       	ldi	r31, 0x00	; 0
    5eda:	80 81       	ld	r24, Z
    5edc:	48 2f       	mov	r20, r24
    5ede:	8a 81       	ldd	r24, Y+2	; 0x02
    5ee0:	28 2f       	mov	r18, r24
    5ee2:	30 e0       	ldi	r19, 0x00	; 0
    5ee4:	81 e0       	ldi	r24, 0x01	; 1
    5ee6:	90 e0       	ldi	r25, 0x00	; 0
    5ee8:	02 2e       	mov	r0, r18
    5eea:	02 c0       	rjmp	.+4      	; 0x5ef0 <GPIO_setupPinDirection+0x13c>
    5eec:	88 0f       	add	r24, r24
    5eee:	99 1f       	adc	r25, r25
    5ef0:	0a 94       	dec	r0
    5ef2:	e2 f7       	brpl	.-8      	; 0x5eec <GPIO_setupPinDirection+0x138>
    5ef4:	84 2b       	or	r24, r20
    5ef6:	8c 93       	st	X, r24
    5ef8:	40 c0       	rjmp	.+128    	; 0x5f7a <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
    5efa:	a7 e2       	ldi	r26, 0x27	; 39
    5efc:	b0 e0       	ldi	r27, 0x00	; 0
    5efe:	e7 e2       	ldi	r30, 0x27	; 39
    5f00:	f0 e0       	ldi	r31, 0x00	; 0
    5f02:	80 81       	ld	r24, Z
    5f04:	48 2f       	mov	r20, r24
    5f06:	8a 81       	ldd	r24, Y+2	; 0x02
    5f08:	28 2f       	mov	r18, r24
    5f0a:	30 e0       	ldi	r19, 0x00	; 0
    5f0c:	81 e0       	ldi	r24, 0x01	; 1
    5f0e:	90 e0       	ldi	r25, 0x00	; 0
    5f10:	02 2e       	mov	r0, r18
    5f12:	02 c0       	rjmp	.+4      	; 0x5f18 <GPIO_setupPinDirection+0x164>
    5f14:	88 0f       	add	r24, r24
    5f16:	99 1f       	adc	r25, r25
    5f18:	0a 94       	dec	r0
    5f1a:	e2 f7       	brpl	.-8      	; 0x5f14 <GPIO_setupPinDirection+0x160>
    5f1c:	80 95       	com	r24
    5f1e:	84 23       	and	r24, r20
    5f20:	8c 93       	st	X, r24
    5f22:	2b c0       	rjmp	.+86     	; 0x5f7a <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
    5f24:	8b 81       	ldd	r24, Y+3	; 0x03
    5f26:	81 30       	cpi	r24, 0x01	; 1
    5f28:	a1 f4       	brne	.+40     	; 0x5f52 <GPIO_setupPinDirection+0x19e>
			{
				SET_BIT(DDRD,pin_num);
    5f2a:	aa e2       	ldi	r26, 0x2A	; 42
    5f2c:	b0 e0       	ldi	r27, 0x00	; 0
    5f2e:	ea e2       	ldi	r30, 0x2A	; 42
    5f30:	f0 e0       	ldi	r31, 0x00	; 0
    5f32:	80 81       	ld	r24, Z
    5f34:	48 2f       	mov	r20, r24
    5f36:	8a 81       	ldd	r24, Y+2	; 0x02
    5f38:	28 2f       	mov	r18, r24
    5f3a:	30 e0       	ldi	r19, 0x00	; 0
    5f3c:	81 e0       	ldi	r24, 0x01	; 1
    5f3e:	90 e0       	ldi	r25, 0x00	; 0
    5f40:	02 2e       	mov	r0, r18
    5f42:	02 c0       	rjmp	.+4      	; 0x5f48 <GPIO_setupPinDirection+0x194>
    5f44:	88 0f       	add	r24, r24
    5f46:	99 1f       	adc	r25, r25
    5f48:	0a 94       	dec	r0
    5f4a:	e2 f7       	brpl	.-8      	; 0x5f44 <GPIO_setupPinDirection+0x190>
    5f4c:	84 2b       	or	r24, r20
    5f4e:	8c 93       	st	X, r24
    5f50:	14 c0       	rjmp	.+40     	; 0x5f7a <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
    5f52:	aa e2       	ldi	r26, 0x2A	; 42
    5f54:	b0 e0       	ldi	r27, 0x00	; 0
    5f56:	ea e2       	ldi	r30, 0x2A	; 42
    5f58:	f0 e0       	ldi	r31, 0x00	; 0
    5f5a:	80 81       	ld	r24, Z
    5f5c:	48 2f       	mov	r20, r24
    5f5e:	8a 81       	ldd	r24, Y+2	; 0x02
    5f60:	28 2f       	mov	r18, r24
    5f62:	30 e0       	ldi	r19, 0x00	; 0
    5f64:	81 e0       	ldi	r24, 0x01	; 1
    5f66:	90 e0       	ldi	r25, 0x00	; 0
    5f68:	02 2e       	mov	r0, r18
    5f6a:	02 c0       	rjmp	.+4      	; 0x5f70 <GPIO_setupPinDirection+0x1bc>
    5f6c:	88 0f       	add	r24, r24
    5f6e:	99 1f       	adc	r25, r25
    5f70:	0a 94       	dec	r0
    5f72:	e2 f7       	brpl	.-8      	; 0x5f6c <GPIO_setupPinDirection+0x1b8>
    5f74:	80 95       	com	r24
    5f76:	84 23       	and	r24, r20
    5f78:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    5f7a:	0f 90       	pop	r0
    5f7c:	0f 90       	pop	r0
    5f7e:	0f 90       	pop	r0
    5f80:	0f 90       	pop	r0
    5f82:	0f 90       	pop	r0
    5f84:	cf 91       	pop	r28
    5f86:	df 91       	pop	r29
    5f88:	08 95       	ret

00005f8a <GPIO_writePin>:
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value)
{
    5f8a:	df 93       	push	r29
    5f8c:	cf 93       	push	r28
    5f8e:	00 d0       	rcall	.+0      	; 0x5f90 <GPIO_writePin+0x6>
    5f90:	00 d0       	rcall	.+0      	; 0x5f92 <GPIO_writePin+0x8>
    5f92:	0f 92       	push	r0
    5f94:	cd b7       	in	r28, 0x3d	; 61
    5f96:	de b7       	in	r29, 0x3e	; 62
    5f98:	89 83       	std	Y+1, r24	; 0x01
    5f9a:	6a 83       	std	Y+2, r22	; 0x02
    5f9c:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    5f9e:	8a 81       	ldd	r24, Y+2	; 0x02
    5fa0:	88 30       	cpi	r24, 0x08	; 8
    5fa2:	08 f0       	brcs	.+2      	; 0x5fa6 <GPIO_writePin+0x1c>
    5fa4:	d5 c0       	rjmp	.+426    	; 0x6150 <GPIO_writePin+0x1c6>
    5fa6:	89 81       	ldd	r24, Y+1	; 0x01
    5fa8:	84 30       	cpi	r24, 0x04	; 4
    5faa:	08 f0       	brcs	.+2      	; 0x5fae <GPIO_writePin+0x24>
    5fac:	d1 c0       	rjmp	.+418    	; 0x6150 <GPIO_writePin+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
    5fae:	89 81       	ldd	r24, Y+1	; 0x01
    5fb0:	28 2f       	mov	r18, r24
    5fb2:	30 e0       	ldi	r19, 0x00	; 0
    5fb4:	3d 83       	std	Y+5, r19	; 0x05
    5fb6:	2c 83       	std	Y+4, r18	; 0x04
    5fb8:	8c 81       	ldd	r24, Y+4	; 0x04
    5fba:	9d 81       	ldd	r25, Y+5	; 0x05
    5fbc:	81 30       	cpi	r24, 0x01	; 1
    5fbe:	91 05       	cpc	r25, r1
    5fc0:	09 f4       	brne	.+2      	; 0x5fc4 <GPIO_writePin+0x3a>
    5fc2:	43 c0       	rjmp	.+134    	; 0x604a <GPIO_writePin+0xc0>
    5fc4:	2c 81       	ldd	r18, Y+4	; 0x04
    5fc6:	3d 81       	ldd	r19, Y+5	; 0x05
    5fc8:	22 30       	cpi	r18, 0x02	; 2
    5fca:	31 05       	cpc	r19, r1
    5fcc:	2c f4       	brge	.+10     	; 0x5fd8 <GPIO_writePin+0x4e>
    5fce:	8c 81       	ldd	r24, Y+4	; 0x04
    5fd0:	9d 81       	ldd	r25, Y+5	; 0x05
    5fd2:	00 97       	sbiw	r24, 0x00	; 0
    5fd4:	71 f0       	breq	.+28     	; 0x5ff2 <GPIO_writePin+0x68>
    5fd6:	bc c0       	rjmp	.+376    	; 0x6150 <GPIO_writePin+0x1c6>
    5fd8:	2c 81       	ldd	r18, Y+4	; 0x04
    5fda:	3d 81       	ldd	r19, Y+5	; 0x05
    5fdc:	22 30       	cpi	r18, 0x02	; 2
    5fde:	31 05       	cpc	r19, r1
    5fe0:	09 f4       	brne	.+2      	; 0x5fe4 <GPIO_writePin+0x5a>
    5fe2:	5f c0       	rjmp	.+190    	; 0x60a2 <GPIO_writePin+0x118>
    5fe4:	8c 81       	ldd	r24, Y+4	; 0x04
    5fe6:	9d 81       	ldd	r25, Y+5	; 0x05
    5fe8:	83 30       	cpi	r24, 0x03	; 3
    5fea:	91 05       	cpc	r25, r1
    5fec:	09 f4       	brne	.+2      	; 0x5ff0 <GPIO_writePin+0x66>
    5fee:	85 c0       	rjmp	.+266    	; 0x60fa <GPIO_writePin+0x170>
    5ff0:	af c0       	rjmp	.+350    	; 0x6150 <GPIO_writePin+0x1c6>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH)
    5ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    5ff4:	81 30       	cpi	r24, 0x01	; 1
    5ff6:	a1 f4       	brne	.+40     	; 0x6020 <GPIO_writePin+0x96>
			{
				SET_BIT(PORTA,pin_num);
    5ff8:	a2 e2       	ldi	r26, 0x22	; 34
    5ffa:	b0 e0       	ldi	r27, 0x00	; 0
    5ffc:	e2 e2       	ldi	r30, 0x22	; 34
    5ffe:	f0 e0       	ldi	r31, 0x00	; 0
    6000:	80 81       	ld	r24, Z
    6002:	48 2f       	mov	r20, r24
    6004:	8a 81       	ldd	r24, Y+2	; 0x02
    6006:	28 2f       	mov	r18, r24
    6008:	30 e0       	ldi	r19, 0x00	; 0
    600a:	81 e0       	ldi	r24, 0x01	; 1
    600c:	90 e0       	ldi	r25, 0x00	; 0
    600e:	02 2e       	mov	r0, r18
    6010:	02 c0       	rjmp	.+4      	; 0x6016 <GPIO_writePin+0x8c>
    6012:	88 0f       	add	r24, r24
    6014:	99 1f       	adc	r25, r25
    6016:	0a 94       	dec	r0
    6018:	e2 f7       	brpl	.-8      	; 0x6012 <GPIO_writePin+0x88>
    601a:	84 2b       	or	r24, r20
    601c:	8c 93       	st	X, r24
    601e:	98 c0       	rjmp	.+304    	; 0x6150 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTA,pin_num);
    6020:	a2 e2       	ldi	r26, 0x22	; 34
    6022:	b0 e0       	ldi	r27, 0x00	; 0
    6024:	e2 e2       	ldi	r30, 0x22	; 34
    6026:	f0 e0       	ldi	r31, 0x00	; 0
    6028:	80 81       	ld	r24, Z
    602a:	48 2f       	mov	r20, r24
    602c:	8a 81       	ldd	r24, Y+2	; 0x02
    602e:	28 2f       	mov	r18, r24
    6030:	30 e0       	ldi	r19, 0x00	; 0
    6032:	81 e0       	ldi	r24, 0x01	; 1
    6034:	90 e0       	ldi	r25, 0x00	; 0
    6036:	02 2e       	mov	r0, r18
    6038:	02 c0       	rjmp	.+4      	; 0x603e <GPIO_writePin+0xb4>
    603a:	88 0f       	add	r24, r24
    603c:	99 1f       	adc	r25, r25
    603e:	0a 94       	dec	r0
    6040:	e2 f7       	brpl	.-8      	; 0x603a <GPIO_writePin+0xb0>
    6042:	80 95       	com	r24
    6044:	84 23       	and	r24, r20
    6046:	8c 93       	st	X, r24
    6048:	83 c0       	rjmp	.+262    	; 0x6150 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTB_ID:
			if(value == LOGIC_HIGH)
    604a:	8b 81       	ldd	r24, Y+3	; 0x03
    604c:	81 30       	cpi	r24, 0x01	; 1
    604e:	a1 f4       	brne	.+40     	; 0x6078 <GPIO_writePin+0xee>
			{
				SET_BIT(PORTB,pin_num);
    6050:	a5 e2       	ldi	r26, 0x25	; 37
    6052:	b0 e0       	ldi	r27, 0x00	; 0
    6054:	e5 e2       	ldi	r30, 0x25	; 37
    6056:	f0 e0       	ldi	r31, 0x00	; 0
    6058:	80 81       	ld	r24, Z
    605a:	48 2f       	mov	r20, r24
    605c:	8a 81       	ldd	r24, Y+2	; 0x02
    605e:	28 2f       	mov	r18, r24
    6060:	30 e0       	ldi	r19, 0x00	; 0
    6062:	81 e0       	ldi	r24, 0x01	; 1
    6064:	90 e0       	ldi	r25, 0x00	; 0
    6066:	02 2e       	mov	r0, r18
    6068:	02 c0       	rjmp	.+4      	; 0x606e <GPIO_writePin+0xe4>
    606a:	88 0f       	add	r24, r24
    606c:	99 1f       	adc	r25, r25
    606e:	0a 94       	dec	r0
    6070:	e2 f7       	brpl	.-8      	; 0x606a <GPIO_writePin+0xe0>
    6072:	84 2b       	or	r24, r20
    6074:	8c 93       	st	X, r24
    6076:	6c c0       	rjmp	.+216    	; 0x6150 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTB,pin_num);
    6078:	a5 e2       	ldi	r26, 0x25	; 37
    607a:	b0 e0       	ldi	r27, 0x00	; 0
    607c:	e5 e2       	ldi	r30, 0x25	; 37
    607e:	f0 e0       	ldi	r31, 0x00	; 0
    6080:	80 81       	ld	r24, Z
    6082:	48 2f       	mov	r20, r24
    6084:	8a 81       	ldd	r24, Y+2	; 0x02
    6086:	28 2f       	mov	r18, r24
    6088:	30 e0       	ldi	r19, 0x00	; 0
    608a:	81 e0       	ldi	r24, 0x01	; 1
    608c:	90 e0       	ldi	r25, 0x00	; 0
    608e:	02 2e       	mov	r0, r18
    6090:	02 c0       	rjmp	.+4      	; 0x6096 <GPIO_writePin+0x10c>
    6092:	88 0f       	add	r24, r24
    6094:	99 1f       	adc	r25, r25
    6096:	0a 94       	dec	r0
    6098:	e2 f7       	brpl	.-8      	; 0x6092 <GPIO_writePin+0x108>
    609a:	80 95       	com	r24
    609c:	84 23       	and	r24, r20
    609e:	8c 93       	st	X, r24
    60a0:	57 c0       	rjmp	.+174    	; 0x6150 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH)
    60a2:	8b 81       	ldd	r24, Y+3	; 0x03
    60a4:	81 30       	cpi	r24, 0x01	; 1
    60a6:	a1 f4       	brne	.+40     	; 0x60d0 <GPIO_writePin+0x146>
			{
				SET_BIT(PORTC,pin_num);
    60a8:	a8 e2       	ldi	r26, 0x28	; 40
    60aa:	b0 e0       	ldi	r27, 0x00	; 0
    60ac:	e8 e2       	ldi	r30, 0x28	; 40
    60ae:	f0 e0       	ldi	r31, 0x00	; 0
    60b0:	80 81       	ld	r24, Z
    60b2:	48 2f       	mov	r20, r24
    60b4:	8a 81       	ldd	r24, Y+2	; 0x02
    60b6:	28 2f       	mov	r18, r24
    60b8:	30 e0       	ldi	r19, 0x00	; 0
    60ba:	81 e0       	ldi	r24, 0x01	; 1
    60bc:	90 e0       	ldi	r25, 0x00	; 0
    60be:	02 2e       	mov	r0, r18
    60c0:	02 c0       	rjmp	.+4      	; 0x60c6 <GPIO_writePin+0x13c>
    60c2:	88 0f       	add	r24, r24
    60c4:	99 1f       	adc	r25, r25
    60c6:	0a 94       	dec	r0
    60c8:	e2 f7       	brpl	.-8      	; 0x60c2 <GPIO_writePin+0x138>
    60ca:	84 2b       	or	r24, r20
    60cc:	8c 93       	st	X, r24
    60ce:	40 c0       	rjmp	.+128    	; 0x6150 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTC,pin_num);
    60d0:	a8 e2       	ldi	r26, 0x28	; 40
    60d2:	b0 e0       	ldi	r27, 0x00	; 0
    60d4:	e8 e2       	ldi	r30, 0x28	; 40
    60d6:	f0 e0       	ldi	r31, 0x00	; 0
    60d8:	80 81       	ld	r24, Z
    60da:	48 2f       	mov	r20, r24
    60dc:	8a 81       	ldd	r24, Y+2	; 0x02
    60de:	28 2f       	mov	r18, r24
    60e0:	30 e0       	ldi	r19, 0x00	; 0
    60e2:	81 e0       	ldi	r24, 0x01	; 1
    60e4:	90 e0       	ldi	r25, 0x00	; 0
    60e6:	02 2e       	mov	r0, r18
    60e8:	02 c0       	rjmp	.+4      	; 0x60ee <GPIO_writePin+0x164>
    60ea:	88 0f       	add	r24, r24
    60ec:	99 1f       	adc	r25, r25
    60ee:	0a 94       	dec	r0
    60f0:	e2 f7       	brpl	.-8      	; 0x60ea <GPIO_writePin+0x160>
    60f2:	80 95       	com	r24
    60f4:	84 23       	and	r24, r20
    60f6:	8c 93       	st	X, r24
    60f8:	2b c0       	rjmp	.+86     	; 0x6150 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH)
    60fa:	8b 81       	ldd	r24, Y+3	; 0x03
    60fc:	81 30       	cpi	r24, 0x01	; 1
    60fe:	a1 f4       	brne	.+40     	; 0x6128 <GPIO_writePin+0x19e>
			{
				SET_BIT(PORTD,pin_num);
    6100:	ab e2       	ldi	r26, 0x2B	; 43
    6102:	b0 e0       	ldi	r27, 0x00	; 0
    6104:	eb e2       	ldi	r30, 0x2B	; 43
    6106:	f0 e0       	ldi	r31, 0x00	; 0
    6108:	80 81       	ld	r24, Z
    610a:	48 2f       	mov	r20, r24
    610c:	8a 81       	ldd	r24, Y+2	; 0x02
    610e:	28 2f       	mov	r18, r24
    6110:	30 e0       	ldi	r19, 0x00	; 0
    6112:	81 e0       	ldi	r24, 0x01	; 1
    6114:	90 e0       	ldi	r25, 0x00	; 0
    6116:	02 2e       	mov	r0, r18
    6118:	02 c0       	rjmp	.+4      	; 0x611e <GPIO_writePin+0x194>
    611a:	88 0f       	add	r24, r24
    611c:	99 1f       	adc	r25, r25
    611e:	0a 94       	dec	r0
    6120:	e2 f7       	brpl	.-8      	; 0x611a <GPIO_writePin+0x190>
    6122:	84 2b       	or	r24, r20
    6124:	8c 93       	st	X, r24
    6126:	14 c0       	rjmp	.+40     	; 0x6150 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTD,pin_num);
    6128:	ab e2       	ldi	r26, 0x2B	; 43
    612a:	b0 e0       	ldi	r27, 0x00	; 0
    612c:	eb e2       	ldi	r30, 0x2B	; 43
    612e:	f0 e0       	ldi	r31, 0x00	; 0
    6130:	80 81       	ld	r24, Z
    6132:	48 2f       	mov	r20, r24
    6134:	8a 81       	ldd	r24, Y+2	; 0x02
    6136:	28 2f       	mov	r18, r24
    6138:	30 e0       	ldi	r19, 0x00	; 0
    613a:	81 e0       	ldi	r24, 0x01	; 1
    613c:	90 e0       	ldi	r25, 0x00	; 0
    613e:	02 2e       	mov	r0, r18
    6140:	02 c0       	rjmp	.+4      	; 0x6146 <GPIO_writePin+0x1bc>
    6142:	88 0f       	add	r24, r24
    6144:	99 1f       	adc	r25, r25
    6146:	0a 94       	dec	r0
    6148:	e2 f7       	brpl	.-8      	; 0x6142 <GPIO_writePin+0x1b8>
    614a:	80 95       	com	r24
    614c:	84 23       	and	r24, r20
    614e:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    6150:	0f 90       	pop	r0
    6152:	0f 90       	pop	r0
    6154:	0f 90       	pop	r0
    6156:	0f 90       	pop	r0
    6158:	0f 90       	pop	r0
    615a:	cf 91       	pop	r28
    615c:	df 91       	pop	r29
    615e:	08 95       	ret

00006160 <GPIO_togglePin>:
 * Write the value toggle on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 *
 */
void GPIO_togglePin(uint8 port_num, uint8 pin_num)
{
    6160:	df 93       	push	r29
    6162:	cf 93       	push	r28
    6164:	00 d0       	rcall	.+0      	; 0x6166 <GPIO_togglePin+0x6>
    6166:	00 d0       	rcall	.+0      	; 0x6168 <GPIO_togglePin+0x8>
    6168:	cd b7       	in	r28, 0x3d	; 61
    616a:	de b7       	in	r29, 0x3e	; 62
    616c:	89 83       	std	Y+1, r24	; 0x01
    616e:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    6170:	8a 81       	ldd	r24, Y+2	; 0x02
    6172:	88 30       	cpi	r24, 0x08	; 8
    6174:	08 f0       	brcs	.+2      	; 0x6178 <GPIO_togglePin+0x18>
    6176:	72 c0       	rjmp	.+228    	; 0x625c <GPIO_togglePin+0xfc>
    6178:	89 81       	ldd	r24, Y+1	; 0x01
    617a:	84 30       	cpi	r24, 0x04	; 4
    617c:	08 f0       	brcs	.+2      	; 0x6180 <GPIO_togglePin+0x20>
    617e:	6e c0       	rjmp	.+220    	; 0x625c <GPIO_togglePin+0xfc>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
    6180:	89 81       	ldd	r24, Y+1	; 0x01
    6182:	28 2f       	mov	r18, r24
    6184:	30 e0       	ldi	r19, 0x00	; 0
    6186:	3c 83       	std	Y+4, r19	; 0x04
    6188:	2b 83       	std	Y+3, r18	; 0x03
    618a:	8b 81       	ldd	r24, Y+3	; 0x03
    618c:	9c 81       	ldd	r25, Y+4	; 0x04
    618e:	81 30       	cpi	r24, 0x01	; 1
    6190:	91 05       	cpc	r25, r1
    6192:	49 f1       	breq	.+82     	; 0x61e6 <GPIO_togglePin+0x86>
    6194:	2b 81       	ldd	r18, Y+3	; 0x03
    6196:	3c 81       	ldd	r19, Y+4	; 0x04
    6198:	22 30       	cpi	r18, 0x02	; 2
    619a:	31 05       	cpc	r19, r1
    619c:	2c f4       	brge	.+10     	; 0x61a8 <GPIO_togglePin+0x48>
    619e:	8b 81       	ldd	r24, Y+3	; 0x03
    61a0:	9c 81       	ldd	r25, Y+4	; 0x04
    61a2:	00 97       	sbiw	r24, 0x00	; 0
    61a4:	61 f0       	breq	.+24     	; 0x61be <GPIO_togglePin+0x5e>
    61a6:	5a c0       	rjmp	.+180    	; 0x625c <GPIO_togglePin+0xfc>
    61a8:	2b 81       	ldd	r18, Y+3	; 0x03
    61aa:	3c 81       	ldd	r19, Y+4	; 0x04
    61ac:	22 30       	cpi	r18, 0x02	; 2
    61ae:	31 05       	cpc	r19, r1
    61b0:	71 f1       	breq	.+92     	; 0x620e <GPIO_togglePin+0xae>
    61b2:	8b 81       	ldd	r24, Y+3	; 0x03
    61b4:	9c 81       	ldd	r25, Y+4	; 0x04
    61b6:	83 30       	cpi	r24, 0x03	; 3
    61b8:	91 05       	cpc	r25, r1
    61ba:	e9 f1       	breq	.+122    	; 0x6236 <GPIO_togglePin+0xd6>
    61bc:	4f c0       	rjmp	.+158    	; 0x625c <GPIO_togglePin+0xfc>
		{
		case PORTA_ID:
			TOGGLE_BIT(PORTA,pin_num);
    61be:	a2 e2       	ldi	r26, 0x22	; 34
    61c0:	b0 e0       	ldi	r27, 0x00	; 0
    61c2:	e2 e2       	ldi	r30, 0x22	; 34
    61c4:	f0 e0       	ldi	r31, 0x00	; 0
    61c6:	80 81       	ld	r24, Z
    61c8:	48 2f       	mov	r20, r24
    61ca:	8a 81       	ldd	r24, Y+2	; 0x02
    61cc:	28 2f       	mov	r18, r24
    61ce:	30 e0       	ldi	r19, 0x00	; 0
    61d0:	81 e0       	ldi	r24, 0x01	; 1
    61d2:	90 e0       	ldi	r25, 0x00	; 0
    61d4:	02 2e       	mov	r0, r18
    61d6:	02 c0       	rjmp	.+4      	; 0x61dc <GPIO_togglePin+0x7c>
    61d8:	88 0f       	add	r24, r24
    61da:	99 1f       	adc	r25, r25
    61dc:	0a 94       	dec	r0
    61de:	e2 f7       	brpl	.-8      	; 0x61d8 <GPIO_togglePin+0x78>
    61e0:	84 27       	eor	r24, r20
    61e2:	8c 93       	st	X, r24
    61e4:	3b c0       	rjmp	.+118    	; 0x625c <GPIO_togglePin+0xfc>
			break;
		case PORTB_ID:
			TOGGLE_BIT(PORTB,pin_num);
    61e6:	a5 e2       	ldi	r26, 0x25	; 37
    61e8:	b0 e0       	ldi	r27, 0x00	; 0
    61ea:	e5 e2       	ldi	r30, 0x25	; 37
    61ec:	f0 e0       	ldi	r31, 0x00	; 0
    61ee:	80 81       	ld	r24, Z
    61f0:	48 2f       	mov	r20, r24
    61f2:	8a 81       	ldd	r24, Y+2	; 0x02
    61f4:	28 2f       	mov	r18, r24
    61f6:	30 e0       	ldi	r19, 0x00	; 0
    61f8:	81 e0       	ldi	r24, 0x01	; 1
    61fa:	90 e0       	ldi	r25, 0x00	; 0
    61fc:	02 2e       	mov	r0, r18
    61fe:	02 c0       	rjmp	.+4      	; 0x6204 <GPIO_togglePin+0xa4>
    6200:	88 0f       	add	r24, r24
    6202:	99 1f       	adc	r25, r25
    6204:	0a 94       	dec	r0
    6206:	e2 f7       	brpl	.-8      	; 0x6200 <GPIO_togglePin+0xa0>
    6208:	84 27       	eor	r24, r20
    620a:	8c 93       	st	X, r24
    620c:	27 c0       	rjmp	.+78     	; 0x625c <GPIO_togglePin+0xfc>
			break;
		case PORTC_ID:
			TOGGLE_BIT(PORTC,pin_num);
    620e:	a8 e2       	ldi	r26, 0x28	; 40
    6210:	b0 e0       	ldi	r27, 0x00	; 0
    6212:	e8 e2       	ldi	r30, 0x28	; 40
    6214:	f0 e0       	ldi	r31, 0x00	; 0
    6216:	80 81       	ld	r24, Z
    6218:	48 2f       	mov	r20, r24
    621a:	8a 81       	ldd	r24, Y+2	; 0x02
    621c:	28 2f       	mov	r18, r24
    621e:	30 e0       	ldi	r19, 0x00	; 0
    6220:	81 e0       	ldi	r24, 0x01	; 1
    6222:	90 e0       	ldi	r25, 0x00	; 0
    6224:	02 2e       	mov	r0, r18
    6226:	02 c0       	rjmp	.+4      	; 0x622c <GPIO_togglePin+0xcc>
    6228:	88 0f       	add	r24, r24
    622a:	99 1f       	adc	r25, r25
    622c:	0a 94       	dec	r0
    622e:	e2 f7       	brpl	.-8      	; 0x6228 <GPIO_togglePin+0xc8>
    6230:	84 27       	eor	r24, r20
    6232:	8c 93       	st	X, r24
    6234:	13 c0       	rjmp	.+38     	; 0x625c <GPIO_togglePin+0xfc>
			break;
		case PORTD_ID:
			TOGGLE_BIT(PORTD,pin_num);
    6236:	ab e2       	ldi	r26, 0x2B	; 43
    6238:	b0 e0       	ldi	r27, 0x00	; 0
    623a:	eb e2       	ldi	r30, 0x2B	; 43
    623c:	f0 e0       	ldi	r31, 0x00	; 0
    623e:	80 81       	ld	r24, Z
    6240:	48 2f       	mov	r20, r24
    6242:	8a 81       	ldd	r24, Y+2	; 0x02
    6244:	28 2f       	mov	r18, r24
    6246:	30 e0       	ldi	r19, 0x00	; 0
    6248:	81 e0       	ldi	r24, 0x01	; 1
    624a:	90 e0       	ldi	r25, 0x00	; 0
    624c:	02 2e       	mov	r0, r18
    624e:	02 c0       	rjmp	.+4      	; 0x6254 <GPIO_togglePin+0xf4>
    6250:	88 0f       	add	r24, r24
    6252:	99 1f       	adc	r25, r25
    6254:	0a 94       	dec	r0
    6256:	e2 f7       	brpl	.-8      	; 0x6250 <GPIO_togglePin+0xf0>
    6258:	84 27       	eor	r24, r20
    625a:	8c 93       	st	X, r24
			break;
		}
	}
}
    625c:	0f 90       	pop	r0
    625e:	0f 90       	pop	r0
    6260:	0f 90       	pop	r0
    6262:	0f 90       	pop	r0
    6264:	cf 91       	pop	r28
    6266:	df 91       	pop	r29
    6268:	08 95       	ret

0000626a <GPIO_readPin>:
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num)
{
    626a:	df 93       	push	r29
    626c:	cf 93       	push	r28
    626e:	00 d0       	rcall	.+0      	; 0x6270 <GPIO_readPin+0x6>
    6270:	00 d0       	rcall	.+0      	; 0x6272 <GPIO_readPin+0x8>
    6272:	0f 92       	push	r0
    6274:	cd b7       	in	r28, 0x3d	; 61
    6276:	de b7       	in	r29, 0x3e	; 62
    6278:	8a 83       	std	Y+2, r24	; 0x02
    627a:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    627c:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    627e:	8b 81       	ldd	r24, Y+3	; 0x03
    6280:	88 30       	cpi	r24, 0x08	; 8
    6282:	08 f0       	brcs	.+2      	; 0x6286 <GPIO_readPin+0x1c>
    6284:	84 c0       	rjmp	.+264    	; 0x638e <GPIO_readPin+0x124>
    6286:	8a 81       	ldd	r24, Y+2	; 0x02
    6288:	84 30       	cpi	r24, 0x04	; 4
    628a:	08 f0       	brcs	.+2      	; 0x628e <GPIO_readPin+0x24>
    628c:	80 c0       	rjmp	.+256    	; 0x638e <GPIO_readPin+0x124>
		/* Do Nothing */
	}
	else
	{
		/* Read the pin value as required */
		switch(port_num)
    628e:	8a 81       	ldd	r24, Y+2	; 0x02
    6290:	28 2f       	mov	r18, r24
    6292:	30 e0       	ldi	r19, 0x00	; 0
    6294:	3d 83       	std	Y+5, r19	; 0x05
    6296:	2c 83       	std	Y+4, r18	; 0x04
    6298:	4c 81       	ldd	r20, Y+4	; 0x04
    629a:	5d 81       	ldd	r21, Y+5	; 0x05
    629c:	41 30       	cpi	r20, 0x01	; 1
    629e:	51 05       	cpc	r21, r1
    62a0:	79 f1       	breq	.+94     	; 0x6300 <GPIO_readPin+0x96>
    62a2:	8c 81       	ldd	r24, Y+4	; 0x04
    62a4:	9d 81       	ldd	r25, Y+5	; 0x05
    62a6:	82 30       	cpi	r24, 0x02	; 2
    62a8:	91 05       	cpc	r25, r1
    62aa:	34 f4       	brge	.+12     	; 0x62b8 <GPIO_readPin+0x4e>
    62ac:	2c 81       	ldd	r18, Y+4	; 0x04
    62ae:	3d 81       	ldd	r19, Y+5	; 0x05
    62b0:	21 15       	cp	r18, r1
    62b2:	31 05       	cpc	r19, r1
    62b4:	69 f0       	breq	.+26     	; 0x62d0 <GPIO_readPin+0x66>
    62b6:	6b c0       	rjmp	.+214    	; 0x638e <GPIO_readPin+0x124>
    62b8:	4c 81       	ldd	r20, Y+4	; 0x04
    62ba:	5d 81       	ldd	r21, Y+5	; 0x05
    62bc:	42 30       	cpi	r20, 0x02	; 2
    62be:	51 05       	cpc	r21, r1
    62c0:	b9 f1       	breq	.+110    	; 0x6330 <GPIO_readPin+0xc6>
    62c2:	8c 81       	ldd	r24, Y+4	; 0x04
    62c4:	9d 81       	ldd	r25, Y+5	; 0x05
    62c6:	83 30       	cpi	r24, 0x03	; 3
    62c8:	91 05       	cpc	r25, r1
    62ca:	09 f4       	brne	.+2      	; 0x62ce <GPIO_readPin+0x64>
    62cc:	49 c0       	rjmp	.+146    	; 0x6360 <GPIO_readPin+0xf6>
    62ce:	5f c0       	rjmp	.+190    	; 0x638e <GPIO_readPin+0x124>
		{
		case PORTA_ID:
			if(BIT_IS_SET(PINA,pin_num))
    62d0:	e0 e2       	ldi	r30, 0x20	; 32
    62d2:	f0 e0       	ldi	r31, 0x00	; 0
    62d4:	80 81       	ld	r24, Z
    62d6:	28 2f       	mov	r18, r24
    62d8:	30 e0       	ldi	r19, 0x00	; 0
    62da:	8b 81       	ldd	r24, Y+3	; 0x03
    62dc:	88 2f       	mov	r24, r24
    62de:	90 e0       	ldi	r25, 0x00	; 0
    62e0:	a9 01       	movw	r20, r18
    62e2:	02 c0       	rjmp	.+4      	; 0x62e8 <GPIO_readPin+0x7e>
    62e4:	55 95       	asr	r21
    62e6:	47 95       	ror	r20
    62e8:	8a 95       	dec	r24
    62ea:	e2 f7       	brpl	.-8      	; 0x62e4 <GPIO_readPin+0x7a>
    62ec:	ca 01       	movw	r24, r20
    62ee:	81 70       	andi	r24, 0x01	; 1
    62f0:	90 70       	andi	r25, 0x00	; 0
    62f2:	88 23       	and	r24, r24
    62f4:	19 f0       	breq	.+6      	; 0x62fc <GPIO_readPin+0x92>
			{
				pin_value = LOGIC_HIGH;
    62f6:	81 e0       	ldi	r24, 0x01	; 1
    62f8:	89 83       	std	Y+1, r24	; 0x01
    62fa:	49 c0       	rjmp	.+146    	; 0x638e <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    62fc:	19 82       	std	Y+1, r1	; 0x01
    62fe:	47 c0       	rjmp	.+142    	; 0x638e <GPIO_readPin+0x124>
			}
			break;
		case PORTB_ID:
			if(BIT_IS_SET(PINB,pin_num))
    6300:	e3 e2       	ldi	r30, 0x23	; 35
    6302:	f0 e0       	ldi	r31, 0x00	; 0
    6304:	80 81       	ld	r24, Z
    6306:	28 2f       	mov	r18, r24
    6308:	30 e0       	ldi	r19, 0x00	; 0
    630a:	8b 81       	ldd	r24, Y+3	; 0x03
    630c:	88 2f       	mov	r24, r24
    630e:	90 e0       	ldi	r25, 0x00	; 0
    6310:	a9 01       	movw	r20, r18
    6312:	02 c0       	rjmp	.+4      	; 0x6318 <GPIO_readPin+0xae>
    6314:	55 95       	asr	r21
    6316:	47 95       	ror	r20
    6318:	8a 95       	dec	r24
    631a:	e2 f7       	brpl	.-8      	; 0x6314 <GPIO_readPin+0xaa>
    631c:	ca 01       	movw	r24, r20
    631e:	81 70       	andi	r24, 0x01	; 1
    6320:	90 70       	andi	r25, 0x00	; 0
    6322:	88 23       	and	r24, r24
    6324:	19 f0       	breq	.+6      	; 0x632c <GPIO_readPin+0xc2>
			{
				pin_value = LOGIC_HIGH;
    6326:	81 e0       	ldi	r24, 0x01	; 1
    6328:	89 83       	std	Y+1, r24	; 0x01
    632a:	31 c0       	rjmp	.+98     	; 0x638e <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    632c:	19 82       	std	Y+1, r1	; 0x01
    632e:	2f c0       	rjmp	.+94     	; 0x638e <GPIO_readPin+0x124>
			}
			break;
		case PORTC_ID:
			if(BIT_IS_SET(PINC,pin_num))
    6330:	e6 e2       	ldi	r30, 0x26	; 38
    6332:	f0 e0       	ldi	r31, 0x00	; 0
    6334:	80 81       	ld	r24, Z
    6336:	28 2f       	mov	r18, r24
    6338:	30 e0       	ldi	r19, 0x00	; 0
    633a:	8b 81       	ldd	r24, Y+3	; 0x03
    633c:	88 2f       	mov	r24, r24
    633e:	90 e0       	ldi	r25, 0x00	; 0
    6340:	a9 01       	movw	r20, r18
    6342:	02 c0       	rjmp	.+4      	; 0x6348 <GPIO_readPin+0xde>
    6344:	55 95       	asr	r21
    6346:	47 95       	ror	r20
    6348:	8a 95       	dec	r24
    634a:	e2 f7       	brpl	.-8      	; 0x6344 <GPIO_readPin+0xda>
    634c:	ca 01       	movw	r24, r20
    634e:	81 70       	andi	r24, 0x01	; 1
    6350:	90 70       	andi	r25, 0x00	; 0
    6352:	88 23       	and	r24, r24
    6354:	19 f0       	breq	.+6      	; 0x635c <GPIO_readPin+0xf2>
			{
				pin_value = LOGIC_HIGH;
    6356:	81 e0       	ldi	r24, 0x01	; 1
    6358:	89 83       	std	Y+1, r24	; 0x01
    635a:	19 c0       	rjmp	.+50     	; 0x638e <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    635c:	19 82       	std	Y+1, r1	; 0x01
    635e:	17 c0       	rjmp	.+46     	; 0x638e <GPIO_readPin+0x124>
			}
			break;
		case PORTD_ID:
			if(BIT_IS_SET(PIND,pin_num))
    6360:	e9 e2       	ldi	r30, 0x29	; 41
    6362:	f0 e0       	ldi	r31, 0x00	; 0
    6364:	80 81       	ld	r24, Z
    6366:	28 2f       	mov	r18, r24
    6368:	30 e0       	ldi	r19, 0x00	; 0
    636a:	8b 81       	ldd	r24, Y+3	; 0x03
    636c:	88 2f       	mov	r24, r24
    636e:	90 e0       	ldi	r25, 0x00	; 0
    6370:	a9 01       	movw	r20, r18
    6372:	02 c0       	rjmp	.+4      	; 0x6378 <GPIO_readPin+0x10e>
    6374:	55 95       	asr	r21
    6376:	47 95       	ror	r20
    6378:	8a 95       	dec	r24
    637a:	e2 f7       	brpl	.-8      	; 0x6374 <GPIO_readPin+0x10a>
    637c:	ca 01       	movw	r24, r20
    637e:	81 70       	andi	r24, 0x01	; 1
    6380:	90 70       	andi	r25, 0x00	; 0
    6382:	88 23       	and	r24, r24
    6384:	19 f0       	breq	.+6      	; 0x638c <GPIO_readPin+0x122>
			{
				pin_value = LOGIC_HIGH;
    6386:	81 e0       	ldi	r24, 0x01	; 1
    6388:	89 83       	std	Y+1, r24	; 0x01
    638a:	01 c0       	rjmp	.+2      	; 0x638e <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    638c:	19 82       	std	Y+1, r1	; 0x01
			}
			break;
		}
	}

	return pin_value;
    638e:	89 81       	ldd	r24, Y+1	; 0x01
}
    6390:	0f 90       	pop	r0
    6392:	0f 90       	pop	r0
    6394:	0f 90       	pop	r0
    6396:	0f 90       	pop	r0
    6398:	0f 90       	pop	r0
    639a:	cf 91       	pop	r28
    639c:	df 91       	pop	r29
    639e:	08 95       	ret

000063a0 <GPIO_setupPortDirection>:
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction)
{
    63a0:	df 93       	push	r29
    63a2:	cf 93       	push	r28
    63a4:	00 d0       	rcall	.+0      	; 0x63a6 <GPIO_setupPortDirection+0x6>
    63a6:	00 d0       	rcall	.+0      	; 0x63a8 <GPIO_setupPortDirection+0x8>
    63a8:	cd b7       	in	r28, 0x3d	; 61
    63aa:	de b7       	in	r29, 0x3e	; 62
    63ac:	89 83       	std	Y+1, r24	; 0x01
    63ae:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    63b0:	89 81       	ldd	r24, Y+1	; 0x01
    63b2:	84 30       	cpi	r24, 0x04	; 4
    63b4:	90 f5       	brcc	.+100    	; 0x641a <GPIO_setupPortDirection+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Setup the port direction as required */
		switch(port_num)
    63b6:	89 81       	ldd	r24, Y+1	; 0x01
    63b8:	28 2f       	mov	r18, r24
    63ba:	30 e0       	ldi	r19, 0x00	; 0
    63bc:	3c 83       	std	Y+4, r19	; 0x04
    63be:	2b 83       	std	Y+3, r18	; 0x03
    63c0:	8b 81       	ldd	r24, Y+3	; 0x03
    63c2:	9c 81       	ldd	r25, Y+4	; 0x04
    63c4:	81 30       	cpi	r24, 0x01	; 1
    63c6:	91 05       	cpc	r25, r1
    63c8:	d1 f0       	breq	.+52     	; 0x63fe <GPIO_setupPortDirection+0x5e>
    63ca:	2b 81       	ldd	r18, Y+3	; 0x03
    63cc:	3c 81       	ldd	r19, Y+4	; 0x04
    63ce:	22 30       	cpi	r18, 0x02	; 2
    63d0:	31 05       	cpc	r19, r1
    63d2:	2c f4       	brge	.+10     	; 0x63de <GPIO_setupPortDirection+0x3e>
    63d4:	8b 81       	ldd	r24, Y+3	; 0x03
    63d6:	9c 81       	ldd	r25, Y+4	; 0x04
    63d8:	00 97       	sbiw	r24, 0x00	; 0
    63da:	61 f0       	breq	.+24     	; 0x63f4 <GPIO_setupPortDirection+0x54>
    63dc:	1e c0       	rjmp	.+60     	; 0x641a <GPIO_setupPortDirection+0x7a>
    63de:	2b 81       	ldd	r18, Y+3	; 0x03
    63e0:	3c 81       	ldd	r19, Y+4	; 0x04
    63e2:	22 30       	cpi	r18, 0x02	; 2
    63e4:	31 05       	cpc	r19, r1
    63e6:	81 f0       	breq	.+32     	; 0x6408 <GPIO_setupPortDirection+0x68>
    63e8:	8b 81       	ldd	r24, Y+3	; 0x03
    63ea:	9c 81       	ldd	r25, Y+4	; 0x04
    63ec:	83 30       	cpi	r24, 0x03	; 3
    63ee:	91 05       	cpc	r25, r1
    63f0:	81 f0       	breq	.+32     	; 0x6412 <GPIO_setupPortDirection+0x72>
    63f2:	13 c0       	rjmp	.+38     	; 0x641a <GPIO_setupPortDirection+0x7a>
		{
		case PORTA_ID:
			DDRA = direction;
    63f4:	e1 e2       	ldi	r30, 0x21	; 33
    63f6:	f0 e0       	ldi	r31, 0x00	; 0
    63f8:	8a 81       	ldd	r24, Y+2	; 0x02
    63fa:	80 83       	st	Z, r24
    63fc:	0e c0       	rjmp	.+28     	; 0x641a <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
    63fe:	e4 e2       	ldi	r30, 0x24	; 36
    6400:	f0 e0       	ldi	r31, 0x00	; 0
    6402:	8a 81       	ldd	r24, Y+2	; 0x02
    6404:	80 83       	st	Z, r24
    6406:	09 c0       	rjmp	.+18     	; 0x641a <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    6408:	e7 e2       	ldi	r30, 0x27	; 39
    640a:	f0 e0       	ldi	r31, 0x00	; 0
    640c:	8a 81       	ldd	r24, Y+2	; 0x02
    640e:	80 83       	st	Z, r24
    6410:	04 c0       	rjmp	.+8      	; 0x641a <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
    6412:	ea e2       	ldi	r30, 0x2A	; 42
    6414:	f0 e0       	ldi	r31, 0x00	; 0
    6416:	8a 81       	ldd	r24, Y+2	; 0x02
    6418:	80 83       	st	Z, r24
			break;
		}
	}
}
    641a:	0f 90       	pop	r0
    641c:	0f 90       	pop	r0
    641e:	0f 90       	pop	r0
    6420:	0f 90       	pop	r0
    6422:	cf 91       	pop	r28
    6424:	df 91       	pop	r29
    6426:	08 95       	ret

00006428 <GPIO_writePort>:
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value)
{
    6428:	df 93       	push	r29
    642a:	cf 93       	push	r28
    642c:	00 d0       	rcall	.+0      	; 0x642e <GPIO_writePort+0x6>
    642e:	00 d0       	rcall	.+0      	; 0x6430 <GPIO_writePort+0x8>
    6430:	cd b7       	in	r28, 0x3d	; 61
    6432:	de b7       	in	r29, 0x3e	; 62
    6434:	89 83       	std	Y+1, r24	; 0x01
    6436:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    6438:	89 81       	ldd	r24, Y+1	; 0x01
    643a:	84 30       	cpi	r24, 0x04	; 4
    643c:	90 f5       	brcc	.+100    	; 0x64a2 <GPIO_writePort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Write the port value as required */
		switch(port_num)
    643e:	89 81       	ldd	r24, Y+1	; 0x01
    6440:	28 2f       	mov	r18, r24
    6442:	30 e0       	ldi	r19, 0x00	; 0
    6444:	3c 83       	std	Y+4, r19	; 0x04
    6446:	2b 83       	std	Y+3, r18	; 0x03
    6448:	8b 81       	ldd	r24, Y+3	; 0x03
    644a:	9c 81       	ldd	r25, Y+4	; 0x04
    644c:	81 30       	cpi	r24, 0x01	; 1
    644e:	91 05       	cpc	r25, r1
    6450:	d1 f0       	breq	.+52     	; 0x6486 <GPIO_writePort+0x5e>
    6452:	2b 81       	ldd	r18, Y+3	; 0x03
    6454:	3c 81       	ldd	r19, Y+4	; 0x04
    6456:	22 30       	cpi	r18, 0x02	; 2
    6458:	31 05       	cpc	r19, r1
    645a:	2c f4       	brge	.+10     	; 0x6466 <GPIO_writePort+0x3e>
    645c:	8b 81       	ldd	r24, Y+3	; 0x03
    645e:	9c 81       	ldd	r25, Y+4	; 0x04
    6460:	00 97       	sbiw	r24, 0x00	; 0
    6462:	61 f0       	breq	.+24     	; 0x647c <GPIO_writePort+0x54>
    6464:	1e c0       	rjmp	.+60     	; 0x64a2 <GPIO_writePort+0x7a>
    6466:	2b 81       	ldd	r18, Y+3	; 0x03
    6468:	3c 81       	ldd	r19, Y+4	; 0x04
    646a:	22 30       	cpi	r18, 0x02	; 2
    646c:	31 05       	cpc	r19, r1
    646e:	81 f0       	breq	.+32     	; 0x6490 <GPIO_writePort+0x68>
    6470:	8b 81       	ldd	r24, Y+3	; 0x03
    6472:	9c 81       	ldd	r25, Y+4	; 0x04
    6474:	83 30       	cpi	r24, 0x03	; 3
    6476:	91 05       	cpc	r25, r1
    6478:	81 f0       	breq	.+32     	; 0x649a <GPIO_writePort+0x72>
    647a:	13 c0       	rjmp	.+38     	; 0x64a2 <GPIO_writePort+0x7a>
		{
		case PORTA_ID:
			PORTA = value;
    647c:	e2 e2       	ldi	r30, 0x22	; 34
    647e:	f0 e0       	ldi	r31, 0x00	; 0
    6480:	8a 81       	ldd	r24, Y+2	; 0x02
    6482:	80 83       	st	Z, r24
    6484:	0e c0       	rjmp	.+28     	; 0x64a2 <GPIO_writePort+0x7a>
			break;
		case PORTB_ID:
			PORTB = value;
    6486:	e5 e2       	ldi	r30, 0x25	; 37
    6488:	f0 e0       	ldi	r31, 0x00	; 0
    648a:	8a 81       	ldd	r24, Y+2	; 0x02
    648c:	80 83       	st	Z, r24
    648e:	09 c0       	rjmp	.+18     	; 0x64a2 <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
    6490:	e8 e2       	ldi	r30, 0x28	; 40
    6492:	f0 e0       	ldi	r31, 0x00	; 0
    6494:	8a 81       	ldd	r24, Y+2	; 0x02
    6496:	80 83       	st	Z, r24
    6498:	04 c0       	rjmp	.+8      	; 0x64a2 <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
    649a:	eb e2       	ldi	r30, 0x2B	; 43
    649c:	f0 e0       	ldi	r31, 0x00	; 0
    649e:	8a 81       	ldd	r24, Y+2	; 0x02
    64a0:	80 83       	st	Z, r24
			break;
		}
	}
}
    64a2:	0f 90       	pop	r0
    64a4:	0f 90       	pop	r0
    64a6:	0f 90       	pop	r0
    64a8:	0f 90       	pop	r0
    64aa:	cf 91       	pop	r28
    64ac:	df 91       	pop	r29
    64ae:	08 95       	ret

000064b0 <GPIO_readPort>:
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num)
{
    64b0:	df 93       	push	r29
    64b2:	cf 93       	push	r28
    64b4:	00 d0       	rcall	.+0      	; 0x64b6 <GPIO_readPort+0x6>
    64b6:	00 d0       	rcall	.+0      	; 0x64b8 <GPIO_readPort+0x8>
    64b8:	cd b7       	in	r28, 0x3d	; 61
    64ba:	de b7       	in	r29, 0x3e	; 62
    64bc:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    64be:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    64c0:	8a 81       	ldd	r24, Y+2	; 0x02
    64c2:	84 30       	cpi	r24, 0x04	; 4
    64c4:	90 f5       	brcc	.+100    	; 0x652a <GPIO_readPort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Read the port value as required */
		switch(port_num)
    64c6:	8a 81       	ldd	r24, Y+2	; 0x02
    64c8:	28 2f       	mov	r18, r24
    64ca:	30 e0       	ldi	r19, 0x00	; 0
    64cc:	3c 83       	std	Y+4, r19	; 0x04
    64ce:	2b 83       	std	Y+3, r18	; 0x03
    64d0:	8b 81       	ldd	r24, Y+3	; 0x03
    64d2:	9c 81       	ldd	r25, Y+4	; 0x04
    64d4:	81 30       	cpi	r24, 0x01	; 1
    64d6:	91 05       	cpc	r25, r1
    64d8:	d1 f0       	breq	.+52     	; 0x650e <GPIO_readPort+0x5e>
    64da:	2b 81       	ldd	r18, Y+3	; 0x03
    64dc:	3c 81       	ldd	r19, Y+4	; 0x04
    64de:	22 30       	cpi	r18, 0x02	; 2
    64e0:	31 05       	cpc	r19, r1
    64e2:	2c f4       	brge	.+10     	; 0x64ee <GPIO_readPort+0x3e>
    64e4:	8b 81       	ldd	r24, Y+3	; 0x03
    64e6:	9c 81       	ldd	r25, Y+4	; 0x04
    64e8:	00 97       	sbiw	r24, 0x00	; 0
    64ea:	61 f0       	breq	.+24     	; 0x6504 <GPIO_readPort+0x54>
    64ec:	1e c0       	rjmp	.+60     	; 0x652a <GPIO_readPort+0x7a>
    64ee:	2b 81       	ldd	r18, Y+3	; 0x03
    64f0:	3c 81       	ldd	r19, Y+4	; 0x04
    64f2:	22 30       	cpi	r18, 0x02	; 2
    64f4:	31 05       	cpc	r19, r1
    64f6:	81 f0       	breq	.+32     	; 0x6518 <GPIO_readPort+0x68>
    64f8:	8b 81       	ldd	r24, Y+3	; 0x03
    64fa:	9c 81       	ldd	r25, Y+4	; 0x04
    64fc:	83 30       	cpi	r24, 0x03	; 3
    64fe:	91 05       	cpc	r25, r1
    6500:	81 f0       	breq	.+32     	; 0x6522 <GPIO_readPort+0x72>
    6502:	13 c0       	rjmp	.+38     	; 0x652a <GPIO_readPort+0x7a>
		{
		case PORTA_ID:
			value = PINA;
    6504:	e0 e2       	ldi	r30, 0x20	; 32
    6506:	f0 e0       	ldi	r31, 0x00	; 0
    6508:	80 81       	ld	r24, Z
    650a:	89 83       	std	Y+1, r24	; 0x01
    650c:	0e c0       	rjmp	.+28     	; 0x652a <GPIO_readPort+0x7a>
			break;
		case PORTB_ID:
			value = PINB;
    650e:	e3 e2       	ldi	r30, 0x23	; 35
    6510:	f0 e0       	ldi	r31, 0x00	; 0
    6512:	80 81       	ld	r24, Z
    6514:	89 83       	std	Y+1, r24	; 0x01
    6516:	09 c0       	rjmp	.+18     	; 0x652a <GPIO_readPort+0x7a>
			break;
		case PORTC_ID:
			value = PINC;
    6518:	e6 e2       	ldi	r30, 0x26	; 38
    651a:	f0 e0       	ldi	r31, 0x00	; 0
    651c:	80 81       	ld	r24, Z
    651e:	89 83       	std	Y+1, r24	; 0x01
    6520:	04 c0       	rjmp	.+8      	; 0x652a <GPIO_readPort+0x7a>
			break;
		case PORTD_ID:
			value = PIND;
    6522:	e9 e2       	ldi	r30, 0x29	; 41
    6524:	f0 e0       	ldi	r31, 0x00	; 0
    6526:	80 81       	ld	r24, Z
    6528:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}

	return value;
    652a:	89 81       	ldd	r24, Y+1	; 0x01
}
    652c:	0f 90       	pop	r0
    652e:	0f 90       	pop	r0
    6530:	0f 90       	pop	r0
    6532:	0f 90       	pop	r0
    6534:	cf 91       	pop	r28
    6536:	df 91       	pop	r29
    6538:	08 95       	ret

0000653a <__vector_16>:
/*******************************************************************************
 *                       Interrupt Service Routines                            *
 *******************************************************************************/

ISR(TIMER1_CAPT_vect)
{
    653a:	1f 92       	push	r1
    653c:	0f 92       	push	r0
    653e:	0f b6       	in	r0, 0x3f	; 63
    6540:	0f 92       	push	r0
    6542:	11 24       	eor	r1, r1
    6544:	2f 93       	push	r18
    6546:	3f 93       	push	r19
    6548:	4f 93       	push	r20
    654a:	5f 93       	push	r21
    654c:	6f 93       	push	r22
    654e:	7f 93       	push	r23
    6550:	8f 93       	push	r24
    6552:	9f 93       	push	r25
    6554:	af 93       	push	r26
    6556:	bf 93       	push	r27
    6558:	ef 93       	push	r30
    655a:	ff 93       	push	r31
    655c:	df 93       	push	r29
    655e:	cf 93       	push	r28
    6560:	cd b7       	in	r28, 0x3d	; 61
    6562:	de b7       	in	r29, 0x3e	; 62
	if(g_callBackPtr != NULL_PTR)
    6564:	80 91 a5 15 	lds	r24, 0x15A5
    6568:	90 91 a6 15 	lds	r25, 0x15A6
    656c:	00 97       	sbiw	r24, 0x00	; 0
    656e:	29 f0       	breq	.+10     	; 0x657a <__vector_16+0x40>
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
    6570:	e0 91 a5 15 	lds	r30, 0x15A5
    6574:	f0 91 a6 15 	lds	r31, 0x15A6
    6578:	09 95       	icall
	}
}
    657a:	cf 91       	pop	r28
    657c:	df 91       	pop	r29
    657e:	ff 91       	pop	r31
    6580:	ef 91       	pop	r30
    6582:	bf 91       	pop	r27
    6584:	af 91       	pop	r26
    6586:	9f 91       	pop	r25
    6588:	8f 91       	pop	r24
    658a:	7f 91       	pop	r23
    658c:	6f 91       	pop	r22
    658e:	5f 91       	pop	r21
    6590:	4f 91       	pop	r20
    6592:	3f 91       	pop	r19
    6594:	2f 91       	pop	r18
    6596:	0f 90       	pop	r0
    6598:	0f be       	out	0x3f, r0	; 63
    659a:	0f 90       	pop	r0
    659c:	1f 90       	pop	r1
    659e:	18 95       	reti

000065a0 <Icu_init>:
 * 	2. Set the required edge detection.
 * 	3. Enable the Input Capture Interrupt.
 * 	4. Initialize Timer1 Registers
 */
void Icu_init(const Icu_ConfigType * Config_Ptr)
{
    65a0:	df 93       	push	r29
    65a2:	cf 93       	push	r28
    65a4:	00 d0       	rcall	.+0      	; 0x65a6 <Icu_init+0x6>
    65a6:	cd b7       	in	r28, 0x3d	; 61
    65a8:	de b7       	in	r29, 0x3e	; 62
    65aa:	9a 83       	std	Y+2, r25	; 0x02
    65ac:	89 83       	std	Y+1, r24	; 0x01
	/* Configure ICP1/PD6 as i/p pin */
	DDRD &= ~(1<<PD4);
    65ae:	aa e2       	ldi	r26, 0x2A	; 42
    65b0:	b0 e0       	ldi	r27, 0x00	; 0
    65b2:	ea e2       	ldi	r30, 0x2A	; 42
    65b4:	f0 e0       	ldi	r31, 0x00	; 0
    65b6:	80 81       	ld	r24, Z
    65b8:	8f 7e       	andi	r24, 0xEF	; 239
    65ba:	8c 93       	st	X, r24

	/* Timer1 always operates in Normal Mode */
	TCCR1C = (1<<FOC1A) | (1<<FOC1B)|(1<<FOC1C);
    65bc:	e2 e8       	ldi	r30, 0x82	; 130
    65be:	f0 e0       	ldi	r31, 0x00	; 0
    65c0:	80 ee       	ldi	r24, 0xE0	; 224
    65c2:	80 83       	st	Z, r24

	/*
	 * insert the required clock value in the first three bits (CS10, CS11 and CS12)
	 * of TCCR1B Register
	 */
	TCCR1B = (TCCR1B & 0xF8) | (Config_Ptr->clock);
    65c4:	a1 e8       	ldi	r26, 0x81	; 129
    65c6:	b0 e0       	ldi	r27, 0x00	; 0
    65c8:	e1 e8       	ldi	r30, 0x81	; 129
    65ca:	f0 e0       	ldi	r31, 0x00	; 0
    65cc:	80 81       	ld	r24, Z
    65ce:	98 2f       	mov	r25, r24
    65d0:	98 7f       	andi	r25, 0xF8	; 248
    65d2:	e9 81       	ldd	r30, Y+1	; 0x01
    65d4:	fa 81       	ldd	r31, Y+2	; 0x02
    65d6:	80 81       	ld	r24, Z
    65d8:	89 2b       	or	r24, r25
    65da:	8c 93       	st	X, r24
	/*
     * insert the required edge type in ICES1 bit in TCCR1B Register
	 */
	TCCR1B = (TCCR1B & 0xBF) | ((Config_Ptr->edge)<<6);
    65dc:	a1 e8       	ldi	r26, 0x81	; 129
    65de:	b0 e0       	ldi	r27, 0x00	; 0
    65e0:	e1 e8       	ldi	r30, 0x81	; 129
    65e2:	f0 e0       	ldi	r31, 0x00	; 0
    65e4:	80 81       	ld	r24, Z
    65e6:	28 2f       	mov	r18, r24
    65e8:	2f 7b       	andi	r18, 0xBF	; 191
    65ea:	e9 81       	ldd	r30, Y+1	; 0x01
    65ec:	fa 81       	ldd	r31, Y+2	; 0x02
    65ee:	81 81       	ldd	r24, Z+1	; 0x01
    65f0:	88 2f       	mov	r24, r24
    65f2:	90 e0       	ldi	r25, 0x00	; 0
    65f4:	00 24       	eor	r0, r0
    65f6:	96 95       	lsr	r25
    65f8:	87 95       	ror	r24
    65fa:	07 94       	ror	r0
    65fc:	96 95       	lsr	r25
    65fe:	87 95       	ror	r24
    6600:	07 94       	ror	r0
    6602:	98 2f       	mov	r25, r24
    6604:	80 2d       	mov	r24, r0
    6606:	82 2b       	or	r24, r18
    6608:	8c 93       	st	X, r24

	/* Initial Value for Timer1 */
	TCNT1 = 0;
    660a:	e4 e8       	ldi	r30, 0x84	; 132
    660c:	f0 e0       	ldi	r31, 0x00	; 0
    660e:	11 82       	std	Z+1, r1	; 0x01
    6610:	10 82       	st	Z, r1

	/* Initial Value for the input capture register */
	ICR1 = 0;
    6612:	e6 e8       	ldi	r30, 0x86	; 134
    6614:	f0 e0       	ldi	r31, 0x00	; 0
    6616:	11 82       	std	Z+1, r1	; 0x01
    6618:	10 82       	st	Z, r1

	/* Enable the Input Capture interrupt to generate an interrupt when edge is detected on ICP1/PD6 pin */
	TIMSK1 |= (1<<ICIE1);
    661a:	af e6       	ldi	r26, 0x6F	; 111
    661c:	b0 e0       	ldi	r27, 0x00	; 0
    661e:	ef e6       	ldi	r30, 0x6F	; 111
    6620:	f0 e0       	ldi	r31, 0x00	; 0
    6622:	80 81       	ld	r24, Z
    6624:	80 62       	ori	r24, 0x20	; 32
    6626:	8c 93       	st	X, r24
}
    6628:	0f 90       	pop	r0
    662a:	0f 90       	pop	r0
    662c:	cf 91       	pop	r28
    662e:	df 91       	pop	r29
    6630:	08 95       	ret

00006632 <Icu_setCallBack>:

/*
 * Description: Function to set the Call Back function address.
 */
void Icu_setCallBack(void(*a_ptr)(void))
{
    6632:	df 93       	push	r29
    6634:	cf 93       	push	r28
    6636:	00 d0       	rcall	.+0      	; 0x6638 <Icu_setCallBack+0x6>
    6638:	cd b7       	in	r28, 0x3d	; 61
    663a:	de b7       	in	r29, 0x3e	; 62
    663c:	9a 83       	std	Y+2, r25	; 0x02
    663e:	89 83       	std	Y+1, r24	; 0x01
	/* Save the address of the Call back function in a global variable */
	g_callBackPtr = a_ptr;
    6640:	89 81       	ldd	r24, Y+1	; 0x01
    6642:	9a 81       	ldd	r25, Y+2	; 0x02
    6644:	90 93 a6 15 	sts	0x15A6, r25
    6648:	80 93 a5 15 	sts	0x15A5, r24
}
    664c:	0f 90       	pop	r0
    664e:	0f 90       	pop	r0
    6650:	cf 91       	pop	r28
    6652:	df 91       	pop	r29
    6654:	08 95       	ret

00006656 <Icu_setEdgeDetectionType>:

/*
 * Description: Function to set the required edge detection.
 */
void Icu_setEdgeDetectionType(const Icu_EdgeType a_edgeType)
{
    6656:	df 93       	push	r29
    6658:	cf 93       	push	r28
    665a:	0f 92       	push	r0
    665c:	cd b7       	in	r28, 0x3d	; 61
    665e:	de b7       	in	r29, 0x3e	; 62
    6660:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * insert the required edge type in ICES1 bit in TCCR1B Register
	 */
	TCCR1B = (TCCR1B & 0xBF) | (a_edgeType<<6);
    6662:	a1 e8       	ldi	r26, 0x81	; 129
    6664:	b0 e0       	ldi	r27, 0x00	; 0
    6666:	e1 e8       	ldi	r30, 0x81	; 129
    6668:	f0 e0       	ldi	r31, 0x00	; 0
    666a:	80 81       	ld	r24, Z
    666c:	28 2f       	mov	r18, r24
    666e:	2f 7b       	andi	r18, 0xBF	; 191
    6670:	89 81       	ldd	r24, Y+1	; 0x01
    6672:	88 2f       	mov	r24, r24
    6674:	90 e0       	ldi	r25, 0x00	; 0
    6676:	00 24       	eor	r0, r0
    6678:	96 95       	lsr	r25
    667a:	87 95       	ror	r24
    667c:	07 94       	ror	r0
    667e:	96 95       	lsr	r25
    6680:	87 95       	ror	r24
    6682:	07 94       	ror	r0
    6684:	98 2f       	mov	r25, r24
    6686:	80 2d       	mov	r24, r0
    6688:	82 2b       	or	r24, r18
    668a:	8c 93       	st	X, r24
}
    668c:	0f 90       	pop	r0
    668e:	cf 91       	pop	r28
    6690:	df 91       	pop	r29
    6692:	08 95       	ret

00006694 <Icu_getInputCaptureValue>:
/*
 * Description: Function to get the Timer1 Value when the input is captured
 *              The value stored at Input Capture Register ICR1
 */
uint16 Icu_getInputCaptureValue(void)
{
    6694:	df 93       	push	r29
    6696:	cf 93       	push	r28
    6698:	cd b7       	in	r28, 0x3d	; 61
    669a:	de b7       	in	r29, 0x3e	; 62
	return ICR1;
    669c:	e6 e8       	ldi	r30, 0x86	; 134
    669e:	f0 e0       	ldi	r31, 0x00	; 0
    66a0:	80 81       	ld	r24, Z
    66a2:	91 81       	ldd	r25, Z+1	; 0x01
}
    66a4:	cf 91       	pop	r28
    66a6:	df 91       	pop	r29
    66a8:	08 95       	ret

000066aa <Icu_clearTimerValue>:

/*
 * Description: Function to clear the Timer1 Value to start count from ZERO
 */
void Icu_clearTimerValue(void)
{
    66aa:	df 93       	push	r29
    66ac:	cf 93       	push	r28
    66ae:	cd b7       	in	r28, 0x3d	; 61
    66b0:	de b7       	in	r29, 0x3e	; 62
	TCNT1 = 0;
    66b2:	e4 e8       	ldi	r30, 0x84	; 132
    66b4:	f0 e0       	ldi	r31, 0x00	; 0
    66b6:	11 82       	std	Z+1, r1	; 0x01
    66b8:	10 82       	st	Z, r1
}
    66ba:	cf 91       	pop	r28
    66bc:	df 91       	pop	r29
    66be:	08 95       	ret

000066c0 <Icu_DeInit>:

/*
 * Description: Function to disable the Timer1 to stop the ICU Driver
 */
void Icu_DeInit(void)
{
    66c0:	df 93       	push	r29
    66c2:	cf 93       	push	r28
    66c4:	cd b7       	in	r28, 0x3d	; 61
    66c6:	de b7       	in	r29, 0x3e	; 62
	/* Clear All Timer1 Registers */
	TCCR1A = 0;
    66c8:	e0 e8       	ldi	r30, 0x80	; 128
    66ca:	f0 e0       	ldi	r31, 0x00	; 0
    66cc:	10 82       	st	Z, r1
	TCCR1B = 0;
    66ce:	e1 e8       	ldi	r30, 0x81	; 129
    66d0:	f0 e0       	ldi	r31, 0x00	; 0
    66d2:	10 82       	st	Z, r1
	TCNT1 = 0;
    66d4:	e4 e8       	ldi	r30, 0x84	; 132
    66d6:	f0 e0       	ldi	r31, 0x00	; 0
    66d8:	11 82       	std	Z+1, r1	; 0x01
    66da:	10 82       	st	Z, r1
	ICR1 = 0;
    66dc:	e6 e8       	ldi	r30, 0x86	; 134
    66de:	f0 e0       	ldi	r31, 0x00	; 0
    66e0:	11 82       	std	Z+1, r1	; 0x01
    66e2:	10 82       	st	Z, r1

	/* Disable the Input Capture interrupt */
	TIMSK1 &= ~(1<<ICIE1);
    66e4:	af e6       	ldi	r26, 0x6F	; 111
    66e6:	b0 e0       	ldi	r27, 0x00	; 0
    66e8:	ef e6       	ldi	r30, 0x6F	; 111
    66ea:	f0 e0       	ldi	r31, 0x00	; 0
    66ec:	80 81       	ld	r24, Z
    66ee:	8f 7d       	andi	r24, 0xDF	; 223
    66f0:	8c 93       	st	X, r24

}
    66f2:	cf 91       	pop	r28
    66f4:	df 91       	pop	r29
    66f6:	08 95       	ret

000066f8 <GLCD_sendcommand>:
};




void GLCD_sendcommand(uint8 command){
    66f8:	df 93       	push	r29
    66fa:	cf 93       	push	r28
    66fc:	cd b7       	in	r28, 0x3d	; 61
    66fe:	de b7       	in	r29, 0x3e	; 62
    6700:	e1 97       	sbiw	r28, 0x31	; 49
    6702:	0f b6       	in	r0, 0x3f	; 63
    6704:	f8 94       	cli
    6706:	de bf       	out	0x3e, r29	; 62
    6708:	0f be       	out	0x3f, r0	; 63
    670a:	cd bf       	out	0x3d, r28	; 61
    670c:	89 ab       	std	Y+49, r24	; 0x31

GPIO_writePort(GLCD_DATA_PORT_ID, command);
    670e:	80 e0       	ldi	r24, 0x00	; 0
    6710:	69 a9       	ldd	r22, Y+49	; 0x31
    6712:	0e 94 14 32 	call	0x6428	; 0x6428 <GPIO_writePort>


    GPIO_writePin(GLCD_RS_PORT_ID,GLCD_RS_PIN_ID , LOGIC_LOW);
    6716:	81 e0       	ldi	r24, 0x01	; 1
    6718:	66 e0       	ldi	r22, 0x06	; 6
    671a:	40 e0       	ldi	r20, 0x00	; 0
    671c:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
	GPIO_writePin(GLCD_RW_PORT_ID,GLCD_RW_PIN_ID , LOGIC_LOW);
    6720:	81 e0       	ldi	r24, 0x01	; 1
    6722:	67 e0       	ldi	r22, 0x07	; 7
    6724:	40 e0       	ldi	r20, 0x00	; 0
    6726:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
	GPIO_writePin(GLCD_E_PORT_ID,GLCD_E_PIN_ID , LOGIC_HIGH);
    672a:	81 e0       	ldi	r24, 0x01	; 1
    672c:	60 e0       	ldi	r22, 0x00	; 0
    672e:	41 e0       	ldi	r20, 0x01	; 1
    6730:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
    6734:	80 e0       	ldi	r24, 0x00	; 0
    6736:	90 e0       	ldi	r25, 0x00	; 0
    6738:	a0 ea       	ldi	r26, 0xA0	; 160
    673a:	b0 e4       	ldi	r27, 0x40	; 64
    673c:	8d a7       	std	Y+45, r24	; 0x2d
    673e:	9e a7       	std	Y+46, r25	; 0x2e
    6740:	af a7       	std	Y+47, r26	; 0x2f
    6742:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    6744:	6d a5       	ldd	r22, Y+45	; 0x2d
    6746:	7e a5       	ldd	r23, Y+46	; 0x2e
    6748:	8f a5       	ldd	r24, Y+47	; 0x2f
    674a:	98 a9       	ldd	r25, Y+48	; 0x30
    674c:	2b ea       	ldi	r18, 0xAB	; 171
    674e:	3a ea       	ldi	r19, 0xAA	; 170
    6750:	4a ea       	ldi	r20, 0xAA	; 170
    6752:	5e e3       	ldi	r21, 0x3E	; 62
    6754:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    6758:	dc 01       	movw	r26, r24
    675a:	cb 01       	movw	r24, r22
    675c:	89 a7       	std	Y+41, r24	; 0x29
    675e:	9a a7       	std	Y+42, r25	; 0x2a
    6760:	ab a7       	std	Y+43, r26	; 0x2b
    6762:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    6764:	69 a5       	ldd	r22, Y+41	; 0x29
    6766:	7a a5       	ldd	r23, Y+42	; 0x2a
    6768:	8b a5       	ldd	r24, Y+43	; 0x2b
    676a:	9c a5       	ldd	r25, Y+44	; 0x2c
    676c:	20 e0       	ldi	r18, 0x00	; 0
    676e:	30 e0       	ldi	r19, 0x00	; 0
    6770:	40 e8       	ldi	r20, 0x80	; 128
    6772:	5f e3       	ldi	r21, 0x3F	; 63
    6774:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__ltsf2>
    6778:	88 23       	and	r24, r24
    677a:	1c f4       	brge	.+6      	; 0x6782 <GLCD_sendcommand+0x8a>
		__ticks = 1;
    677c:	81 e0       	ldi	r24, 0x01	; 1
    677e:	88 a7       	std	Y+40, r24	; 0x28
    6780:	91 c0       	rjmp	.+290    	; 0x68a4 <GLCD_sendcommand+0x1ac>
	else if (__tmp > 255)
    6782:	69 a5       	ldd	r22, Y+41	; 0x29
    6784:	7a a5       	ldd	r23, Y+42	; 0x2a
    6786:	8b a5       	ldd	r24, Y+43	; 0x2b
    6788:	9c a5       	ldd	r25, Y+44	; 0x2c
    678a:	20 e0       	ldi	r18, 0x00	; 0
    678c:	30 e0       	ldi	r19, 0x00	; 0
    678e:	4f e7       	ldi	r20, 0x7F	; 127
    6790:	53 e4       	ldi	r21, 0x43	; 67
    6792:	0e 94 8c 04 	call	0x918	; 0x918 <__gtsf2>
    6796:	18 16       	cp	r1, r24
    6798:	0c f0       	brlt	.+2      	; 0x679c <GLCD_sendcommand+0xa4>
    679a:	7b c0       	rjmp	.+246    	; 0x6892 <GLCD_sendcommand+0x19a>
	{
		_delay_ms(__us / 1000.0);
    679c:	6d a5       	ldd	r22, Y+45	; 0x2d
    679e:	7e a5       	ldd	r23, Y+46	; 0x2e
    67a0:	8f a5       	ldd	r24, Y+47	; 0x2f
    67a2:	98 a9       	ldd	r25, Y+48	; 0x30
    67a4:	20 e0       	ldi	r18, 0x00	; 0
    67a6:	30 e0       	ldi	r19, 0x00	; 0
    67a8:	4a e7       	ldi	r20, 0x7A	; 122
    67aa:	54 e4       	ldi	r21, 0x44	; 68
    67ac:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <__divsf3>
    67b0:	dc 01       	movw	r26, r24
    67b2:	cb 01       	movw	r24, r22
    67b4:	8c a3       	std	Y+36, r24	; 0x24
    67b6:	9d a3       	std	Y+37, r25	; 0x25
    67b8:	ae a3       	std	Y+38, r26	; 0x26
    67ba:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    67bc:	6c a1       	ldd	r22, Y+36	; 0x24
    67be:	7d a1       	ldd	r23, Y+37	; 0x25
    67c0:	8e a1       	ldd	r24, Y+38	; 0x26
    67c2:	9f a1       	ldd	r25, Y+39	; 0x27
    67c4:	20 e0       	ldi	r18, 0x00	; 0
    67c6:	30 e0       	ldi	r19, 0x00	; 0
    67c8:	4a e7       	ldi	r20, 0x7A	; 122
    67ca:	53 e4       	ldi	r21, 0x43	; 67
    67cc:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    67d0:	dc 01       	movw	r26, r24
    67d2:	cb 01       	movw	r24, r22
    67d4:	88 a3       	std	Y+32, r24	; 0x20
    67d6:	99 a3       	std	Y+33, r25	; 0x21
    67d8:	aa a3       	std	Y+34, r26	; 0x22
    67da:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    67dc:	68 a1       	ldd	r22, Y+32	; 0x20
    67de:	79 a1       	ldd	r23, Y+33	; 0x21
    67e0:	8a a1       	ldd	r24, Y+34	; 0x22
    67e2:	9b a1       	ldd	r25, Y+35	; 0x23
    67e4:	20 e0       	ldi	r18, 0x00	; 0
    67e6:	30 e0       	ldi	r19, 0x00	; 0
    67e8:	40 e8       	ldi	r20, 0x80	; 128
    67ea:	5f e3       	ldi	r21, 0x3F	; 63
    67ec:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__ltsf2>
    67f0:	88 23       	and	r24, r24
    67f2:	2c f4       	brge	.+10     	; 0x67fe <GLCD_sendcommand+0x106>
		__ticks = 1;
    67f4:	81 e0       	ldi	r24, 0x01	; 1
    67f6:	90 e0       	ldi	r25, 0x00	; 0
    67f8:	9f 8f       	std	Y+31, r25	; 0x1f
    67fa:	8e 8f       	std	Y+30, r24	; 0x1e
    67fc:	3f c0       	rjmp	.+126    	; 0x687c <GLCD_sendcommand+0x184>
	else if (__tmp > 65535)
    67fe:	68 a1       	ldd	r22, Y+32	; 0x20
    6800:	79 a1       	ldd	r23, Y+33	; 0x21
    6802:	8a a1       	ldd	r24, Y+34	; 0x22
    6804:	9b a1       	ldd	r25, Y+35	; 0x23
    6806:	20 e0       	ldi	r18, 0x00	; 0
    6808:	3f ef       	ldi	r19, 0xFF	; 255
    680a:	4f e7       	ldi	r20, 0x7F	; 127
    680c:	57 e4       	ldi	r21, 0x47	; 71
    680e:	0e 94 8c 04 	call	0x918	; 0x918 <__gtsf2>
    6812:	18 16       	cp	r1, r24
    6814:	4c f5       	brge	.+82     	; 0x6868 <GLCD_sendcommand+0x170>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6816:	6c a1       	ldd	r22, Y+36	; 0x24
    6818:	7d a1       	ldd	r23, Y+37	; 0x25
    681a:	8e a1       	ldd	r24, Y+38	; 0x26
    681c:	9f a1       	ldd	r25, Y+39	; 0x27
    681e:	20 e0       	ldi	r18, 0x00	; 0
    6820:	30 e0       	ldi	r19, 0x00	; 0
    6822:	40 e2       	ldi	r20, 0x20	; 32
    6824:	51 e4       	ldi	r21, 0x41	; 65
    6826:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    682a:	dc 01       	movw	r26, r24
    682c:	cb 01       	movw	r24, r22
    682e:	bc 01       	movw	r22, r24
    6830:	cd 01       	movw	r24, r26
    6832:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    6836:	dc 01       	movw	r26, r24
    6838:	cb 01       	movw	r24, r22
    683a:	9f 8f       	std	Y+31, r25	; 0x1f
    683c:	8e 8f       	std	Y+30, r24	; 0x1e
    683e:	0f c0       	rjmp	.+30     	; 0x685e <GLCD_sendcommand+0x166>
    6840:	89 e1       	ldi	r24, 0x19	; 25
    6842:	90 e0       	ldi	r25, 0x00	; 0
    6844:	9d 8f       	std	Y+29, r25	; 0x1d
    6846:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6848:	8c 8d       	ldd	r24, Y+28	; 0x1c
    684a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    684c:	01 97       	sbiw	r24, 0x01	; 1
    684e:	f1 f7       	brne	.-4      	; 0x684c <GLCD_sendcommand+0x154>
    6850:	9d 8f       	std	Y+29, r25	; 0x1d
    6852:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6854:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6856:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6858:	01 97       	sbiw	r24, 0x01	; 1
    685a:	9f 8f       	std	Y+31, r25	; 0x1f
    685c:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    685e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6860:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6862:	00 97       	sbiw	r24, 0x00	; 0
    6864:	69 f7       	brne	.-38     	; 0x6840 <GLCD_sendcommand+0x148>
    6866:	24 c0       	rjmp	.+72     	; 0x68b0 <GLCD_sendcommand+0x1b8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6868:	68 a1       	ldd	r22, Y+32	; 0x20
    686a:	79 a1       	ldd	r23, Y+33	; 0x21
    686c:	8a a1       	ldd	r24, Y+34	; 0x22
    686e:	9b a1       	ldd	r25, Y+35	; 0x23
    6870:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    6874:	dc 01       	movw	r26, r24
    6876:	cb 01       	movw	r24, r22
    6878:	9f 8f       	std	Y+31, r25	; 0x1f
    687a:	8e 8f       	std	Y+30, r24	; 0x1e
    687c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    687e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6880:	9b 8f       	std	Y+27, r25	; 0x1b
    6882:	8a 8f       	std	Y+26, r24	; 0x1a
    6884:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6886:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6888:	01 97       	sbiw	r24, 0x01	; 1
    688a:	f1 f7       	brne	.-4      	; 0x6888 <GLCD_sendcommand+0x190>
    688c:	9b 8f       	std	Y+27, r25	; 0x1b
    688e:	8a 8f       	std	Y+26, r24	; 0x1a
    6890:	0f c0       	rjmp	.+30     	; 0x68b0 <GLCD_sendcommand+0x1b8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6892:	69 a5       	ldd	r22, Y+41	; 0x29
    6894:	7a a5       	ldd	r23, Y+42	; 0x2a
    6896:	8b a5       	ldd	r24, Y+43	; 0x2b
    6898:	9c a5       	ldd	r25, Y+44	; 0x2c
    689a:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    689e:	dc 01       	movw	r26, r24
    68a0:	cb 01       	movw	r24, r22
    68a2:	88 a7       	std	Y+40, r24	; 0x28
    68a4:	88 a5       	ldd	r24, Y+40	; 0x28
    68a6:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    68a8:	89 8d       	ldd	r24, Y+25	; 0x19
    68aa:	8a 95       	dec	r24
    68ac:	f1 f7       	brne	.-4      	; 0x68aa <GLCD_sendcommand+0x1b2>
    68ae:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(5);
	GPIO_writePin(GLCD_E_PORT_ID,GLCD_E_PIN_ID , LOGIC_LOW);
    68b0:	81 e0       	ldi	r24, 0x01	; 1
    68b2:	60 e0       	ldi	r22, 0x00	; 0
    68b4:	40 e0       	ldi	r20, 0x00	; 0
    68b6:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
    68ba:	80 e0       	ldi	r24, 0x00	; 0
    68bc:	90 e0       	ldi	r25, 0x00	; 0
    68be:	a0 ea       	ldi	r26, 0xA0	; 160
    68c0:	b0 e4       	ldi	r27, 0x40	; 64
    68c2:	8d 8b       	std	Y+21, r24	; 0x15
    68c4:	9e 8b       	std	Y+22, r25	; 0x16
    68c6:	af 8b       	std	Y+23, r26	; 0x17
    68c8:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    68ca:	6d 89       	ldd	r22, Y+21	; 0x15
    68cc:	7e 89       	ldd	r23, Y+22	; 0x16
    68ce:	8f 89       	ldd	r24, Y+23	; 0x17
    68d0:	98 8d       	ldd	r25, Y+24	; 0x18
    68d2:	2b ea       	ldi	r18, 0xAB	; 171
    68d4:	3a ea       	ldi	r19, 0xAA	; 170
    68d6:	4a ea       	ldi	r20, 0xAA	; 170
    68d8:	5e e3       	ldi	r21, 0x3E	; 62
    68da:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    68de:	dc 01       	movw	r26, r24
    68e0:	cb 01       	movw	r24, r22
    68e2:	89 8b       	std	Y+17, r24	; 0x11
    68e4:	9a 8b       	std	Y+18, r25	; 0x12
    68e6:	ab 8b       	std	Y+19, r26	; 0x13
    68e8:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    68ea:	69 89       	ldd	r22, Y+17	; 0x11
    68ec:	7a 89       	ldd	r23, Y+18	; 0x12
    68ee:	8b 89       	ldd	r24, Y+19	; 0x13
    68f0:	9c 89       	ldd	r25, Y+20	; 0x14
    68f2:	20 e0       	ldi	r18, 0x00	; 0
    68f4:	30 e0       	ldi	r19, 0x00	; 0
    68f6:	40 e8       	ldi	r20, 0x80	; 128
    68f8:	5f e3       	ldi	r21, 0x3F	; 63
    68fa:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__ltsf2>
    68fe:	88 23       	and	r24, r24
    6900:	1c f4       	brge	.+6      	; 0x6908 <GLCD_sendcommand+0x210>
		__ticks = 1;
    6902:	81 e0       	ldi	r24, 0x01	; 1
    6904:	88 8b       	std	Y+16, r24	; 0x10
    6906:	91 c0       	rjmp	.+290    	; 0x6a2a <GLCD_sendcommand+0x332>
	else if (__tmp > 255)
    6908:	69 89       	ldd	r22, Y+17	; 0x11
    690a:	7a 89       	ldd	r23, Y+18	; 0x12
    690c:	8b 89       	ldd	r24, Y+19	; 0x13
    690e:	9c 89       	ldd	r25, Y+20	; 0x14
    6910:	20 e0       	ldi	r18, 0x00	; 0
    6912:	30 e0       	ldi	r19, 0x00	; 0
    6914:	4f e7       	ldi	r20, 0x7F	; 127
    6916:	53 e4       	ldi	r21, 0x43	; 67
    6918:	0e 94 8c 04 	call	0x918	; 0x918 <__gtsf2>
    691c:	18 16       	cp	r1, r24
    691e:	0c f0       	brlt	.+2      	; 0x6922 <GLCD_sendcommand+0x22a>
    6920:	7b c0       	rjmp	.+246    	; 0x6a18 <GLCD_sendcommand+0x320>
	{
		_delay_ms(__us / 1000.0);
    6922:	6d 89       	ldd	r22, Y+21	; 0x15
    6924:	7e 89       	ldd	r23, Y+22	; 0x16
    6926:	8f 89       	ldd	r24, Y+23	; 0x17
    6928:	98 8d       	ldd	r25, Y+24	; 0x18
    692a:	20 e0       	ldi	r18, 0x00	; 0
    692c:	30 e0       	ldi	r19, 0x00	; 0
    692e:	4a e7       	ldi	r20, 0x7A	; 122
    6930:	54 e4       	ldi	r21, 0x44	; 68
    6932:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <__divsf3>
    6936:	dc 01       	movw	r26, r24
    6938:	cb 01       	movw	r24, r22
    693a:	8c 87       	std	Y+12, r24	; 0x0c
    693c:	9d 87       	std	Y+13, r25	; 0x0d
    693e:	ae 87       	std	Y+14, r26	; 0x0e
    6940:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6942:	6c 85       	ldd	r22, Y+12	; 0x0c
    6944:	7d 85       	ldd	r23, Y+13	; 0x0d
    6946:	8e 85       	ldd	r24, Y+14	; 0x0e
    6948:	9f 85       	ldd	r25, Y+15	; 0x0f
    694a:	20 e0       	ldi	r18, 0x00	; 0
    694c:	30 e0       	ldi	r19, 0x00	; 0
    694e:	4a e7       	ldi	r20, 0x7A	; 122
    6950:	53 e4       	ldi	r21, 0x43	; 67
    6952:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    6956:	dc 01       	movw	r26, r24
    6958:	cb 01       	movw	r24, r22
    695a:	88 87       	std	Y+8, r24	; 0x08
    695c:	99 87       	std	Y+9, r25	; 0x09
    695e:	aa 87       	std	Y+10, r26	; 0x0a
    6960:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    6962:	68 85       	ldd	r22, Y+8	; 0x08
    6964:	79 85       	ldd	r23, Y+9	; 0x09
    6966:	8a 85       	ldd	r24, Y+10	; 0x0a
    6968:	9b 85       	ldd	r25, Y+11	; 0x0b
    696a:	20 e0       	ldi	r18, 0x00	; 0
    696c:	30 e0       	ldi	r19, 0x00	; 0
    696e:	40 e8       	ldi	r20, 0x80	; 128
    6970:	5f e3       	ldi	r21, 0x3F	; 63
    6972:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__ltsf2>
    6976:	88 23       	and	r24, r24
    6978:	2c f4       	brge	.+10     	; 0x6984 <GLCD_sendcommand+0x28c>
		__ticks = 1;
    697a:	81 e0       	ldi	r24, 0x01	; 1
    697c:	90 e0       	ldi	r25, 0x00	; 0
    697e:	9f 83       	std	Y+7, r25	; 0x07
    6980:	8e 83       	std	Y+6, r24	; 0x06
    6982:	3f c0       	rjmp	.+126    	; 0x6a02 <GLCD_sendcommand+0x30a>
	else if (__tmp > 65535)
    6984:	68 85       	ldd	r22, Y+8	; 0x08
    6986:	79 85       	ldd	r23, Y+9	; 0x09
    6988:	8a 85       	ldd	r24, Y+10	; 0x0a
    698a:	9b 85       	ldd	r25, Y+11	; 0x0b
    698c:	20 e0       	ldi	r18, 0x00	; 0
    698e:	3f ef       	ldi	r19, 0xFF	; 255
    6990:	4f e7       	ldi	r20, 0x7F	; 127
    6992:	57 e4       	ldi	r21, 0x47	; 71
    6994:	0e 94 8c 04 	call	0x918	; 0x918 <__gtsf2>
    6998:	18 16       	cp	r1, r24
    699a:	4c f5       	brge	.+82     	; 0x69ee <GLCD_sendcommand+0x2f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    699c:	6c 85       	ldd	r22, Y+12	; 0x0c
    699e:	7d 85       	ldd	r23, Y+13	; 0x0d
    69a0:	8e 85       	ldd	r24, Y+14	; 0x0e
    69a2:	9f 85       	ldd	r25, Y+15	; 0x0f
    69a4:	20 e0       	ldi	r18, 0x00	; 0
    69a6:	30 e0       	ldi	r19, 0x00	; 0
    69a8:	40 e2       	ldi	r20, 0x20	; 32
    69aa:	51 e4       	ldi	r21, 0x41	; 65
    69ac:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    69b0:	dc 01       	movw	r26, r24
    69b2:	cb 01       	movw	r24, r22
    69b4:	bc 01       	movw	r22, r24
    69b6:	cd 01       	movw	r24, r26
    69b8:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    69bc:	dc 01       	movw	r26, r24
    69be:	cb 01       	movw	r24, r22
    69c0:	9f 83       	std	Y+7, r25	; 0x07
    69c2:	8e 83       	std	Y+6, r24	; 0x06
    69c4:	0f c0       	rjmp	.+30     	; 0x69e4 <GLCD_sendcommand+0x2ec>
    69c6:	89 e1       	ldi	r24, 0x19	; 25
    69c8:	90 e0       	ldi	r25, 0x00	; 0
    69ca:	9d 83       	std	Y+5, r25	; 0x05
    69cc:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    69ce:	8c 81       	ldd	r24, Y+4	; 0x04
    69d0:	9d 81       	ldd	r25, Y+5	; 0x05
    69d2:	01 97       	sbiw	r24, 0x01	; 1
    69d4:	f1 f7       	brne	.-4      	; 0x69d2 <GLCD_sendcommand+0x2da>
    69d6:	9d 83       	std	Y+5, r25	; 0x05
    69d8:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    69da:	8e 81       	ldd	r24, Y+6	; 0x06
    69dc:	9f 81       	ldd	r25, Y+7	; 0x07
    69de:	01 97       	sbiw	r24, 0x01	; 1
    69e0:	9f 83       	std	Y+7, r25	; 0x07
    69e2:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    69e4:	8e 81       	ldd	r24, Y+6	; 0x06
    69e6:	9f 81       	ldd	r25, Y+7	; 0x07
    69e8:	00 97       	sbiw	r24, 0x00	; 0
    69ea:	69 f7       	brne	.-38     	; 0x69c6 <GLCD_sendcommand+0x2ce>
    69ec:	24 c0       	rjmp	.+72     	; 0x6a36 <GLCD_sendcommand+0x33e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    69ee:	68 85       	ldd	r22, Y+8	; 0x08
    69f0:	79 85       	ldd	r23, Y+9	; 0x09
    69f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    69f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    69f6:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    69fa:	dc 01       	movw	r26, r24
    69fc:	cb 01       	movw	r24, r22
    69fe:	9f 83       	std	Y+7, r25	; 0x07
    6a00:	8e 83       	std	Y+6, r24	; 0x06
    6a02:	8e 81       	ldd	r24, Y+6	; 0x06
    6a04:	9f 81       	ldd	r25, Y+7	; 0x07
    6a06:	9b 83       	std	Y+3, r25	; 0x03
    6a08:	8a 83       	std	Y+2, r24	; 0x02
    6a0a:	8a 81       	ldd	r24, Y+2	; 0x02
    6a0c:	9b 81       	ldd	r25, Y+3	; 0x03
    6a0e:	01 97       	sbiw	r24, 0x01	; 1
    6a10:	f1 f7       	brne	.-4      	; 0x6a0e <GLCD_sendcommand+0x316>
    6a12:	9b 83       	std	Y+3, r25	; 0x03
    6a14:	8a 83       	std	Y+2, r24	; 0x02
    6a16:	0f c0       	rjmp	.+30     	; 0x6a36 <GLCD_sendcommand+0x33e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6a18:	69 89       	ldd	r22, Y+17	; 0x11
    6a1a:	7a 89       	ldd	r23, Y+18	; 0x12
    6a1c:	8b 89       	ldd	r24, Y+19	; 0x13
    6a1e:	9c 89       	ldd	r25, Y+20	; 0x14
    6a20:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    6a24:	dc 01       	movw	r26, r24
    6a26:	cb 01       	movw	r24, r22
    6a28:	88 8b       	std	Y+16, r24	; 0x10
    6a2a:	88 89       	ldd	r24, Y+16	; 0x10
    6a2c:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6a2e:	89 81       	ldd	r24, Y+1	; 0x01
    6a30:	8a 95       	dec	r24
    6a32:	f1 f7       	brne	.-4      	; 0x6a30 <GLCD_sendcommand+0x338>
    6a34:	89 83       	std	Y+1, r24	; 0x01





}
    6a36:	e1 96       	adiw	r28, 0x31	; 49
    6a38:	0f b6       	in	r0, 0x3f	; 63
    6a3a:	f8 94       	cli
    6a3c:	de bf       	out	0x3e, r29	; 62
    6a3e:	0f be       	out	0x3f, r0	; 63
    6a40:	cd bf       	out	0x3d, r28	; 61
    6a42:	cf 91       	pop	r28
    6a44:	df 91       	pop	r29
    6a46:	08 95       	ret

00006a48 <GLCD_init>:

void GLCD_init(void)
{
    6a48:	df 93       	push	r29
    6a4a:	cf 93       	push	r28
    6a4c:	cd b7       	in	r28, 0x3d	; 61
    6a4e:	de b7       	in	r29, 0x3e	; 62
    6a50:	2e 97       	sbiw	r28, 0x0e	; 14
    6a52:	0f b6       	in	r0, 0x3f	; 63
    6a54:	f8 94       	cli
    6a56:	de bf       	out	0x3e, r29	; 62
    6a58:	0f be       	out	0x3f, r0	; 63
    6a5a:	cd bf       	out	0x3d, r28	; 61

	    GPIO_setupPinDirection(GLCD_CS1_PORT_ID, GLCD_CS1_PIN_ID, PIN_OUTPUT);
    6a5c:	81 e0       	ldi	r24, 0x01	; 1
    6a5e:	64 e0       	ldi	r22, 0x04	; 4
    6a60:	41 e0       	ldi	r20, 0x01	; 1
    6a62:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <GPIO_setupPinDirection>
		GPIO_setupPinDirection(GLCD_CS2_PORT_ID, GLCD_CS2_PIN_ID, PIN_OUTPUT);
    6a66:	81 e0       	ldi	r24, 0x01	; 1
    6a68:	65 e0       	ldi	r22, 0x05	; 5
    6a6a:	41 e0       	ldi	r20, 0x01	; 1
    6a6c:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <GPIO_setupPinDirection>
		GPIO_setupPinDirection(GLCD_E_PORT_ID, GLCD_E_PIN_ID, PIN_OUTPUT);
    6a70:	81 e0       	ldi	r24, 0x01	; 1
    6a72:	60 e0       	ldi	r22, 0x00	; 0
    6a74:	41 e0       	ldi	r20, 0x01	; 1
    6a76:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <GPIO_setupPinDirection>
		GPIO_setupPinDirection(GLCD_RS_PORT_ID, GLCD_RS_PIN_ID, PIN_OUTPUT);
    6a7a:	81 e0       	ldi	r24, 0x01	; 1
    6a7c:	66 e0       	ldi	r22, 0x06	; 6
    6a7e:	41 e0       	ldi	r20, 0x01	; 1
    6a80:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <GPIO_setupPinDirection>
		GPIO_setupPinDirection(GLCD_RW_PORT_ID, GLCD_RW_PIN_ID, PIN_OUTPUT);
    6a84:	81 e0       	ldi	r24, 0x01	; 1
    6a86:	67 e0       	ldi	r22, 0x07	; 7
    6a88:	41 e0       	ldi	r20, 0x01	; 1
    6a8a:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <GPIO_setupPinDirection>
		GPIO_setupPinDirection(GLCD_RST_PORT_ID, GLCD_RST_PIN_ID, PIN_OUTPUT);
    6a8e:	81 e0       	ldi	r24, 0x01	; 1
    6a90:	61 e0       	ldi	r22, 0x01	; 1
    6a92:	41 e0       	ldi	r20, 0x01	; 1
    6a94:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <GPIO_setupPinDirection>
		GPIO_setupPortDirection(GLCD_DATA_PORT_ID, PORT_OUTPUT);
    6a98:	80 e0       	ldi	r24, 0x00	; 0
    6a9a:	6f ef       	ldi	r22, 0xFF	; 255
    6a9c:	0e 94 d0 31 	call	0x63a0	; 0x63a0 <GPIO_setupPortDirection>


		GPIO_writePin(GLCD_CS1_PORT_ID,GLCD_CS1_PIN_ID , LOGIC_HIGH);
    6aa0:	81 e0       	ldi	r24, 0x01	; 1
    6aa2:	64 e0       	ldi	r22, 0x04	; 4
    6aa4:	41 e0       	ldi	r20, 0x01	; 1
    6aa6:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
		GPIO_writePin(GLCD_CS2_PORT_ID,GLCD_CS2_PIN_ID , LOGIC_HIGH);
    6aaa:	81 e0       	ldi	r24, 0x01	; 1
    6aac:	65 e0       	ldi	r22, 0x05	; 5
    6aae:	41 e0       	ldi	r20, 0x01	; 1
    6ab0:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
		GPIO_writePin(GLCD_RST_PORT_ID,GLCD_RST_PIN_ID , LOGIC_HIGH);
    6ab4:	81 e0       	ldi	r24, 0x01	; 1
    6ab6:	61 e0       	ldi	r22, 0x01	; 1
    6ab8:	41 e0       	ldi	r20, 0x01	; 1
    6aba:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
    6abe:	80 e0       	ldi	r24, 0x00	; 0
    6ac0:	90 e0       	ldi	r25, 0x00	; 0
    6ac2:	a0 ea       	ldi	r26, 0xA0	; 160
    6ac4:	b1 e4       	ldi	r27, 0x41	; 65
    6ac6:	8b 87       	std	Y+11, r24	; 0x0b
    6ac8:	9c 87       	std	Y+12, r25	; 0x0c
    6aca:	ad 87       	std	Y+13, r26	; 0x0d
    6acc:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6ace:	6b 85       	ldd	r22, Y+11	; 0x0b
    6ad0:	7c 85       	ldd	r23, Y+12	; 0x0c
    6ad2:	8d 85       	ldd	r24, Y+13	; 0x0d
    6ad4:	9e 85       	ldd	r25, Y+14	; 0x0e
    6ad6:	20 e0       	ldi	r18, 0x00	; 0
    6ad8:	30 e0       	ldi	r19, 0x00	; 0
    6ada:	4a e7       	ldi	r20, 0x7A	; 122
    6adc:	53 e4       	ldi	r21, 0x43	; 67
    6ade:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    6ae2:	dc 01       	movw	r26, r24
    6ae4:	cb 01       	movw	r24, r22
    6ae6:	8f 83       	std	Y+7, r24	; 0x07
    6ae8:	98 87       	std	Y+8, r25	; 0x08
    6aea:	a9 87       	std	Y+9, r26	; 0x09
    6aec:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    6aee:	6f 81       	ldd	r22, Y+7	; 0x07
    6af0:	78 85       	ldd	r23, Y+8	; 0x08
    6af2:	89 85       	ldd	r24, Y+9	; 0x09
    6af4:	9a 85       	ldd	r25, Y+10	; 0x0a
    6af6:	20 e0       	ldi	r18, 0x00	; 0
    6af8:	30 e0       	ldi	r19, 0x00	; 0
    6afa:	40 e8       	ldi	r20, 0x80	; 128
    6afc:	5f e3       	ldi	r21, 0x3F	; 63
    6afe:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__ltsf2>
    6b02:	88 23       	and	r24, r24
    6b04:	2c f4       	brge	.+10     	; 0x6b10 <GLCD_init+0xc8>
		__ticks = 1;
    6b06:	81 e0       	ldi	r24, 0x01	; 1
    6b08:	90 e0       	ldi	r25, 0x00	; 0
    6b0a:	9e 83       	std	Y+6, r25	; 0x06
    6b0c:	8d 83       	std	Y+5, r24	; 0x05
    6b0e:	3f c0       	rjmp	.+126    	; 0x6b8e <GLCD_init+0x146>
	else if (__tmp > 65535)
    6b10:	6f 81       	ldd	r22, Y+7	; 0x07
    6b12:	78 85       	ldd	r23, Y+8	; 0x08
    6b14:	89 85       	ldd	r24, Y+9	; 0x09
    6b16:	9a 85       	ldd	r25, Y+10	; 0x0a
    6b18:	20 e0       	ldi	r18, 0x00	; 0
    6b1a:	3f ef       	ldi	r19, 0xFF	; 255
    6b1c:	4f e7       	ldi	r20, 0x7F	; 127
    6b1e:	57 e4       	ldi	r21, 0x47	; 71
    6b20:	0e 94 8c 04 	call	0x918	; 0x918 <__gtsf2>
    6b24:	18 16       	cp	r1, r24
    6b26:	4c f5       	brge	.+82     	; 0x6b7a <GLCD_init+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6b28:	6b 85       	ldd	r22, Y+11	; 0x0b
    6b2a:	7c 85       	ldd	r23, Y+12	; 0x0c
    6b2c:	8d 85       	ldd	r24, Y+13	; 0x0d
    6b2e:	9e 85       	ldd	r25, Y+14	; 0x0e
    6b30:	20 e0       	ldi	r18, 0x00	; 0
    6b32:	30 e0       	ldi	r19, 0x00	; 0
    6b34:	40 e2       	ldi	r20, 0x20	; 32
    6b36:	51 e4       	ldi	r21, 0x41	; 65
    6b38:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    6b3c:	dc 01       	movw	r26, r24
    6b3e:	cb 01       	movw	r24, r22
    6b40:	bc 01       	movw	r22, r24
    6b42:	cd 01       	movw	r24, r26
    6b44:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    6b48:	dc 01       	movw	r26, r24
    6b4a:	cb 01       	movw	r24, r22
    6b4c:	9e 83       	std	Y+6, r25	; 0x06
    6b4e:	8d 83       	std	Y+5, r24	; 0x05
    6b50:	0f c0       	rjmp	.+30     	; 0x6b70 <GLCD_init+0x128>
    6b52:	89 e1       	ldi	r24, 0x19	; 25
    6b54:	90 e0       	ldi	r25, 0x00	; 0
    6b56:	9c 83       	std	Y+4, r25	; 0x04
    6b58:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6b5a:	8b 81       	ldd	r24, Y+3	; 0x03
    6b5c:	9c 81       	ldd	r25, Y+4	; 0x04
    6b5e:	01 97       	sbiw	r24, 0x01	; 1
    6b60:	f1 f7       	brne	.-4      	; 0x6b5e <GLCD_init+0x116>
    6b62:	9c 83       	std	Y+4, r25	; 0x04
    6b64:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6b66:	8d 81       	ldd	r24, Y+5	; 0x05
    6b68:	9e 81       	ldd	r25, Y+6	; 0x06
    6b6a:	01 97       	sbiw	r24, 0x01	; 1
    6b6c:	9e 83       	std	Y+6, r25	; 0x06
    6b6e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6b70:	8d 81       	ldd	r24, Y+5	; 0x05
    6b72:	9e 81       	ldd	r25, Y+6	; 0x06
    6b74:	00 97       	sbiw	r24, 0x00	; 0
    6b76:	69 f7       	brne	.-38     	; 0x6b52 <GLCD_init+0x10a>
    6b78:	14 c0       	rjmp	.+40     	; 0x6ba2 <GLCD_init+0x15a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6b7a:	6f 81       	ldd	r22, Y+7	; 0x07
    6b7c:	78 85       	ldd	r23, Y+8	; 0x08
    6b7e:	89 85       	ldd	r24, Y+9	; 0x09
    6b80:	9a 85       	ldd	r25, Y+10	; 0x0a
    6b82:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    6b86:	dc 01       	movw	r26, r24
    6b88:	cb 01       	movw	r24, r22
    6b8a:	9e 83       	std	Y+6, r25	; 0x06
    6b8c:	8d 83       	std	Y+5, r24	; 0x05
    6b8e:	8d 81       	ldd	r24, Y+5	; 0x05
    6b90:	9e 81       	ldd	r25, Y+6	; 0x06
    6b92:	9a 83       	std	Y+2, r25	; 0x02
    6b94:	89 83       	std	Y+1, r24	; 0x01
    6b96:	89 81       	ldd	r24, Y+1	; 0x01
    6b98:	9a 81       	ldd	r25, Y+2	; 0x02
    6b9a:	01 97       	sbiw	r24, 0x01	; 1
    6b9c:	f1 f7       	brne	.-4      	; 0x6b9a <GLCD_init+0x152>
    6b9e:	9a 83       	std	Y+2, r25	; 0x02
    6ba0:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(20);


	    GLCD_sendcommand(0x3E);		/* Display OFF */
    6ba2:	8e e3       	ldi	r24, 0x3E	; 62
    6ba4:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>
		GLCD_sendcommand(0x40);		/* Set Y address (column=0) */
    6ba8:	80 e4       	ldi	r24, 0x40	; 64
    6baa:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>
		GLCD_sendcommand(0xB8);		/* Set x address (page=0) */
    6bae:	88 eb       	ldi	r24, 0xB8	; 184
    6bb0:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>
		GLCD_sendcommand(0xC0);		/* Set z address (start line=0) */
    6bb4:	80 ec       	ldi	r24, 0xC0	; 192
    6bb6:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>
		GLCD_sendcommand(0x3F);		/* Display ON */
    6bba:	8f e3       	ldi	r24, 0x3F	; 63
    6bbc:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>

}
    6bc0:	2e 96       	adiw	r28, 0x0e	; 14
    6bc2:	0f b6       	in	r0, 0x3f	; 63
    6bc4:	f8 94       	cli
    6bc6:	de bf       	out	0x3e, r29	; 62
    6bc8:	0f be       	out	0x3f, r0	; 63
    6bca:	cd bf       	out	0x3d, r28	; 61
    6bcc:	cf 91       	pop	r28
    6bce:	df 91       	pop	r29
    6bd0:	08 95       	ret

00006bd2 <GLCD_senddata>:




void GLCD_senddata(uint8 data)
{
    6bd2:	df 93       	push	r29
    6bd4:	cf 93       	push	r28
    6bd6:	cd b7       	in	r28, 0x3d	; 61
    6bd8:	de b7       	in	r29, 0x3e	; 62
    6bda:	e1 97       	sbiw	r28, 0x31	; 49
    6bdc:	0f b6       	in	r0, 0x3f	; 63
    6bde:	f8 94       	cli
    6be0:	de bf       	out	0x3e, r29	; 62
    6be2:	0f be       	out	0x3f, r0	; 63
    6be4:	cd bf       	out	0x3d, r28	; 61
    6be6:	89 ab       	std	Y+49, r24	; 0x31


		   GPIO_writePort(GLCD_DATA_PORT_ID, data);
    6be8:	80 e0       	ldi	r24, 0x00	; 0
    6bea:	69 a9       	ldd	r22, Y+49	; 0x31
    6bec:	0e 94 14 32 	call	0x6428	; 0x6428 <GPIO_writePort>

		    GPIO_writePin(GLCD_RS_PORT_ID,GLCD_RS_PIN_ID , LOGIC_HIGH);
    6bf0:	81 e0       	ldi	r24, 0x01	; 1
    6bf2:	66 e0       	ldi	r22, 0x06	; 6
    6bf4:	41 e0       	ldi	r20, 0x01	; 1
    6bf6:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
			GPIO_writePin(GLCD_RW_PORT_ID,GLCD_RW_PIN_ID , LOGIC_LOW);
    6bfa:	81 e0       	ldi	r24, 0x01	; 1
    6bfc:	67 e0       	ldi	r22, 0x07	; 7
    6bfe:	40 e0       	ldi	r20, 0x00	; 0
    6c00:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
			GPIO_writePin(GLCD_E_PORT_ID,GLCD_E_PIN_ID , LOGIC_HIGH);
    6c04:	81 e0       	ldi	r24, 0x01	; 1
    6c06:	60 e0       	ldi	r22, 0x00	; 0
    6c08:	41 e0       	ldi	r20, 0x01	; 1
    6c0a:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
    6c0e:	80 e0       	ldi	r24, 0x00	; 0
    6c10:	90 e0       	ldi	r25, 0x00	; 0
    6c12:	a0 ea       	ldi	r26, 0xA0	; 160
    6c14:	b0 e4       	ldi	r27, 0x40	; 64
    6c16:	8d a7       	std	Y+45, r24	; 0x2d
    6c18:	9e a7       	std	Y+46, r25	; 0x2e
    6c1a:	af a7       	std	Y+47, r26	; 0x2f
    6c1c:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    6c1e:	6d a5       	ldd	r22, Y+45	; 0x2d
    6c20:	7e a5       	ldd	r23, Y+46	; 0x2e
    6c22:	8f a5       	ldd	r24, Y+47	; 0x2f
    6c24:	98 a9       	ldd	r25, Y+48	; 0x30
    6c26:	2b ea       	ldi	r18, 0xAB	; 171
    6c28:	3a ea       	ldi	r19, 0xAA	; 170
    6c2a:	4a ea       	ldi	r20, 0xAA	; 170
    6c2c:	5e e3       	ldi	r21, 0x3E	; 62
    6c2e:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    6c32:	dc 01       	movw	r26, r24
    6c34:	cb 01       	movw	r24, r22
    6c36:	89 a7       	std	Y+41, r24	; 0x29
    6c38:	9a a7       	std	Y+42, r25	; 0x2a
    6c3a:	ab a7       	std	Y+43, r26	; 0x2b
    6c3c:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    6c3e:	69 a5       	ldd	r22, Y+41	; 0x29
    6c40:	7a a5       	ldd	r23, Y+42	; 0x2a
    6c42:	8b a5       	ldd	r24, Y+43	; 0x2b
    6c44:	9c a5       	ldd	r25, Y+44	; 0x2c
    6c46:	20 e0       	ldi	r18, 0x00	; 0
    6c48:	30 e0       	ldi	r19, 0x00	; 0
    6c4a:	40 e8       	ldi	r20, 0x80	; 128
    6c4c:	5f e3       	ldi	r21, 0x3F	; 63
    6c4e:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__ltsf2>
    6c52:	88 23       	and	r24, r24
    6c54:	1c f4       	brge	.+6      	; 0x6c5c <GLCD_senddata+0x8a>
		__ticks = 1;
    6c56:	81 e0       	ldi	r24, 0x01	; 1
    6c58:	88 a7       	std	Y+40, r24	; 0x28
    6c5a:	91 c0       	rjmp	.+290    	; 0x6d7e <GLCD_senddata+0x1ac>
	else if (__tmp > 255)
    6c5c:	69 a5       	ldd	r22, Y+41	; 0x29
    6c5e:	7a a5       	ldd	r23, Y+42	; 0x2a
    6c60:	8b a5       	ldd	r24, Y+43	; 0x2b
    6c62:	9c a5       	ldd	r25, Y+44	; 0x2c
    6c64:	20 e0       	ldi	r18, 0x00	; 0
    6c66:	30 e0       	ldi	r19, 0x00	; 0
    6c68:	4f e7       	ldi	r20, 0x7F	; 127
    6c6a:	53 e4       	ldi	r21, 0x43	; 67
    6c6c:	0e 94 8c 04 	call	0x918	; 0x918 <__gtsf2>
    6c70:	18 16       	cp	r1, r24
    6c72:	0c f0       	brlt	.+2      	; 0x6c76 <GLCD_senddata+0xa4>
    6c74:	7b c0       	rjmp	.+246    	; 0x6d6c <GLCD_senddata+0x19a>
	{
		_delay_ms(__us / 1000.0);
    6c76:	6d a5       	ldd	r22, Y+45	; 0x2d
    6c78:	7e a5       	ldd	r23, Y+46	; 0x2e
    6c7a:	8f a5       	ldd	r24, Y+47	; 0x2f
    6c7c:	98 a9       	ldd	r25, Y+48	; 0x30
    6c7e:	20 e0       	ldi	r18, 0x00	; 0
    6c80:	30 e0       	ldi	r19, 0x00	; 0
    6c82:	4a e7       	ldi	r20, 0x7A	; 122
    6c84:	54 e4       	ldi	r21, 0x44	; 68
    6c86:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <__divsf3>
    6c8a:	dc 01       	movw	r26, r24
    6c8c:	cb 01       	movw	r24, r22
    6c8e:	8c a3       	std	Y+36, r24	; 0x24
    6c90:	9d a3       	std	Y+37, r25	; 0x25
    6c92:	ae a3       	std	Y+38, r26	; 0x26
    6c94:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6c96:	6c a1       	ldd	r22, Y+36	; 0x24
    6c98:	7d a1       	ldd	r23, Y+37	; 0x25
    6c9a:	8e a1       	ldd	r24, Y+38	; 0x26
    6c9c:	9f a1       	ldd	r25, Y+39	; 0x27
    6c9e:	20 e0       	ldi	r18, 0x00	; 0
    6ca0:	30 e0       	ldi	r19, 0x00	; 0
    6ca2:	4a e7       	ldi	r20, 0x7A	; 122
    6ca4:	53 e4       	ldi	r21, 0x43	; 67
    6ca6:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    6caa:	dc 01       	movw	r26, r24
    6cac:	cb 01       	movw	r24, r22
    6cae:	88 a3       	std	Y+32, r24	; 0x20
    6cb0:	99 a3       	std	Y+33, r25	; 0x21
    6cb2:	aa a3       	std	Y+34, r26	; 0x22
    6cb4:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    6cb6:	68 a1       	ldd	r22, Y+32	; 0x20
    6cb8:	79 a1       	ldd	r23, Y+33	; 0x21
    6cba:	8a a1       	ldd	r24, Y+34	; 0x22
    6cbc:	9b a1       	ldd	r25, Y+35	; 0x23
    6cbe:	20 e0       	ldi	r18, 0x00	; 0
    6cc0:	30 e0       	ldi	r19, 0x00	; 0
    6cc2:	40 e8       	ldi	r20, 0x80	; 128
    6cc4:	5f e3       	ldi	r21, 0x3F	; 63
    6cc6:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__ltsf2>
    6cca:	88 23       	and	r24, r24
    6ccc:	2c f4       	brge	.+10     	; 0x6cd8 <GLCD_senddata+0x106>
		__ticks = 1;
    6cce:	81 e0       	ldi	r24, 0x01	; 1
    6cd0:	90 e0       	ldi	r25, 0x00	; 0
    6cd2:	9f 8f       	std	Y+31, r25	; 0x1f
    6cd4:	8e 8f       	std	Y+30, r24	; 0x1e
    6cd6:	3f c0       	rjmp	.+126    	; 0x6d56 <GLCD_senddata+0x184>
	else if (__tmp > 65535)
    6cd8:	68 a1       	ldd	r22, Y+32	; 0x20
    6cda:	79 a1       	ldd	r23, Y+33	; 0x21
    6cdc:	8a a1       	ldd	r24, Y+34	; 0x22
    6cde:	9b a1       	ldd	r25, Y+35	; 0x23
    6ce0:	20 e0       	ldi	r18, 0x00	; 0
    6ce2:	3f ef       	ldi	r19, 0xFF	; 255
    6ce4:	4f e7       	ldi	r20, 0x7F	; 127
    6ce6:	57 e4       	ldi	r21, 0x47	; 71
    6ce8:	0e 94 8c 04 	call	0x918	; 0x918 <__gtsf2>
    6cec:	18 16       	cp	r1, r24
    6cee:	4c f5       	brge	.+82     	; 0x6d42 <GLCD_senddata+0x170>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6cf0:	6c a1       	ldd	r22, Y+36	; 0x24
    6cf2:	7d a1       	ldd	r23, Y+37	; 0x25
    6cf4:	8e a1       	ldd	r24, Y+38	; 0x26
    6cf6:	9f a1       	ldd	r25, Y+39	; 0x27
    6cf8:	20 e0       	ldi	r18, 0x00	; 0
    6cfa:	30 e0       	ldi	r19, 0x00	; 0
    6cfc:	40 e2       	ldi	r20, 0x20	; 32
    6cfe:	51 e4       	ldi	r21, 0x41	; 65
    6d00:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    6d04:	dc 01       	movw	r26, r24
    6d06:	cb 01       	movw	r24, r22
    6d08:	bc 01       	movw	r22, r24
    6d0a:	cd 01       	movw	r24, r26
    6d0c:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    6d10:	dc 01       	movw	r26, r24
    6d12:	cb 01       	movw	r24, r22
    6d14:	9f 8f       	std	Y+31, r25	; 0x1f
    6d16:	8e 8f       	std	Y+30, r24	; 0x1e
    6d18:	0f c0       	rjmp	.+30     	; 0x6d38 <GLCD_senddata+0x166>
    6d1a:	89 e1       	ldi	r24, 0x19	; 25
    6d1c:	90 e0       	ldi	r25, 0x00	; 0
    6d1e:	9d 8f       	std	Y+29, r25	; 0x1d
    6d20:	8c 8f       	std	Y+28, r24	; 0x1c
    6d22:	8c 8d       	ldd	r24, Y+28	; 0x1c
    6d24:	9d 8d       	ldd	r25, Y+29	; 0x1d
    6d26:	01 97       	sbiw	r24, 0x01	; 1
    6d28:	f1 f7       	brne	.-4      	; 0x6d26 <GLCD_senddata+0x154>
    6d2a:	9d 8f       	std	Y+29, r25	; 0x1d
    6d2c:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6d2e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6d30:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6d32:	01 97       	sbiw	r24, 0x01	; 1
    6d34:	9f 8f       	std	Y+31, r25	; 0x1f
    6d36:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6d38:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6d3a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6d3c:	00 97       	sbiw	r24, 0x00	; 0
    6d3e:	69 f7       	brne	.-38     	; 0x6d1a <GLCD_senddata+0x148>
    6d40:	24 c0       	rjmp	.+72     	; 0x6d8a <GLCD_senddata+0x1b8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6d42:	68 a1       	ldd	r22, Y+32	; 0x20
    6d44:	79 a1       	ldd	r23, Y+33	; 0x21
    6d46:	8a a1       	ldd	r24, Y+34	; 0x22
    6d48:	9b a1       	ldd	r25, Y+35	; 0x23
    6d4a:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    6d4e:	dc 01       	movw	r26, r24
    6d50:	cb 01       	movw	r24, r22
    6d52:	9f 8f       	std	Y+31, r25	; 0x1f
    6d54:	8e 8f       	std	Y+30, r24	; 0x1e
    6d56:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6d58:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6d5a:	9b 8f       	std	Y+27, r25	; 0x1b
    6d5c:	8a 8f       	std	Y+26, r24	; 0x1a
    6d5e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6d60:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6d62:	01 97       	sbiw	r24, 0x01	; 1
    6d64:	f1 f7       	brne	.-4      	; 0x6d62 <GLCD_senddata+0x190>
    6d66:	9b 8f       	std	Y+27, r25	; 0x1b
    6d68:	8a 8f       	std	Y+26, r24	; 0x1a
    6d6a:	0f c0       	rjmp	.+30     	; 0x6d8a <GLCD_senddata+0x1b8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6d6c:	69 a5       	ldd	r22, Y+41	; 0x29
    6d6e:	7a a5       	ldd	r23, Y+42	; 0x2a
    6d70:	8b a5       	ldd	r24, Y+43	; 0x2b
    6d72:	9c a5       	ldd	r25, Y+44	; 0x2c
    6d74:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    6d78:	dc 01       	movw	r26, r24
    6d7a:	cb 01       	movw	r24, r22
    6d7c:	88 a7       	std	Y+40, r24	; 0x28
    6d7e:	88 a5       	ldd	r24, Y+40	; 0x28
    6d80:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6d82:	89 8d       	ldd	r24, Y+25	; 0x19
    6d84:	8a 95       	dec	r24
    6d86:	f1 f7       	brne	.-4      	; 0x6d84 <GLCD_senddata+0x1b2>
    6d88:	89 8f       	std	Y+25, r24	; 0x19
			_delay_us(5);
			GPIO_writePin(GLCD_E_PORT_ID,GLCD_E_PIN_ID , LOGIC_LOW);
    6d8a:	81 e0       	ldi	r24, 0x01	; 1
    6d8c:	60 e0       	ldi	r22, 0x00	; 0
    6d8e:	40 e0       	ldi	r20, 0x00	; 0
    6d90:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
    6d94:	80 e0       	ldi	r24, 0x00	; 0
    6d96:	90 e0       	ldi	r25, 0x00	; 0
    6d98:	a0 ea       	ldi	r26, 0xA0	; 160
    6d9a:	b0 e4       	ldi	r27, 0x40	; 64
    6d9c:	8d 8b       	std	Y+21, r24	; 0x15
    6d9e:	9e 8b       	std	Y+22, r25	; 0x16
    6da0:	af 8b       	std	Y+23, r26	; 0x17
    6da2:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    6da4:	6d 89       	ldd	r22, Y+21	; 0x15
    6da6:	7e 89       	ldd	r23, Y+22	; 0x16
    6da8:	8f 89       	ldd	r24, Y+23	; 0x17
    6daa:	98 8d       	ldd	r25, Y+24	; 0x18
    6dac:	2b ea       	ldi	r18, 0xAB	; 171
    6dae:	3a ea       	ldi	r19, 0xAA	; 170
    6db0:	4a ea       	ldi	r20, 0xAA	; 170
    6db2:	5e e3       	ldi	r21, 0x3E	; 62
    6db4:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    6db8:	dc 01       	movw	r26, r24
    6dba:	cb 01       	movw	r24, r22
    6dbc:	89 8b       	std	Y+17, r24	; 0x11
    6dbe:	9a 8b       	std	Y+18, r25	; 0x12
    6dc0:	ab 8b       	std	Y+19, r26	; 0x13
    6dc2:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    6dc4:	69 89       	ldd	r22, Y+17	; 0x11
    6dc6:	7a 89       	ldd	r23, Y+18	; 0x12
    6dc8:	8b 89       	ldd	r24, Y+19	; 0x13
    6dca:	9c 89       	ldd	r25, Y+20	; 0x14
    6dcc:	20 e0       	ldi	r18, 0x00	; 0
    6dce:	30 e0       	ldi	r19, 0x00	; 0
    6dd0:	40 e8       	ldi	r20, 0x80	; 128
    6dd2:	5f e3       	ldi	r21, 0x3F	; 63
    6dd4:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__ltsf2>
    6dd8:	88 23       	and	r24, r24
    6dda:	1c f4       	brge	.+6      	; 0x6de2 <GLCD_senddata+0x210>
		__ticks = 1;
    6ddc:	81 e0       	ldi	r24, 0x01	; 1
    6dde:	88 8b       	std	Y+16, r24	; 0x10
    6de0:	91 c0       	rjmp	.+290    	; 0x6f04 <GLCD_senddata+0x332>
	else if (__tmp > 255)
    6de2:	69 89       	ldd	r22, Y+17	; 0x11
    6de4:	7a 89       	ldd	r23, Y+18	; 0x12
    6de6:	8b 89       	ldd	r24, Y+19	; 0x13
    6de8:	9c 89       	ldd	r25, Y+20	; 0x14
    6dea:	20 e0       	ldi	r18, 0x00	; 0
    6dec:	30 e0       	ldi	r19, 0x00	; 0
    6dee:	4f e7       	ldi	r20, 0x7F	; 127
    6df0:	53 e4       	ldi	r21, 0x43	; 67
    6df2:	0e 94 8c 04 	call	0x918	; 0x918 <__gtsf2>
    6df6:	18 16       	cp	r1, r24
    6df8:	0c f0       	brlt	.+2      	; 0x6dfc <GLCD_senddata+0x22a>
    6dfa:	7b c0       	rjmp	.+246    	; 0x6ef2 <GLCD_senddata+0x320>
	{
		_delay_ms(__us / 1000.0);
    6dfc:	6d 89       	ldd	r22, Y+21	; 0x15
    6dfe:	7e 89       	ldd	r23, Y+22	; 0x16
    6e00:	8f 89       	ldd	r24, Y+23	; 0x17
    6e02:	98 8d       	ldd	r25, Y+24	; 0x18
    6e04:	20 e0       	ldi	r18, 0x00	; 0
    6e06:	30 e0       	ldi	r19, 0x00	; 0
    6e08:	4a e7       	ldi	r20, 0x7A	; 122
    6e0a:	54 e4       	ldi	r21, 0x44	; 68
    6e0c:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <__divsf3>
    6e10:	dc 01       	movw	r26, r24
    6e12:	cb 01       	movw	r24, r22
    6e14:	8c 87       	std	Y+12, r24	; 0x0c
    6e16:	9d 87       	std	Y+13, r25	; 0x0d
    6e18:	ae 87       	std	Y+14, r26	; 0x0e
    6e1a:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6e1c:	6c 85       	ldd	r22, Y+12	; 0x0c
    6e1e:	7d 85       	ldd	r23, Y+13	; 0x0d
    6e20:	8e 85       	ldd	r24, Y+14	; 0x0e
    6e22:	9f 85       	ldd	r25, Y+15	; 0x0f
    6e24:	20 e0       	ldi	r18, 0x00	; 0
    6e26:	30 e0       	ldi	r19, 0x00	; 0
    6e28:	4a e7       	ldi	r20, 0x7A	; 122
    6e2a:	53 e4       	ldi	r21, 0x43	; 67
    6e2c:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    6e30:	dc 01       	movw	r26, r24
    6e32:	cb 01       	movw	r24, r22
    6e34:	88 87       	std	Y+8, r24	; 0x08
    6e36:	99 87       	std	Y+9, r25	; 0x09
    6e38:	aa 87       	std	Y+10, r26	; 0x0a
    6e3a:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    6e3c:	68 85       	ldd	r22, Y+8	; 0x08
    6e3e:	79 85       	ldd	r23, Y+9	; 0x09
    6e40:	8a 85       	ldd	r24, Y+10	; 0x0a
    6e42:	9b 85       	ldd	r25, Y+11	; 0x0b
    6e44:	20 e0       	ldi	r18, 0x00	; 0
    6e46:	30 e0       	ldi	r19, 0x00	; 0
    6e48:	40 e8       	ldi	r20, 0x80	; 128
    6e4a:	5f e3       	ldi	r21, 0x3F	; 63
    6e4c:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__ltsf2>
    6e50:	88 23       	and	r24, r24
    6e52:	2c f4       	brge	.+10     	; 0x6e5e <GLCD_senddata+0x28c>
		__ticks = 1;
    6e54:	81 e0       	ldi	r24, 0x01	; 1
    6e56:	90 e0       	ldi	r25, 0x00	; 0
    6e58:	9f 83       	std	Y+7, r25	; 0x07
    6e5a:	8e 83       	std	Y+6, r24	; 0x06
    6e5c:	3f c0       	rjmp	.+126    	; 0x6edc <GLCD_senddata+0x30a>
	else if (__tmp > 65535)
    6e5e:	68 85       	ldd	r22, Y+8	; 0x08
    6e60:	79 85       	ldd	r23, Y+9	; 0x09
    6e62:	8a 85       	ldd	r24, Y+10	; 0x0a
    6e64:	9b 85       	ldd	r25, Y+11	; 0x0b
    6e66:	20 e0       	ldi	r18, 0x00	; 0
    6e68:	3f ef       	ldi	r19, 0xFF	; 255
    6e6a:	4f e7       	ldi	r20, 0x7F	; 127
    6e6c:	57 e4       	ldi	r21, 0x47	; 71
    6e6e:	0e 94 8c 04 	call	0x918	; 0x918 <__gtsf2>
    6e72:	18 16       	cp	r1, r24
    6e74:	4c f5       	brge	.+82     	; 0x6ec8 <GLCD_senddata+0x2f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6e76:	6c 85       	ldd	r22, Y+12	; 0x0c
    6e78:	7d 85       	ldd	r23, Y+13	; 0x0d
    6e7a:	8e 85       	ldd	r24, Y+14	; 0x0e
    6e7c:	9f 85       	ldd	r25, Y+15	; 0x0f
    6e7e:	20 e0       	ldi	r18, 0x00	; 0
    6e80:	30 e0       	ldi	r19, 0x00	; 0
    6e82:	40 e2       	ldi	r20, 0x20	; 32
    6e84:	51 e4       	ldi	r21, 0x41	; 65
    6e86:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    6e8a:	dc 01       	movw	r26, r24
    6e8c:	cb 01       	movw	r24, r22
    6e8e:	bc 01       	movw	r22, r24
    6e90:	cd 01       	movw	r24, r26
    6e92:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    6e96:	dc 01       	movw	r26, r24
    6e98:	cb 01       	movw	r24, r22
    6e9a:	9f 83       	std	Y+7, r25	; 0x07
    6e9c:	8e 83       	std	Y+6, r24	; 0x06
    6e9e:	0f c0       	rjmp	.+30     	; 0x6ebe <GLCD_senddata+0x2ec>
    6ea0:	89 e1       	ldi	r24, 0x19	; 25
    6ea2:	90 e0       	ldi	r25, 0x00	; 0
    6ea4:	9d 83       	std	Y+5, r25	; 0x05
    6ea6:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6ea8:	8c 81       	ldd	r24, Y+4	; 0x04
    6eaa:	9d 81       	ldd	r25, Y+5	; 0x05
    6eac:	01 97       	sbiw	r24, 0x01	; 1
    6eae:	f1 f7       	brne	.-4      	; 0x6eac <GLCD_senddata+0x2da>
    6eb0:	9d 83       	std	Y+5, r25	; 0x05
    6eb2:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6eb4:	8e 81       	ldd	r24, Y+6	; 0x06
    6eb6:	9f 81       	ldd	r25, Y+7	; 0x07
    6eb8:	01 97       	sbiw	r24, 0x01	; 1
    6eba:	9f 83       	std	Y+7, r25	; 0x07
    6ebc:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6ebe:	8e 81       	ldd	r24, Y+6	; 0x06
    6ec0:	9f 81       	ldd	r25, Y+7	; 0x07
    6ec2:	00 97       	sbiw	r24, 0x00	; 0
    6ec4:	69 f7       	brne	.-38     	; 0x6ea0 <GLCD_senddata+0x2ce>
    6ec6:	24 c0       	rjmp	.+72     	; 0x6f10 <GLCD_senddata+0x33e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6ec8:	68 85       	ldd	r22, Y+8	; 0x08
    6eca:	79 85       	ldd	r23, Y+9	; 0x09
    6ecc:	8a 85       	ldd	r24, Y+10	; 0x0a
    6ece:	9b 85       	ldd	r25, Y+11	; 0x0b
    6ed0:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    6ed4:	dc 01       	movw	r26, r24
    6ed6:	cb 01       	movw	r24, r22
    6ed8:	9f 83       	std	Y+7, r25	; 0x07
    6eda:	8e 83       	std	Y+6, r24	; 0x06
    6edc:	8e 81       	ldd	r24, Y+6	; 0x06
    6ede:	9f 81       	ldd	r25, Y+7	; 0x07
    6ee0:	9b 83       	std	Y+3, r25	; 0x03
    6ee2:	8a 83       	std	Y+2, r24	; 0x02
    6ee4:	8a 81       	ldd	r24, Y+2	; 0x02
    6ee6:	9b 81       	ldd	r25, Y+3	; 0x03
    6ee8:	01 97       	sbiw	r24, 0x01	; 1
    6eea:	f1 f7       	brne	.-4      	; 0x6ee8 <GLCD_senddata+0x316>
    6eec:	9b 83       	std	Y+3, r25	; 0x03
    6eee:	8a 83       	std	Y+2, r24	; 0x02
    6ef0:	0f c0       	rjmp	.+30     	; 0x6f10 <GLCD_senddata+0x33e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6ef2:	69 89       	ldd	r22, Y+17	; 0x11
    6ef4:	7a 89       	ldd	r23, Y+18	; 0x12
    6ef6:	8b 89       	ldd	r24, Y+19	; 0x13
    6ef8:	9c 89       	ldd	r25, Y+20	; 0x14
    6efa:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    6efe:	dc 01       	movw	r26, r24
    6f00:	cb 01       	movw	r24, r22
    6f02:	88 8b       	std	Y+16, r24	; 0x10
    6f04:	88 89       	ldd	r24, Y+16	; 0x10
    6f06:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6f08:	89 81       	ldd	r24, Y+1	; 0x01
    6f0a:	8a 95       	dec	r24
    6f0c:	f1 f7       	brne	.-4      	; 0x6f0a <GLCD_senddata+0x338>
    6f0e:	89 83       	std	Y+1, r24	; 0x01
			_delay_us(5);

}
    6f10:	e1 96       	adiw	r28, 0x31	; 49
    6f12:	0f b6       	in	r0, 0x3f	; 63
    6f14:	f8 94       	cli
    6f16:	de bf       	out	0x3e, r29	; 62
    6f18:	0f be       	out	0x3f, r0	; 63
    6f1a:	cd bf       	out	0x3d, r28	; 61
    6f1c:	cf 91       	pop	r28
    6f1e:	df 91       	pop	r29
    6f20:	08 95       	ret

00006f22 <GLCD_DisplaySpecialPattern>:


void GLCD_DisplaySpecialPattern(uint64 Pattern)
{
    6f22:	af 92       	push	r10
    6f24:	bf 92       	push	r11
    6f26:	cf 92       	push	r12
    6f28:	df 92       	push	r13
    6f2a:	ef 92       	push	r14
    6f2c:	ff 92       	push	r15
    6f2e:	0f 93       	push	r16
    6f30:	1f 93       	push	r17
    6f32:	df 93       	push	r29
    6f34:	cf 93       	push	r28
    6f36:	cd b7       	in	r28, 0x3d	; 61
    6f38:	de b7       	in	r29, 0x3e	; 62
    6f3a:	29 97       	sbiw	r28, 0x09	; 9
    6f3c:	0f b6       	in	r0, 0x3f	; 63
    6f3e:	f8 94       	cli
    6f40:	de bf       	out	0x3e, r29	; 62
    6f42:	0f be       	out	0x3f, r0	; 63
    6f44:	cd bf       	out	0x3d, r28	; 61
    6f46:	2a 83       	std	Y+2, r18	; 0x02
    6f48:	3b 83       	std	Y+3, r19	; 0x03
    6f4a:	4c 83       	std	Y+4, r20	; 0x04
    6f4c:	5d 83       	std	Y+5, r21	; 0x05
    6f4e:	6e 83       	std	Y+6, r22	; 0x06
    6f50:	7f 83       	std	Y+7, r23	; 0x07
    6f52:	88 87       	std	Y+8, r24	; 0x08
    6f54:	99 87       	std	Y+9, r25	; 0x09

	for(uint8 i = 0; i < 5; i++) {
    6f56:	19 82       	std	Y+1, r1	; 0x01
    6f58:	47 c0       	rjmp	.+142    	; 0x6fe8 <GLCD_DisplaySpecialPattern+0xc6>
		GLCD_sendcommand(GLCD_SET_X_ADDRESS_PREFIX + gu8_Curr_X_Address);
    6f5a:	80 91 a7 15 	lds	r24, 0x15A7
    6f5e:	88 54       	subi	r24, 0x48	; 72
    6f60:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>
		GLCD_sendcommand(GLCD_SET_Y_ADDRESS_PREFIX + gu8_Curr_Y_Address);
    6f64:	80 91 a8 15 	lds	r24, 0x15A8
    6f68:	80 5c       	subi	r24, 0xC0	; 192
    6f6a:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>
		GLCD_senddata((Pattern>>(i*8U)) & 0x00000000FFUL);
    6f6e:	89 81       	ldd	r24, Y+1	; 0x01
    6f70:	88 2f       	mov	r24, r24
    6f72:	90 e0       	ldi	r25, 0x00	; 0
    6f74:	88 0f       	add	r24, r24
    6f76:	99 1f       	adc	r25, r25
    6f78:	88 0f       	add	r24, r24
    6f7a:	99 1f       	adc	r25, r25
    6f7c:	88 0f       	add	r24, r24
    6f7e:	99 1f       	adc	r25, r25
    6f80:	fc 01       	movw	r30, r24
    6f82:	2a 81       	ldd	r18, Y+2	; 0x02
    6f84:	3b 81       	ldd	r19, Y+3	; 0x03
    6f86:	4c 81       	ldd	r20, Y+4	; 0x04
    6f88:	5d 81       	ldd	r21, Y+5	; 0x05
    6f8a:	6e 81       	ldd	r22, Y+6	; 0x06
    6f8c:	7f 81       	ldd	r23, Y+7	; 0x07
    6f8e:	88 85       	ldd	r24, Y+8	; 0x08
    6f90:	99 85       	ldd	r25, Y+9	; 0x09
    6f92:	0e 2f       	mov	r16, r30
    6f94:	0e 94 91 00 	call	0x122	; 0x122 <__lshrdi3>
    6f98:	a2 2e       	mov	r10, r18
    6f9a:	b3 2e       	mov	r11, r19
    6f9c:	c4 2e       	mov	r12, r20
    6f9e:	d5 2e       	mov	r13, r21
    6fa0:	e6 2e       	mov	r14, r22
    6fa2:	f7 2e       	mov	r15, r23
    6fa4:	08 2f       	mov	r16, r24
    6fa6:	19 2f       	mov	r17, r25
    6fa8:	2a 2d       	mov	r18, r10
    6faa:	3b 2d       	mov	r19, r11
    6fac:	4c 2d       	mov	r20, r12
    6fae:	5d 2d       	mov	r21, r13
    6fb0:	6e 2d       	mov	r22, r14
    6fb2:	7f 2d       	mov	r23, r15
    6fb4:	80 2f       	mov	r24, r16
    6fb6:	91 2f       	mov	r25, r17
    6fb8:	82 2f       	mov	r24, r18
    6fba:	0e 94 e9 35 	call	0x6bd2	; 0x6bd2 <GLCD_senddata>
		gu8_Curr_Y_Address++;
    6fbe:	80 91 a8 15 	lds	r24, 0x15A8
    6fc2:	8f 5f       	subi	r24, 0xFF	; 255
    6fc4:	80 93 a8 15 	sts	0x15A8, r24
		if (gu8_Curr_Y_Address >= 64 && gu8_Curr_Page == 0) {
    6fc8:	80 91 a8 15 	lds	r24, 0x15A8
    6fcc:	80 34       	cpi	r24, 0x40	; 64
    6fce:	48 f0       	brcs	.+18     	; 0x6fe2 <GLCD_DisplaySpecialPattern+0xc0>
    6fd0:	80 91 a9 15 	lds	r24, 0x15A9
    6fd4:	88 23       	and	r24, r24
    6fd6:	29 f4       	brne	.+10     	; 0x6fe2 <GLCD_DisplaySpecialPattern+0xc0>
			 GLCD_select_page(2);
    6fd8:	82 e0       	ldi	r24, 0x02	; 2
    6fda:	0e 94 09 38 	call	0x7012	; 0x7012 <GLCD_select_page>
			gu8_Curr_Y_Address = 0;
    6fde:	10 92 a8 15 	sts	0x15A8, r1


void GLCD_DisplaySpecialPattern(uint64 Pattern)
{

	for(uint8 i = 0; i < 5; i++) {
    6fe2:	89 81       	ldd	r24, Y+1	; 0x01
    6fe4:	8f 5f       	subi	r24, 0xFF	; 255
    6fe6:	89 83       	std	Y+1, r24	; 0x01
    6fe8:	89 81       	ldd	r24, Y+1	; 0x01
    6fea:	85 30       	cpi	r24, 0x05	; 5
    6fec:	08 f4       	brcc	.+2      	; 0x6ff0 <GLCD_DisplaySpecialPattern+0xce>
    6fee:	b5 cf       	rjmp	.-150    	; 0x6f5a <GLCD_DisplaySpecialPattern+0x38>
		if (gu8_Curr_Y_Address >= 64 && gu8_Curr_Page == 0) {
			 GLCD_select_page(2);
			gu8_Curr_Y_Address = 0;
		}
	}
}
    6ff0:	29 96       	adiw	r28, 0x09	; 9
    6ff2:	0f b6       	in	r0, 0x3f	; 63
    6ff4:	f8 94       	cli
    6ff6:	de bf       	out	0x3e, r29	; 62
    6ff8:	0f be       	out	0x3f, r0	; 63
    6ffa:	cd bf       	out	0x3d, r28	; 61
    6ffc:	cf 91       	pop	r28
    6ffe:	df 91       	pop	r29
    7000:	1f 91       	pop	r17
    7002:	0f 91       	pop	r16
    7004:	ff 90       	pop	r15
    7006:	ef 90       	pop	r14
    7008:	df 90       	pop	r13
    700a:	cf 90       	pop	r12
    700c:	bf 90       	pop	r11
    700e:	af 90       	pop	r10
    7010:	08 95       	ret

00007012 <GLCD_select_page>:

void GLCD_select_page(uint8 page){
    7012:	df 93       	push	r29
    7014:	cf 93       	push	r28
    7016:	00 d0       	rcall	.+0      	; 0x7018 <GLCD_select_page+0x6>
    7018:	0f 92       	push	r0
    701a:	cd b7       	in	r28, 0x3d	; 61
    701c:	de b7       	in	r29, 0x3e	; 62
    701e:	89 83       	std	Y+1, r24	; 0x01

	switch(page){
    7020:	89 81       	ldd	r24, Y+1	; 0x01
    7022:	28 2f       	mov	r18, r24
    7024:	30 e0       	ldi	r19, 0x00	; 0
    7026:	3b 83       	std	Y+3, r19	; 0x03
    7028:	2a 83       	std	Y+2, r18	; 0x02
    702a:	8a 81       	ldd	r24, Y+2	; 0x02
    702c:	9b 81       	ldd	r25, Y+3	; 0x03
    702e:	81 30       	cpi	r24, 0x01	; 1
    7030:	91 05       	cpc	r25, r1
    7032:	01 f1       	breq	.+64     	; 0x7074 <GLCD_select_page+0x62>
    7034:	2a 81       	ldd	r18, Y+2	; 0x02
    7036:	3b 81       	ldd	r19, Y+3	; 0x03
    7038:	22 30       	cpi	r18, 0x02	; 2
    703a:	31 05       	cpc	r19, r1
    703c:	2c f4       	brge	.+10     	; 0x7048 <GLCD_select_page+0x36>
    703e:	8a 81       	ldd	r24, Y+2	; 0x02
    7040:	9b 81       	ldd	r25, Y+3	; 0x03
    7042:	00 97       	sbiw	r24, 0x00	; 0
    7044:	61 f0       	breq	.+24     	; 0x705e <GLCD_select_page+0x4c>
    7046:	36 c0       	rjmp	.+108    	; 0x70b4 <GLCD_select_page+0xa2>
    7048:	2a 81       	ldd	r18, Y+2	; 0x02
    704a:	3b 81       	ldd	r19, Y+3	; 0x03
    704c:	22 30       	cpi	r18, 0x02	; 2
    704e:	31 05       	cpc	r19, r1
    7050:	e1 f0       	breq	.+56     	; 0x708a <GLCD_select_page+0x78>
    7052:	8a 81       	ldd	r24, Y+2	; 0x02
    7054:	9b 81       	ldd	r25, Y+3	; 0x03
    7056:	83 30       	cpi	r24, 0x03	; 3
    7058:	91 05       	cpc	r25, r1
    705a:	11 f1       	breq	.+68     	; 0x70a0 <GLCD_select_page+0x8e>
    705c:	2b c0       	rjmp	.+86     	; 0x70b4 <GLCD_select_page+0xa2>

	case 0:
		 GPIO_writePin(GLCD_CS1_PORT_ID,GLCD_CS1_PIN_ID , LOGIC_LOW);
    705e:	81 e0       	ldi	r24, 0x01	; 1
    7060:	64 e0       	ldi	r22, 0x04	; 4
    7062:	40 e0       	ldi	r20, 0x00	; 0
    7064:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
		    GPIO_writePin(GLCD_CS2_PORT_ID,GLCD_CS2_PIN_ID , LOGIC_LOW);
    7068:	81 e0       	ldi	r24, 0x01	; 1
    706a:	65 e0       	ldi	r22, 0x05	; 5
    706c:	40 e0       	ldi	r20, 0x00	; 0
    706e:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
    7072:	20 c0       	rjmp	.+64     	; 0x70b4 <GLCD_select_page+0xa2>
		break;

	case 1:
		 GPIO_writePin(GLCD_CS1_PORT_ID,GLCD_CS1_PIN_ID , LOGIC_HIGH);
    7074:	81 e0       	ldi	r24, 0x01	; 1
    7076:	64 e0       	ldi	r22, 0x04	; 4
    7078:	41 e0       	ldi	r20, 0x01	; 1
    707a:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
		    GPIO_writePin(GLCD_CS2_PORT_ID,GLCD_CS2_PIN_ID , LOGIC_LOW);
    707e:	81 e0       	ldi	r24, 0x01	; 1
    7080:	65 e0       	ldi	r22, 0x05	; 5
    7082:	40 e0       	ldi	r20, 0x00	; 0
    7084:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
    7088:	15 c0       	rjmp	.+42     	; 0x70b4 <GLCD_select_page+0xa2>
			break;
	case 2:
		 GPIO_writePin(GLCD_CS1_PORT_ID,GLCD_CS1_PIN_ID , LOGIC_LOW);
    708a:	81 e0       	ldi	r24, 0x01	; 1
    708c:	64 e0       	ldi	r22, 0x04	; 4
    708e:	40 e0       	ldi	r20, 0x00	; 0
    7090:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
		    GPIO_writePin(GLCD_CS2_PORT_ID,GLCD_CS2_PIN_ID , LOGIC_HIGH);
    7094:	81 e0       	ldi	r24, 0x01	; 1
    7096:	65 e0       	ldi	r22, 0x05	; 5
    7098:	41 e0       	ldi	r20, 0x01	; 1
    709a:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
    709e:	0a c0       	rjmp	.+20     	; 0x70b4 <GLCD_select_page+0xa2>
			break;
	case 3:
		 GPIO_writePin(GLCD_CS1_PORT_ID,GLCD_CS1_PIN_ID , LOGIC_HIGH);
    70a0:	81 e0       	ldi	r24, 0x01	; 1
    70a2:	64 e0       	ldi	r22, 0x04	; 4
    70a4:	41 e0       	ldi	r20, 0x01	; 1
    70a6:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
		   GPIO_writePin(GLCD_CS2_PORT_ID,GLCD_CS2_PIN_ID , LOGIC_HIGH);
    70aa:	81 e0       	ldi	r24, 0x01	; 1
    70ac:	65 e0       	ldi	r22, 0x05	; 5
    70ae:	41 e0       	ldi	r20, 0x01	; 1
    70b0:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
			break;
	}

}
    70b4:	0f 90       	pop	r0
    70b6:	0f 90       	pop	r0
    70b8:	0f 90       	pop	r0
    70ba:	cf 91       	pop	r28
    70bc:	df 91       	pop	r29
    70be:	08 95       	ret

000070c0 <GLCD_String>:

void GLCD_String(char line_no,char page, char *str)/* GLCD string write function */
{
    70c0:	0f 93       	push	r16
    70c2:	1f 93       	push	r17
    70c4:	df 93       	push	r29
    70c6:	cf 93       	push	r28
    70c8:	cd b7       	in	r28, 0x3d	; 61
    70ca:	de b7       	in	r29, 0x3e	; 62
    70cc:	60 97       	sbiw	r28, 0x10	; 16
    70ce:	0f b6       	in	r0, 0x3f	; 63
    70d0:	f8 94       	cli
    70d2:	de bf       	out	0x3e, r29	; 62
    70d4:	0f be       	out	0x3f, r0	; 63
    70d6:	cd bf       	out	0x3d, r28	; 61
    70d8:	8d 87       	std	Y+13, r24	; 0x0d
    70da:	6e 87       	std	Y+14, r22	; 0x0e
    70dc:	58 8b       	std	Y+16, r21	; 0x10
    70de:	4f 87       	std	Y+15, r20	; 0x0f
	unsigned int i, column;
	unsigned int Page = ((0xB8) + line_no);
    70e0:	8d 85       	ldd	r24, Y+13	; 0x0d
    70e2:	88 2f       	mov	r24, r24
    70e4:	90 e0       	ldi	r25, 0x00	; 0
    70e6:	88 54       	subi	r24, 0x48	; 72
    70e8:	9f 4f       	sbci	r25, 0xFF	; 255
    70ea:	98 87       	std	Y+8, r25	; 0x08
    70ec:	8f 83       	std	Y+7, r24	; 0x07
	unsigned int Y_address = 0;
    70ee:	1e 82       	std	Y+6, r1	; 0x06
    70f0:	1d 82       	std	Y+5, r1	; 0x05
	float Page_inc = 0.5;
    70f2:	80 e0       	ldi	r24, 0x00	; 0
    70f4:	90 e0       	ldi	r25, 0x00	; 0
    70f6:	a0 e0       	ldi	r26, 0x00	; 0
    70f8:	bf e3       	ldi	r27, 0x3F	; 63
    70fa:	89 83       	std	Y+1, r24	; 0x01
    70fc:	9a 83       	std	Y+2, r25	; 0x02
    70fe:	ab 83       	std	Y+3, r26	; 0x03
    7100:	bc 83       	std	Y+4, r27	; 0x04
GLCD_select_page(page);
    7102:	8e 85       	ldd	r24, Y+14	; 0x0e
    7104:	0e 94 09 38 	call	0x7012	; 0x7012 <GLCD_select_page>
	GLCD_sendcommand(Page);
    7108:	8f 81       	ldd	r24, Y+7	; 0x07
    710a:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>
	for(i = 0; str[i] != 0; i++)	/* Print char in string till null */
    710e:	1c 86       	std	Y+12, r1	; 0x0c
    7110:	1b 86       	std	Y+11, r1	; 0x0b
    7112:	f6 c1       	rjmp	.+1004   	; 0x7500 <GLCD_String+0x440>
		{
		if (Y_address > (1024-(((line_no)*128)+FontWidth)))
    7114:	8d 85       	ldd	r24, Y+13	; 0x0d
    7116:	88 2f       	mov	r24, r24
    7118:	90 e0       	ldi	r25, 0x00	; 0
    711a:	96 95       	lsr	r25
    711c:	98 2f       	mov	r25, r24
    711e:	88 27       	eor	r24, r24
    7120:	97 95       	ror	r25
    7122:	87 95       	ror	r24
    7124:	90 95       	com	r25
    7126:	81 95       	neg	r24
    7128:	9f 4f       	sbci	r25, 0xFF	; 255
    712a:	85 50       	subi	r24, 0x05	; 5
    712c:	9c 4f       	sbci	r25, 0xFC	; 252
    712e:	9c 01       	movw	r18, r24
    7130:	8d 81       	ldd	r24, Y+5	; 0x05
    7132:	9e 81       	ldd	r25, Y+6	; 0x06
    7134:	28 17       	cp	r18, r24
    7136:	39 07       	cpc	r19, r25
    7138:	08 f4       	brcc	.+2      	; 0x713c <GLCD_String+0x7c>
    713a:	ed c1       	rjmp	.+986    	; 0x7516 <GLCD_String+0x456>
		break;
		if (str[i]!=32)
    713c:	2f 85       	ldd	r18, Y+15	; 0x0f
    713e:	38 89       	ldd	r19, Y+16	; 0x10
    7140:	8b 85       	ldd	r24, Y+11	; 0x0b
    7142:	9c 85       	ldd	r25, Y+12	; 0x0c
    7144:	f9 01       	movw	r30, r18
    7146:	e8 0f       	add	r30, r24
    7148:	f9 1f       	adc	r31, r25
    714a:	80 81       	ld	r24, Z
    714c:	80 32       	cpi	r24, 0x20	; 32
    714e:	09 f4       	brne	.+2      	; 0x7152 <GLCD_String+0x92>
    7150:	78 c0       	rjmp	.+240    	; 0x7242 <GLCD_String+0x182>
		{
			for (column=1; column<=FontWidth; column++)
    7152:	81 e0       	ldi	r24, 0x01	; 1
    7154:	90 e0       	ldi	r25, 0x00	; 0
    7156:	9a 87       	std	Y+10, r25	; 0x0a
    7158:	89 87       	std	Y+9, r24	; 0x09
    715a:	6d c0       	rjmp	.+218    	; 0x7236 <GLCD_String+0x176>
			{
				if ((Y_address+column)==(128*((int)(Page_inc+0.5))))
    715c:	2d 81       	ldd	r18, Y+5	; 0x05
    715e:	3e 81       	ldd	r19, Y+6	; 0x06
    7160:	89 85       	ldd	r24, Y+9	; 0x09
    7162:	9a 85       	ldd	r25, Y+10	; 0x0a
    7164:	89 01       	movw	r16, r18
    7166:	08 0f       	add	r16, r24
    7168:	19 1f       	adc	r17, r25
    716a:	69 81       	ldd	r22, Y+1	; 0x01
    716c:	7a 81       	ldd	r23, Y+2	; 0x02
    716e:	8b 81       	ldd	r24, Y+3	; 0x03
    7170:	9c 81       	ldd	r25, Y+4	; 0x04
    7172:	20 e0       	ldi	r18, 0x00	; 0
    7174:	30 e0       	ldi	r19, 0x00	; 0
    7176:	40 e0       	ldi	r20, 0x00	; 0
    7178:	5f e3       	ldi	r21, 0x3F	; 63
    717a:	0e 94 b9 02 	call	0x572	; 0x572 <__addsf3>
    717e:	dc 01       	movw	r26, r24
    7180:	cb 01       	movw	r24, r22
    7182:	bc 01       	movw	r22, r24
    7184:	cd 01       	movw	r24, r26
    7186:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <__fixsfsi>
    718a:	dc 01       	movw	r26, r24
    718c:	cb 01       	movw	r24, r22
    718e:	96 95       	lsr	r25
    7190:	98 2f       	mov	r25, r24
    7192:	88 27       	eor	r24, r24
    7194:	97 95       	ror	r25
    7196:	87 95       	ror	r24
    7198:	08 17       	cp	r16, r24
    719a:	19 07       	cpc	r17, r25
    719c:	09 f0       	breq	.+2      	; 0x71a0 <GLCD_String+0xe0>
    719e:	46 c0       	rjmp	.+140    	; 0x722c <GLCD_String+0x16c>
				{
					if (column == FontWidth)
    71a0:	89 85       	ldd	r24, Y+9	; 0x09
    71a2:	9a 85       	ldd	r25, Y+10	; 0x0a
    71a4:	85 30       	cpi	r24, 0x05	; 5
    71a6:	91 05       	cpc	r25, r1
    71a8:	09 f4       	brne	.+2      	; 0x71ac <GLCD_String+0xec>
    71aa:	4b c0       	rjmp	.+150    	; 0x7242 <GLCD_String+0x182>
					break;
					GLCD_sendcommand(0x40);
    71ac:	80 e4       	ldi	r24, 0x40	; 64
    71ae:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>
					Y_address = Y_address + column;
    71b2:	2d 81       	ldd	r18, Y+5	; 0x05
    71b4:	3e 81       	ldd	r19, Y+6	; 0x06
    71b6:	89 85       	ldd	r24, Y+9	; 0x09
    71b8:	9a 85       	ldd	r25, Y+10	; 0x0a
    71ba:	82 0f       	add	r24, r18
    71bc:	93 1f       	adc	r25, r19
    71be:	9e 83       	std	Y+6, r25	; 0x06
    71c0:	8d 83       	std	Y+5, r24	; 0x05
					GPIO_togglePin(GLCD_CS1_PORT_ID, GLCD_CS1_PIN_ID);
    71c2:	81 e0       	ldi	r24, 0x01	; 1
    71c4:	64 e0       	ldi	r22, 0x04	; 4
    71c6:	0e 94 b0 30 	call	0x6160	; 0x6160 <GPIO_togglePin>
					GPIO_togglePin(GLCD_CS2_PORT_ID, GLCD_CS2_PIN_ID);
    71ca:	81 e0       	ldi	r24, 0x01	; 1
    71cc:	65 e0       	ldi	r22, 0x05	; 5
    71ce:	0e 94 b0 30 	call	0x6160	; 0x6160 <GPIO_togglePin>


					GLCD_sendcommand(Page + Page_inc);
    71d2:	8f 81       	ldd	r24, Y+7	; 0x07
    71d4:	98 85       	ldd	r25, Y+8	; 0x08
    71d6:	cc 01       	movw	r24, r24
    71d8:	a0 e0       	ldi	r26, 0x00	; 0
    71da:	b0 e0       	ldi	r27, 0x00	; 0
    71dc:	bc 01       	movw	r22, r24
    71de:	cd 01       	movw	r24, r26
    71e0:	0e 94 ce 05 	call	0xb9c	; 0xb9c <__floatunsisf>
    71e4:	dc 01       	movw	r26, r24
    71e6:	cb 01       	movw	r24, r22
    71e8:	bc 01       	movw	r22, r24
    71ea:	cd 01       	movw	r24, r26
    71ec:	29 81       	ldd	r18, Y+1	; 0x01
    71ee:	3a 81       	ldd	r19, Y+2	; 0x02
    71f0:	4b 81       	ldd	r20, Y+3	; 0x03
    71f2:	5c 81       	ldd	r21, Y+4	; 0x04
    71f4:	0e 94 b9 02 	call	0x572	; 0x572 <__addsf3>
    71f8:	dc 01       	movw	r26, r24
    71fa:	cb 01       	movw	r24, r22
    71fc:	bc 01       	movw	r22, r24
    71fe:	cd 01       	movw	r24, r26
    7200:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    7204:	dc 01       	movw	r26, r24
    7206:	cb 01       	movw	r24, r22
    7208:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>
					Page_inc = Page_inc + 0.5;
    720c:	69 81       	ldd	r22, Y+1	; 0x01
    720e:	7a 81       	ldd	r23, Y+2	; 0x02
    7210:	8b 81       	ldd	r24, Y+3	; 0x03
    7212:	9c 81       	ldd	r25, Y+4	; 0x04
    7214:	20 e0       	ldi	r18, 0x00	; 0
    7216:	30 e0       	ldi	r19, 0x00	; 0
    7218:	40 e0       	ldi	r20, 0x00	; 0
    721a:	5f e3       	ldi	r21, 0x3F	; 63
    721c:	0e 94 b9 02 	call	0x572	; 0x572 <__addsf3>
    7220:	dc 01       	movw	r26, r24
    7222:	cb 01       	movw	r24, r22
    7224:	89 83       	std	Y+1, r24	; 0x01
    7226:	9a 83       	std	Y+2, r25	; 0x02
    7228:	ab 83       	std	Y+3, r26	; 0x03
    722a:	bc 83       	std	Y+4, r27	; 0x04
		{
		if (Y_address > (1024-(((line_no)*128)+FontWidth)))
		break;
		if (str[i]!=32)
		{
			for (column=1; column<=FontWidth; column++)
    722c:	89 85       	ldd	r24, Y+9	; 0x09
    722e:	9a 85       	ldd	r25, Y+10	; 0x0a
    7230:	01 96       	adiw	r24, 0x01	; 1
    7232:	9a 87       	std	Y+10, r25	; 0x0a
    7234:	89 87       	std	Y+9, r24	; 0x09
    7236:	89 85       	ldd	r24, Y+9	; 0x09
    7238:	9a 85       	ldd	r25, Y+10	; 0x0a
    723a:	86 30       	cpi	r24, 0x06	; 6
    723c:	91 05       	cpc	r25, r1
    723e:	08 f4       	brcc	.+2      	; 0x7242 <GLCD_String+0x182>
    7240:	8d cf       	rjmp	.-230    	; 0x715c <GLCD_String+0x9c>
					GLCD_sendcommand(Page + Page_inc);
					Page_inc = Page_inc + 0.5;
				}
			}
		}
		if (Y_address>(1024-(((line_no)*128)+FontWidth)))
    7242:	8d 85       	ldd	r24, Y+13	; 0x0d
    7244:	88 2f       	mov	r24, r24
    7246:	90 e0       	ldi	r25, 0x00	; 0
    7248:	96 95       	lsr	r25
    724a:	98 2f       	mov	r25, r24
    724c:	88 27       	eor	r24, r24
    724e:	97 95       	ror	r25
    7250:	87 95       	ror	r24
    7252:	90 95       	com	r25
    7254:	81 95       	neg	r24
    7256:	9f 4f       	sbci	r25, 0xFF	; 255
    7258:	85 50       	subi	r24, 0x05	; 5
    725a:	9c 4f       	sbci	r25, 0xFC	; 252
    725c:	9c 01       	movw	r18, r24
    725e:	8d 81       	ldd	r24, Y+5	; 0x05
    7260:	9e 81       	ldd	r25, Y+6	; 0x06
    7262:	28 17       	cp	r18, r24
    7264:	39 07       	cpc	r19, r25
    7266:	08 f4       	brcc	.+2      	; 0x726a <GLCD_String+0x1aa>
    7268:	56 c1       	rjmp	.+684    	; 0x7516 <GLCD_String+0x456>
		break;
		if((font[((str[i]-32)*FontWidth)+4])==0 || str[i]==32)
    726a:	2f 85       	ldd	r18, Y+15	; 0x0f
    726c:	38 89       	ldd	r19, Y+16	; 0x10
    726e:	8b 85       	ldd	r24, Y+11	; 0x0b
    7270:	9c 85       	ldd	r25, Y+12	; 0x0c
    7272:	f9 01       	movw	r30, r18
    7274:	e8 0f       	add	r30, r24
    7276:	f9 1f       	adc	r31, r25
    7278:	80 81       	ld	r24, Z
    727a:	28 2f       	mov	r18, r24
    727c:	30 e0       	ldi	r19, 0x00	; 0
    727e:	c9 01       	movw	r24, r18
    7280:	88 0f       	add	r24, r24
    7282:	99 1f       	adc	r25, r25
    7284:	82 0f       	add	r24, r18
    7286:	93 1f       	adc	r25, r19
    7288:	88 0f       	add	r24, r24
    728a:	99 1f       	adc	r25, r25
    728c:	88 0f       	add	r24, r24
    728e:	99 1f       	adc	r25, r25
    7290:	88 0f       	add	r24, r24
    7292:	99 1f       	adc	r25, r25
    7294:	82 0f       	add	r24, r18
    7296:	93 1f       	adc	r25, r19
    7298:	8c 50       	subi	r24, 0x0C	; 12
    729a:	93 40       	sbci	r25, 0x03	; 3
    729c:	85 5b       	subi	r24, 0xB5	; 181
    729e:	9c 4f       	sbci	r25, 0xFC	; 252
    72a0:	00 97       	sbiw	r24, 0x00	; 0
    72a2:	59 f0       	breq	.+22     	; 0x72ba <GLCD_String+0x1fa>
    72a4:	2f 85       	ldd	r18, Y+15	; 0x0f
    72a6:	38 89       	ldd	r19, Y+16	; 0x10
    72a8:	8b 85       	ldd	r24, Y+11	; 0x0b
    72aa:	9c 85       	ldd	r25, Y+12	; 0x0c
    72ac:	f9 01       	movw	r30, r18
    72ae:	e8 0f       	add	r30, r24
    72b0:	f9 1f       	adc	r31, r25
    72b2:	80 81       	ld	r24, Z
    72b4:	80 32       	cpi	r24, 0x20	; 32
    72b6:	09 f0       	breq	.+2      	; 0x72ba <GLCD_String+0x1fa>
    72b8:	6e c0       	rjmp	.+220    	; 0x7396 <GLCD_String+0x2d6>
		{
			for(column=0; column<FontWidth; column++)
    72ba:	1a 86       	std	Y+10, r1	; 0x0a
    72bc:	19 86       	std	Y+9, r1	; 0x09
    72be:	64 c0       	rjmp	.+200    	; 0x7388 <GLCD_String+0x2c8>
			{
				GLCD_senddata(font[str[i]-32][column]);
    72c0:	2f 85       	ldd	r18, Y+15	; 0x0f
    72c2:	38 89       	ldd	r19, Y+16	; 0x10
    72c4:	8b 85       	ldd	r24, Y+11	; 0x0b
    72c6:	9c 85       	ldd	r25, Y+12	; 0x0c
    72c8:	f9 01       	movw	r30, r18
    72ca:	e8 0f       	add	r30, r24
    72cc:	f9 1f       	adc	r31, r25
    72ce:	80 81       	ld	r24, Z
    72d0:	88 2f       	mov	r24, r24
    72d2:	90 e0       	ldi	r25, 0x00	; 0
    72d4:	9c 01       	movw	r18, r24
    72d6:	20 52       	subi	r18, 0x20	; 32
    72d8:	30 40       	sbci	r19, 0x00	; 0
    72da:	49 85       	ldd	r20, Y+9	; 0x09
    72dc:	5a 85       	ldd	r21, Y+10	; 0x0a
    72de:	c9 01       	movw	r24, r18
    72e0:	88 0f       	add	r24, r24
    72e2:	99 1f       	adc	r25, r25
    72e4:	88 0f       	add	r24, r24
    72e6:	99 1f       	adc	r25, r25
    72e8:	82 0f       	add	r24, r18
    72ea:	93 1f       	adc	r25, r19
    72ec:	84 0f       	add	r24, r20
    72ee:	95 1f       	adc	r25, r21
    72f0:	fc 01       	movw	r30, r24
    72f2:	e5 5b       	subi	r30, 0xB5	; 181
    72f4:	fc 4f       	sbci	r31, 0xFC	; 252
    72f6:	80 81       	ld	r24, Z
    72f8:	0e 94 e9 35 	call	0x6bd2	; 0x6bd2 <GLCD_senddata>
				if((Y_address+1)%64==0)
    72fc:	8d 81       	ldd	r24, Y+5	; 0x05
    72fe:	9e 81       	ldd	r25, Y+6	; 0x06
    7300:	01 96       	adiw	r24, 0x01	; 1
    7302:	8f 73       	andi	r24, 0x3F	; 63
    7304:	90 70       	andi	r25, 0x00	; 0
    7306:	00 97       	sbiw	r24, 0x00	; 0
    7308:	a9 f5       	brne	.+106    	; 0x7374 <GLCD_String+0x2b4>
				{
					GPIO_togglePin(GLCD_CS1_PORT_ID, GLCD_CS1_PIN_ID);
    730a:	81 e0       	ldi	r24, 0x01	; 1
    730c:	64 e0       	ldi	r22, 0x04	; 4
    730e:	0e 94 b0 30 	call	0x6160	; 0x6160 <GPIO_togglePin>
					GPIO_togglePin(GLCD_CS2_PORT_ID, GLCD_CS2_PIN_ID);
    7312:	81 e0       	ldi	r24, 0x01	; 1
    7314:	65 e0       	ldi	r22, 0x05	; 5
    7316:	0e 94 b0 30 	call	0x6160	; 0x6160 <GPIO_togglePin>
					GLCD_sendcommand((Page+Page_inc));
    731a:	8f 81       	ldd	r24, Y+7	; 0x07
    731c:	98 85       	ldd	r25, Y+8	; 0x08
    731e:	cc 01       	movw	r24, r24
    7320:	a0 e0       	ldi	r26, 0x00	; 0
    7322:	b0 e0       	ldi	r27, 0x00	; 0
    7324:	bc 01       	movw	r22, r24
    7326:	cd 01       	movw	r24, r26
    7328:	0e 94 ce 05 	call	0xb9c	; 0xb9c <__floatunsisf>
    732c:	dc 01       	movw	r26, r24
    732e:	cb 01       	movw	r24, r22
    7330:	bc 01       	movw	r22, r24
    7332:	cd 01       	movw	r24, r26
    7334:	29 81       	ldd	r18, Y+1	; 0x01
    7336:	3a 81       	ldd	r19, Y+2	; 0x02
    7338:	4b 81       	ldd	r20, Y+3	; 0x03
    733a:	5c 81       	ldd	r21, Y+4	; 0x04
    733c:	0e 94 b9 02 	call	0x572	; 0x572 <__addsf3>
    7340:	dc 01       	movw	r26, r24
    7342:	cb 01       	movw	r24, r22
    7344:	bc 01       	movw	r22, r24
    7346:	cd 01       	movw	r24, r26
    7348:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    734c:	dc 01       	movw	r26, r24
    734e:	cb 01       	movw	r24, r22
    7350:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>
					Page_inc = Page_inc + 0.5;
    7354:	69 81       	ldd	r22, Y+1	; 0x01
    7356:	7a 81       	ldd	r23, Y+2	; 0x02
    7358:	8b 81       	ldd	r24, Y+3	; 0x03
    735a:	9c 81       	ldd	r25, Y+4	; 0x04
    735c:	20 e0       	ldi	r18, 0x00	; 0
    735e:	30 e0       	ldi	r19, 0x00	; 0
    7360:	40 e0       	ldi	r20, 0x00	; 0
    7362:	5f e3       	ldi	r21, 0x3F	; 63
    7364:	0e 94 b9 02 	call	0x572	; 0x572 <__addsf3>
    7368:	dc 01       	movw	r26, r24
    736a:	cb 01       	movw	r24, r22
    736c:	89 83       	std	Y+1, r24	; 0x01
    736e:	9a 83       	std	Y+2, r25	; 0x02
    7370:	ab 83       	std	Y+3, r26	; 0x03
    7372:	bc 83       	std	Y+4, r27	; 0x04
				}
				Y_address++;
    7374:	8d 81       	ldd	r24, Y+5	; 0x05
    7376:	9e 81       	ldd	r25, Y+6	; 0x06
    7378:	01 96       	adiw	r24, 0x01	; 1
    737a:	9e 83       	std	Y+6, r25	; 0x06
    737c:	8d 83       	std	Y+5, r24	; 0x05
		}
		if (Y_address>(1024-(((line_no)*128)+FontWidth)))
		break;
		if((font[((str[i]-32)*FontWidth)+4])==0 || str[i]==32)
		{
			for(column=0; column<FontWidth; column++)
    737e:	89 85       	ldd	r24, Y+9	; 0x09
    7380:	9a 85       	ldd	r25, Y+10	; 0x0a
    7382:	01 96       	adiw	r24, 0x01	; 1
    7384:	9a 87       	std	Y+10, r25	; 0x0a
    7386:	89 87       	std	Y+9, r24	; 0x09
    7388:	89 85       	ldd	r24, Y+9	; 0x09
    738a:	9a 85       	ldd	r25, Y+10	; 0x0a
    738c:	85 30       	cpi	r24, 0x05	; 5
    738e:	91 05       	cpc	r25, r1
    7390:	08 f4       	brcc	.+2      	; 0x7394 <GLCD_String+0x2d4>
    7392:	96 cf       	rjmp	.-212    	; 0x72c0 <GLCD_String+0x200>
    7394:	b0 c0       	rjmp	.+352    	; 0x74f6 <GLCD_String+0x436>
				Y_address++;
			}
		}
		else
		{
			for(column=0; column<FontWidth; column++)
    7396:	1a 86       	std	Y+10, r1	; 0x0a
    7398:	19 86       	std	Y+9, r1	; 0x09
    739a:	64 c0       	rjmp	.+200    	; 0x7464 <GLCD_String+0x3a4>
			{
				GLCD_senddata(font[str[i]-32][column]);
    739c:	2f 85       	ldd	r18, Y+15	; 0x0f
    739e:	38 89       	ldd	r19, Y+16	; 0x10
    73a0:	8b 85       	ldd	r24, Y+11	; 0x0b
    73a2:	9c 85       	ldd	r25, Y+12	; 0x0c
    73a4:	f9 01       	movw	r30, r18
    73a6:	e8 0f       	add	r30, r24
    73a8:	f9 1f       	adc	r31, r25
    73aa:	80 81       	ld	r24, Z
    73ac:	88 2f       	mov	r24, r24
    73ae:	90 e0       	ldi	r25, 0x00	; 0
    73b0:	9c 01       	movw	r18, r24
    73b2:	20 52       	subi	r18, 0x20	; 32
    73b4:	30 40       	sbci	r19, 0x00	; 0
    73b6:	49 85       	ldd	r20, Y+9	; 0x09
    73b8:	5a 85       	ldd	r21, Y+10	; 0x0a
    73ba:	c9 01       	movw	r24, r18
    73bc:	88 0f       	add	r24, r24
    73be:	99 1f       	adc	r25, r25
    73c0:	88 0f       	add	r24, r24
    73c2:	99 1f       	adc	r25, r25
    73c4:	82 0f       	add	r24, r18
    73c6:	93 1f       	adc	r25, r19
    73c8:	84 0f       	add	r24, r20
    73ca:	95 1f       	adc	r25, r21
    73cc:	fc 01       	movw	r30, r24
    73ce:	e5 5b       	subi	r30, 0xB5	; 181
    73d0:	fc 4f       	sbci	r31, 0xFC	; 252
    73d2:	80 81       	ld	r24, Z
    73d4:	0e 94 e9 35 	call	0x6bd2	; 0x6bd2 <GLCD_senddata>
				if((Y_address+1)%64==0)
    73d8:	8d 81       	ldd	r24, Y+5	; 0x05
    73da:	9e 81       	ldd	r25, Y+6	; 0x06
    73dc:	01 96       	adiw	r24, 0x01	; 1
    73de:	8f 73       	andi	r24, 0x3F	; 63
    73e0:	90 70       	andi	r25, 0x00	; 0
    73e2:	00 97       	sbiw	r24, 0x00	; 0
    73e4:	a9 f5       	brne	.+106    	; 0x7450 <GLCD_String+0x390>
				{
					GPIO_togglePin(GLCD_CS1_PORT_ID, GLCD_CS1_PIN_ID);
    73e6:	81 e0       	ldi	r24, 0x01	; 1
    73e8:	64 e0       	ldi	r22, 0x04	; 4
    73ea:	0e 94 b0 30 	call	0x6160	; 0x6160 <GPIO_togglePin>
					GPIO_togglePin(GLCD_CS2_PORT_ID, GLCD_CS2_PIN_ID);
    73ee:	81 e0       	ldi	r24, 0x01	; 1
    73f0:	65 e0       	ldi	r22, 0x05	; 5
    73f2:	0e 94 b0 30 	call	0x6160	; 0x6160 <GPIO_togglePin>
					GLCD_sendcommand((Page+Page_inc));
    73f6:	8f 81       	ldd	r24, Y+7	; 0x07
    73f8:	98 85       	ldd	r25, Y+8	; 0x08
    73fa:	cc 01       	movw	r24, r24
    73fc:	a0 e0       	ldi	r26, 0x00	; 0
    73fe:	b0 e0       	ldi	r27, 0x00	; 0
    7400:	bc 01       	movw	r22, r24
    7402:	cd 01       	movw	r24, r26
    7404:	0e 94 ce 05 	call	0xb9c	; 0xb9c <__floatunsisf>
    7408:	dc 01       	movw	r26, r24
    740a:	cb 01       	movw	r24, r22
    740c:	bc 01       	movw	r22, r24
    740e:	cd 01       	movw	r24, r26
    7410:	29 81       	ldd	r18, Y+1	; 0x01
    7412:	3a 81       	ldd	r19, Y+2	; 0x02
    7414:	4b 81       	ldd	r20, Y+3	; 0x03
    7416:	5c 81       	ldd	r21, Y+4	; 0x04
    7418:	0e 94 b9 02 	call	0x572	; 0x572 <__addsf3>
    741c:	dc 01       	movw	r26, r24
    741e:	cb 01       	movw	r24, r22
    7420:	bc 01       	movw	r22, r24
    7422:	cd 01       	movw	r24, r26
    7424:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    7428:	dc 01       	movw	r26, r24
    742a:	cb 01       	movw	r24, r22
    742c:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>
					Page_inc = Page_inc + 0.5;
    7430:	69 81       	ldd	r22, Y+1	; 0x01
    7432:	7a 81       	ldd	r23, Y+2	; 0x02
    7434:	8b 81       	ldd	r24, Y+3	; 0x03
    7436:	9c 81       	ldd	r25, Y+4	; 0x04
    7438:	20 e0       	ldi	r18, 0x00	; 0
    743a:	30 e0       	ldi	r19, 0x00	; 0
    743c:	40 e0       	ldi	r20, 0x00	; 0
    743e:	5f e3       	ldi	r21, 0x3F	; 63
    7440:	0e 94 b9 02 	call	0x572	; 0x572 <__addsf3>
    7444:	dc 01       	movw	r26, r24
    7446:	cb 01       	movw	r24, r22
    7448:	89 83       	std	Y+1, r24	; 0x01
    744a:	9a 83       	std	Y+2, r25	; 0x02
    744c:	ab 83       	std	Y+3, r26	; 0x03
    744e:	bc 83       	std	Y+4, r27	; 0x04
				}
				Y_address++;
    7450:	8d 81       	ldd	r24, Y+5	; 0x05
    7452:	9e 81       	ldd	r25, Y+6	; 0x06
    7454:	01 96       	adiw	r24, 0x01	; 1
    7456:	9e 83       	std	Y+6, r25	; 0x06
    7458:	8d 83       	std	Y+5, r24	; 0x05
				Y_address++;
			}
		}
		else
		{
			for(column=0; column<FontWidth; column++)
    745a:	89 85       	ldd	r24, Y+9	; 0x09
    745c:	9a 85       	ldd	r25, Y+10	; 0x0a
    745e:	01 96       	adiw	r24, 0x01	; 1
    7460:	9a 87       	std	Y+10, r25	; 0x0a
    7462:	89 87       	std	Y+9, r24	; 0x09
    7464:	89 85       	ldd	r24, Y+9	; 0x09
    7466:	9a 85       	ldd	r25, Y+10	; 0x0a
    7468:	85 30       	cpi	r24, 0x05	; 5
    746a:	91 05       	cpc	r25, r1
    746c:	08 f4       	brcc	.+2      	; 0x7470 <GLCD_String+0x3b0>
    746e:	96 cf       	rjmp	.-212    	; 0x739c <GLCD_String+0x2dc>
					GLCD_sendcommand((Page+Page_inc));
					Page_inc = Page_inc + 0.5;
				}
				Y_address++;
			}
			GLCD_senddata(0);
    7470:	80 e0       	ldi	r24, 0x00	; 0
    7472:	0e 94 e9 35 	call	0x6bd2	; 0x6bd2 <GLCD_senddata>
			Y_address++;
    7476:	8d 81       	ldd	r24, Y+5	; 0x05
    7478:	9e 81       	ldd	r25, Y+6	; 0x06
    747a:	01 96       	adiw	r24, 0x01	; 1
    747c:	9e 83       	std	Y+6, r25	; 0x06
    747e:	8d 83       	std	Y+5, r24	; 0x05
			if((Y_address)%64 == 0)
    7480:	8d 81       	ldd	r24, Y+5	; 0x05
    7482:	9e 81       	ldd	r25, Y+6	; 0x06
    7484:	8f 73       	andi	r24, 0x3F	; 63
    7486:	90 70       	andi	r25, 0x00	; 0
    7488:	00 97       	sbiw	r24, 0x00	; 0
    748a:	a9 f5       	brne	.+106    	; 0x74f6 <GLCD_String+0x436>
			{
				GPIO_togglePin(GLCD_CS1_PORT_ID, GLCD_CS1_PIN_ID);
    748c:	81 e0       	ldi	r24, 0x01	; 1
    748e:	64 e0       	ldi	r22, 0x04	; 4
    7490:	0e 94 b0 30 	call	0x6160	; 0x6160 <GPIO_togglePin>
				GPIO_togglePin(GLCD_CS2_PORT_ID, GLCD_CS2_PIN_ID);
    7494:	81 e0       	ldi	r24, 0x01	; 1
    7496:	65 e0       	ldi	r22, 0x05	; 5
    7498:	0e 94 b0 30 	call	0x6160	; 0x6160 <GPIO_togglePin>
				GLCD_sendcommand((Page+Page_inc));
    749c:	8f 81       	ldd	r24, Y+7	; 0x07
    749e:	98 85       	ldd	r25, Y+8	; 0x08
    74a0:	cc 01       	movw	r24, r24
    74a2:	a0 e0       	ldi	r26, 0x00	; 0
    74a4:	b0 e0       	ldi	r27, 0x00	; 0
    74a6:	bc 01       	movw	r22, r24
    74a8:	cd 01       	movw	r24, r26
    74aa:	0e 94 ce 05 	call	0xb9c	; 0xb9c <__floatunsisf>
    74ae:	dc 01       	movw	r26, r24
    74b0:	cb 01       	movw	r24, r22
    74b2:	bc 01       	movw	r22, r24
    74b4:	cd 01       	movw	r24, r26
    74b6:	29 81       	ldd	r18, Y+1	; 0x01
    74b8:	3a 81       	ldd	r19, Y+2	; 0x02
    74ba:	4b 81       	ldd	r20, Y+3	; 0x03
    74bc:	5c 81       	ldd	r21, Y+4	; 0x04
    74be:	0e 94 b9 02 	call	0x572	; 0x572 <__addsf3>
    74c2:	dc 01       	movw	r26, r24
    74c4:	cb 01       	movw	r24, r22
    74c6:	bc 01       	movw	r22, r24
    74c8:	cd 01       	movw	r24, r26
    74ca:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    74ce:	dc 01       	movw	r26, r24
    74d0:	cb 01       	movw	r24, r22
    74d2:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>
				Page_inc = Page_inc + 0.5;
    74d6:	69 81       	ldd	r22, Y+1	; 0x01
    74d8:	7a 81       	ldd	r23, Y+2	; 0x02
    74da:	8b 81       	ldd	r24, Y+3	; 0x03
    74dc:	9c 81       	ldd	r25, Y+4	; 0x04
    74de:	20 e0       	ldi	r18, 0x00	; 0
    74e0:	30 e0       	ldi	r19, 0x00	; 0
    74e2:	40 e0       	ldi	r20, 0x00	; 0
    74e4:	5f e3       	ldi	r21, 0x3F	; 63
    74e6:	0e 94 b9 02 	call	0x572	; 0x572 <__addsf3>
    74ea:	dc 01       	movw	r26, r24
    74ec:	cb 01       	movw	r24, r22
    74ee:	89 83       	std	Y+1, r24	; 0x01
    74f0:	9a 83       	std	Y+2, r25	; 0x02
    74f2:	ab 83       	std	Y+3, r26	; 0x03
    74f4:	bc 83       	std	Y+4, r27	; 0x04
	unsigned int Page = ((0xB8) + line_no);
	unsigned int Y_address = 0;
	float Page_inc = 0.5;
GLCD_select_page(page);
	GLCD_sendcommand(Page);
	for(i = 0; str[i] != 0; i++)	/* Print char in string till null */
    74f6:	8b 85       	ldd	r24, Y+11	; 0x0b
    74f8:	9c 85       	ldd	r25, Y+12	; 0x0c
    74fa:	01 96       	adiw	r24, 0x01	; 1
    74fc:	9c 87       	std	Y+12, r25	; 0x0c
    74fe:	8b 87       	std	Y+11, r24	; 0x0b
    7500:	2f 85       	ldd	r18, Y+15	; 0x0f
    7502:	38 89       	ldd	r19, Y+16	; 0x10
    7504:	8b 85       	ldd	r24, Y+11	; 0x0b
    7506:	9c 85       	ldd	r25, Y+12	; 0x0c
    7508:	f9 01       	movw	r30, r18
    750a:	e8 0f       	add	r30, r24
    750c:	f9 1f       	adc	r31, r25
    750e:	80 81       	ld	r24, Z
    7510:	88 23       	and	r24, r24
    7512:	09 f0       	breq	.+2      	; 0x7516 <GLCD_String+0x456>
    7514:	ff cd       	rjmp	.-1026   	; 0x7114 <GLCD_String+0x54>
				GLCD_sendcommand((Page+Page_inc));
				Page_inc = Page_inc + 0.5;
			}
		}
	}
	GLCD_sendcommand(0x40);  	/* Set Y address (column=0) */
    7516:	80 e4       	ldi	r24, 0x40	; 64
    7518:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>

}
    751c:	60 96       	adiw	r28, 0x10	; 16
    751e:	0f b6       	in	r0, 0x3f	; 63
    7520:	f8 94       	cli
    7522:	de bf       	out	0x3e, r29	; 62
    7524:	0f be       	out	0x3f, r0	; 63
    7526:	cd bf       	out	0x3d, r28	; 61
    7528:	cf 91       	pop	r28
    752a:	df 91       	pop	r29
    752c:	1f 91       	pop	r17
    752e:	0f 91       	pop	r16
    7530:	08 95       	ret

00007532 <GLCD_line>:



void GLCD_line(uint8 line){
    7532:	df 93       	push	r29
    7534:	cf 93       	push	r28
    7536:	0f 92       	push	r0
    7538:	cd b7       	in	r28, 0x3d	; 61
    753a:	de b7       	in	r29, 0x3e	; 62
    753c:	89 83       	std	Y+1, r24	; 0x01
	GPIO_writePin(GLCD_CS1_PORT_ID,GLCD_CS1_PIN_ID , LOGIC_HIGH);
    753e:	81 e0       	ldi	r24, 0x01	; 1
    7540:	64 e0       	ldi	r22, 0x04	; 4
    7542:	41 e0       	ldi	r20, 0x01	; 1
    7544:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
	GPIO_writePin(GLCD_CS2_PORT_ID,GLCD_CS2_PIN_ID , LOGIC_HIGH);
    7548:	81 e0       	ldi	r24, 0x01	; 1
    754a:	65 e0       	ldi	r22, 0x05	; 5
    754c:	41 e0       	ldi	r20, 0x01	; 1
    754e:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>

	gu8_Curr_X_Address=line;
    7552:	89 81       	ldd	r24, Y+1	; 0x01
    7554:	80 93 a7 15 	sts	0x15A7, r24
	GLCD_sendcommand(GLCD_SET_X_ADDRESS_PREFIX+gu8_Curr_X_Address);
    7558:	80 91 a7 15 	lds	r24, 0x15A7
    755c:	88 54       	subi	r24, 0x48	; 72
    755e:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>
	gu8_Curr_Y_Address=0;
    7562:	10 92 a8 15 	sts	0x15A8, r1
	GLCD_sendcommand(GLCD_SET_Y_ADDRESS_PREFIX+gu8_Curr_Y_Address);
    7566:	80 91 a8 15 	lds	r24, 0x15A8
    756a:	80 5c       	subi	r24, 0xC0	; 192
    756c:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>

	GPIO_writePin(GLCD_CS1_PORT_ID,GLCD_CS1_PIN_ID , LOGIC_HIGH);
    7570:	81 e0       	ldi	r24, 0x01	; 1
    7572:	64 e0       	ldi	r22, 0x04	; 4
    7574:	41 e0       	ldi	r20, 0x01	; 1
    7576:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
	GPIO_writePin(GLCD_CS2_PORT_ID,GLCD_CS2_PIN_ID , LOGIC_LOW);
    757a:	81 e0       	ldi	r24, 0x01	; 1
    757c:	65 e0       	ldi	r22, 0x05	; 5
    757e:	40 e0       	ldi	r20, 0x00	; 0
    7580:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>


}
    7584:	0f 90       	pop	r0
    7586:	cf 91       	pop	r28
    7588:	df 91       	pop	r29
    758a:	08 95       	ret

0000758c <GLCD_number>:


void GLCD_number(uint8 line_no,uint8 page,uint16 number)
{
    758c:	df 93       	push	r29
    758e:	cf 93       	push	r28
    7590:	cd b7       	in	r28, 0x3d	; 61
    7592:	de b7       	in	r29, 0x3e	; 62
    7594:	64 97       	sbiw	r28, 0x14	; 20
    7596:	0f b6       	in	r0, 0x3f	; 63
    7598:	f8 94       	cli
    759a:	de bf       	out	0x3e, r29	; 62
    759c:	0f be       	out	0x3f, r0	; 63
    759e:	cd bf       	out	0x3d, r28	; 61
    75a0:	89 8b       	std	Y+17, r24	; 0x11
    75a2:	6a 8b       	std	Y+18, r22	; 0x12
    75a4:	5c 8b       	std	Y+20, r21	; 0x14
    75a6:	4b 8b       	std	Y+19, r20	; 0x13


	char buff[16]; /* String to hold the ascii result */
	   itoa(number,buff,10);
    75a8:	8b 89       	ldd	r24, Y+19	; 0x13
    75aa:	9c 89       	ldd	r25, Y+20	; 0x14
    75ac:	9e 01       	movw	r18, r28
    75ae:	2f 5f       	subi	r18, 0xFF	; 255
    75b0:	3f 4f       	sbci	r19, 0xFF	; 255
    75b2:	b9 01       	movw	r22, r18
    75b4:	4a e0       	ldi	r20, 0x0A	; 10
    75b6:	50 e0       	ldi	r21, 0x00	; 0
    75b8:	0e 94 27 40 	call	0x804e	; 0x804e <itoa>


	GLCD_String(line_no, page, buff);
    75bc:	89 89       	ldd	r24, Y+17	; 0x11
    75be:	6a 89       	ldd	r22, Y+18	; 0x12
    75c0:	9e 01       	movw	r18, r28
    75c2:	2f 5f       	subi	r18, 0xFF	; 255
    75c4:	3f 4f       	sbci	r19, 0xFF	; 255
    75c6:	a9 01       	movw	r20, r18
    75c8:	0e 94 60 38 	call	0x70c0	; 0x70c0 <GLCD_String>

}
    75cc:	64 96       	adiw	r28, 0x14	; 20
    75ce:	0f b6       	in	r0, 0x3f	; 63
    75d0:	f8 94       	cli
    75d2:	de bf       	out	0x3e, r29	; 62
    75d4:	0f be       	out	0x3f, r0	; 63
    75d6:	cd bf       	out	0x3d, r28	; 61
    75d8:	cf 91       	pop	r28
    75da:	df 91       	pop	r29
    75dc:	08 95       	ret

000075de <GLCD_Reset>:
void GLCD_Reset(void){
    75de:	df 93       	push	r29
    75e0:	cf 93       	push	r28
    75e2:	cd b7       	in	r28, 0x3d	; 61
    75e4:	de b7       	in	r29, 0x3e	; 62
    75e6:	68 97       	sbiw	r28, 0x18	; 24
    75e8:	0f b6       	in	r0, 0x3f	; 63
    75ea:	f8 94       	cli
    75ec:	de bf       	out	0x3e, r29	; 62
    75ee:	0f be       	out	0x3f, r0	; 63
    75f0:	cd bf       	out	0x3d, r28	; 61

	GPIO_writePin(GLCD_RST_PORT_ID, GLCD_RST_PIN_ID, LOGIC_LOW);
    75f2:	81 e0       	ldi	r24, 0x01	; 1
    75f4:	61 e0       	ldi	r22, 0x01	; 1
    75f6:	40 e0       	ldi	r20, 0x00	; 0
    75f8:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>
    75fc:	80 e0       	ldi	r24, 0x00	; 0
    75fe:	90 e0       	ldi	r25, 0x00	; 0
    7600:	a0 e2       	ldi	r26, 0x20	; 32
    7602:	b1 e4       	ldi	r27, 0x41	; 65
    7604:	8d 8b       	std	Y+21, r24	; 0x15
    7606:	9e 8b       	std	Y+22, r25	; 0x16
    7608:	af 8b       	std	Y+23, r26	; 0x17
    760a:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    760c:	6d 89       	ldd	r22, Y+21	; 0x15
    760e:	7e 89       	ldd	r23, Y+22	; 0x16
    7610:	8f 89       	ldd	r24, Y+23	; 0x17
    7612:	98 8d       	ldd	r25, Y+24	; 0x18
    7614:	2b ea       	ldi	r18, 0xAB	; 171
    7616:	3a ea       	ldi	r19, 0xAA	; 170
    7618:	4a ea       	ldi	r20, 0xAA	; 170
    761a:	5e e3       	ldi	r21, 0x3E	; 62
    761c:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    7620:	dc 01       	movw	r26, r24
    7622:	cb 01       	movw	r24, r22
    7624:	89 8b       	std	Y+17, r24	; 0x11
    7626:	9a 8b       	std	Y+18, r25	; 0x12
    7628:	ab 8b       	std	Y+19, r26	; 0x13
    762a:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    762c:	69 89       	ldd	r22, Y+17	; 0x11
    762e:	7a 89       	ldd	r23, Y+18	; 0x12
    7630:	8b 89       	ldd	r24, Y+19	; 0x13
    7632:	9c 89       	ldd	r25, Y+20	; 0x14
    7634:	20 e0       	ldi	r18, 0x00	; 0
    7636:	30 e0       	ldi	r19, 0x00	; 0
    7638:	40 e8       	ldi	r20, 0x80	; 128
    763a:	5f e3       	ldi	r21, 0x3F	; 63
    763c:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__ltsf2>
    7640:	88 23       	and	r24, r24
    7642:	1c f4       	brge	.+6      	; 0x764a <GLCD_Reset+0x6c>
		__ticks = 1;
    7644:	81 e0       	ldi	r24, 0x01	; 1
    7646:	88 8b       	std	Y+16, r24	; 0x10
    7648:	91 c0       	rjmp	.+290    	; 0x776c <GLCD_Reset+0x18e>
	else if (__tmp > 255)
    764a:	69 89       	ldd	r22, Y+17	; 0x11
    764c:	7a 89       	ldd	r23, Y+18	; 0x12
    764e:	8b 89       	ldd	r24, Y+19	; 0x13
    7650:	9c 89       	ldd	r25, Y+20	; 0x14
    7652:	20 e0       	ldi	r18, 0x00	; 0
    7654:	30 e0       	ldi	r19, 0x00	; 0
    7656:	4f e7       	ldi	r20, 0x7F	; 127
    7658:	53 e4       	ldi	r21, 0x43	; 67
    765a:	0e 94 8c 04 	call	0x918	; 0x918 <__gtsf2>
    765e:	18 16       	cp	r1, r24
    7660:	0c f0       	brlt	.+2      	; 0x7664 <GLCD_Reset+0x86>
    7662:	7b c0       	rjmp	.+246    	; 0x775a <GLCD_Reset+0x17c>
	{
		_delay_ms(__us / 1000.0);
    7664:	6d 89       	ldd	r22, Y+21	; 0x15
    7666:	7e 89       	ldd	r23, Y+22	; 0x16
    7668:	8f 89       	ldd	r24, Y+23	; 0x17
    766a:	98 8d       	ldd	r25, Y+24	; 0x18
    766c:	20 e0       	ldi	r18, 0x00	; 0
    766e:	30 e0       	ldi	r19, 0x00	; 0
    7670:	4a e7       	ldi	r20, 0x7A	; 122
    7672:	54 e4       	ldi	r21, 0x44	; 68
    7674:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <__divsf3>
    7678:	dc 01       	movw	r26, r24
    767a:	cb 01       	movw	r24, r22
    767c:	8c 87       	std	Y+12, r24	; 0x0c
    767e:	9d 87       	std	Y+13, r25	; 0x0d
    7680:	ae 87       	std	Y+14, r26	; 0x0e
    7682:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7684:	6c 85       	ldd	r22, Y+12	; 0x0c
    7686:	7d 85       	ldd	r23, Y+13	; 0x0d
    7688:	8e 85       	ldd	r24, Y+14	; 0x0e
    768a:	9f 85       	ldd	r25, Y+15	; 0x0f
    768c:	20 e0       	ldi	r18, 0x00	; 0
    768e:	30 e0       	ldi	r19, 0x00	; 0
    7690:	4a e7       	ldi	r20, 0x7A	; 122
    7692:	53 e4       	ldi	r21, 0x43	; 67
    7694:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    7698:	dc 01       	movw	r26, r24
    769a:	cb 01       	movw	r24, r22
    769c:	88 87       	std	Y+8, r24	; 0x08
    769e:	99 87       	std	Y+9, r25	; 0x09
    76a0:	aa 87       	std	Y+10, r26	; 0x0a
    76a2:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    76a4:	68 85       	ldd	r22, Y+8	; 0x08
    76a6:	79 85       	ldd	r23, Y+9	; 0x09
    76a8:	8a 85       	ldd	r24, Y+10	; 0x0a
    76aa:	9b 85       	ldd	r25, Y+11	; 0x0b
    76ac:	20 e0       	ldi	r18, 0x00	; 0
    76ae:	30 e0       	ldi	r19, 0x00	; 0
    76b0:	40 e8       	ldi	r20, 0x80	; 128
    76b2:	5f e3       	ldi	r21, 0x3F	; 63
    76b4:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__ltsf2>
    76b8:	88 23       	and	r24, r24
    76ba:	2c f4       	brge	.+10     	; 0x76c6 <GLCD_Reset+0xe8>
		__ticks = 1;
    76bc:	81 e0       	ldi	r24, 0x01	; 1
    76be:	90 e0       	ldi	r25, 0x00	; 0
    76c0:	9f 83       	std	Y+7, r25	; 0x07
    76c2:	8e 83       	std	Y+6, r24	; 0x06
    76c4:	3f c0       	rjmp	.+126    	; 0x7744 <GLCD_Reset+0x166>
	else if (__tmp > 65535)
    76c6:	68 85       	ldd	r22, Y+8	; 0x08
    76c8:	79 85       	ldd	r23, Y+9	; 0x09
    76ca:	8a 85       	ldd	r24, Y+10	; 0x0a
    76cc:	9b 85       	ldd	r25, Y+11	; 0x0b
    76ce:	20 e0       	ldi	r18, 0x00	; 0
    76d0:	3f ef       	ldi	r19, 0xFF	; 255
    76d2:	4f e7       	ldi	r20, 0x7F	; 127
    76d4:	57 e4       	ldi	r21, 0x47	; 71
    76d6:	0e 94 8c 04 	call	0x918	; 0x918 <__gtsf2>
    76da:	18 16       	cp	r1, r24
    76dc:	4c f5       	brge	.+82     	; 0x7730 <GLCD_Reset+0x152>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    76de:	6c 85       	ldd	r22, Y+12	; 0x0c
    76e0:	7d 85       	ldd	r23, Y+13	; 0x0d
    76e2:	8e 85       	ldd	r24, Y+14	; 0x0e
    76e4:	9f 85       	ldd	r25, Y+15	; 0x0f
    76e6:	20 e0       	ldi	r18, 0x00	; 0
    76e8:	30 e0       	ldi	r19, 0x00	; 0
    76ea:	40 e2       	ldi	r20, 0x20	; 32
    76ec:	51 e4       	ldi	r21, 0x41	; 65
    76ee:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    76f2:	dc 01       	movw	r26, r24
    76f4:	cb 01       	movw	r24, r22
    76f6:	bc 01       	movw	r22, r24
    76f8:	cd 01       	movw	r24, r26
    76fa:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    76fe:	dc 01       	movw	r26, r24
    7700:	cb 01       	movw	r24, r22
    7702:	9f 83       	std	Y+7, r25	; 0x07
    7704:	8e 83       	std	Y+6, r24	; 0x06
    7706:	0f c0       	rjmp	.+30     	; 0x7726 <GLCD_Reset+0x148>
    7708:	89 e1       	ldi	r24, 0x19	; 25
    770a:	90 e0       	ldi	r25, 0x00	; 0
    770c:	9d 83       	std	Y+5, r25	; 0x05
    770e:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7710:	8c 81       	ldd	r24, Y+4	; 0x04
    7712:	9d 81       	ldd	r25, Y+5	; 0x05
    7714:	01 97       	sbiw	r24, 0x01	; 1
    7716:	f1 f7       	brne	.-4      	; 0x7714 <GLCD_Reset+0x136>
    7718:	9d 83       	std	Y+5, r25	; 0x05
    771a:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    771c:	8e 81       	ldd	r24, Y+6	; 0x06
    771e:	9f 81       	ldd	r25, Y+7	; 0x07
    7720:	01 97       	sbiw	r24, 0x01	; 1
    7722:	9f 83       	std	Y+7, r25	; 0x07
    7724:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7726:	8e 81       	ldd	r24, Y+6	; 0x06
    7728:	9f 81       	ldd	r25, Y+7	; 0x07
    772a:	00 97       	sbiw	r24, 0x00	; 0
    772c:	69 f7       	brne	.-38     	; 0x7708 <GLCD_Reset+0x12a>
    772e:	24 c0       	rjmp	.+72     	; 0x7778 <GLCD_Reset+0x19a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7730:	68 85       	ldd	r22, Y+8	; 0x08
    7732:	79 85       	ldd	r23, Y+9	; 0x09
    7734:	8a 85       	ldd	r24, Y+10	; 0x0a
    7736:	9b 85       	ldd	r25, Y+11	; 0x0b
    7738:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    773c:	dc 01       	movw	r26, r24
    773e:	cb 01       	movw	r24, r22
    7740:	9f 83       	std	Y+7, r25	; 0x07
    7742:	8e 83       	std	Y+6, r24	; 0x06
    7744:	8e 81       	ldd	r24, Y+6	; 0x06
    7746:	9f 81       	ldd	r25, Y+7	; 0x07
    7748:	9b 83       	std	Y+3, r25	; 0x03
    774a:	8a 83       	std	Y+2, r24	; 0x02
    774c:	8a 81       	ldd	r24, Y+2	; 0x02
    774e:	9b 81       	ldd	r25, Y+3	; 0x03
    7750:	01 97       	sbiw	r24, 0x01	; 1
    7752:	f1 f7       	brne	.-4      	; 0x7750 <GLCD_Reset+0x172>
    7754:	9b 83       	std	Y+3, r25	; 0x03
    7756:	8a 83       	std	Y+2, r24	; 0x02
    7758:	0f c0       	rjmp	.+30     	; 0x7778 <GLCD_Reset+0x19a>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    775a:	69 89       	ldd	r22, Y+17	; 0x11
    775c:	7a 89       	ldd	r23, Y+18	; 0x12
    775e:	8b 89       	ldd	r24, Y+19	; 0x13
    7760:	9c 89       	ldd	r25, Y+20	; 0x14
    7762:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    7766:	dc 01       	movw	r26, r24
    7768:	cb 01       	movw	r24, r22
    776a:	88 8b       	std	Y+16, r24	; 0x10
    776c:	88 89       	ldd	r24, Y+16	; 0x10
    776e:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7770:	89 81       	ldd	r24, Y+1	; 0x01
    7772:	8a 95       	dec	r24
    7774:	f1 f7       	brne	.-4      	; 0x7772 <GLCD_Reset+0x194>
    7776:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(10);
	GPIO_writePin(GLCD_RST_PORT_ID, GLCD_RST_PIN_ID, LOGIC_HIGH);
    7778:	81 e0       	ldi	r24, 0x01	; 1
    777a:	61 e0       	ldi	r22, 0x01	; 1
    777c:	41 e0       	ldi	r20, 0x01	; 1
    777e:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <GPIO_writePin>

}
    7782:	68 96       	adiw	r28, 0x18	; 24
    7784:	0f b6       	in	r0, 0x3f	; 63
    7786:	f8 94       	cli
    7788:	de bf       	out	0x3e, r29	; 62
    778a:	0f be       	out	0x3f, r0	; 63
    778c:	cd bf       	out	0x3d, r28	; 61
    778e:	cf 91       	pop	r28
    7790:	df 91       	pop	r29
    7792:	08 95       	ret

00007794 <GLCD_ClearDisplay>:

void GLCD_ClearDisplay(void) {
    7794:	df 93       	push	r29
    7796:	cf 93       	push	r28
    7798:	00 d0       	rcall	.+0      	; 0x779a <GLCD_ClearDisplay+0x6>
    779a:	cd b7       	in	r28, 0x3d	; 61
    779c:	de b7       	in	r29, 0x3e	; 62
	for (uint8 Line = 0; Line < GLCD_MAX_LINES; Line++) {
    779e:	1a 82       	std	Y+2, r1	; 0x02
    77a0:	1e c0       	rjmp	.+60     	; 0x77de <GLCD_ClearDisplay+0x4a>
		GLCD_line(Line);
    77a2:	8a 81       	ldd	r24, Y+2	; 0x02
    77a4:	0e 94 99 3a 	call	0x7532	; 0x7532 <GLCD_line>
		GLCD_select_page(3);
    77a8:	83 e0       	ldi	r24, 0x03	; 3
    77aa:	0e 94 09 38 	call	0x7012	; 0x7012 <GLCD_select_page>
		if(Line>2&&Line<6 ){
    77ae:	8a 81       	ldd	r24, Y+2	; 0x02
    77b0:	83 30       	cpi	r24, 0x03	; 3
    77b2:	18 f0       	brcs	.+6      	; 0x77ba <GLCD_ClearDisplay+0x26>
    77b4:	8a 81       	ldd	r24, Y+2	; 0x02
    77b6:	86 30       	cpi	r24, 0x06	; 6
    77b8:	78 f0       	brcs	.+30     	; 0x77d8 <GLCD_ClearDisplay+0x44>
			continue;
		}
		else{
		for (uint8 i = 0; i < GLCD_MAX_PAGE_PIXEL; i++) {
    77ba:	19 82       	std	Y+1, r1	; 0x01
    77bc:	0a c0       	rjmp	.+20     	; 0x77d2 <GLCD_ClearDisplay+0x3e>
			GLCD_sendcommand(GLCD_SET_Y_ADDRESS_PREFIX + i);
    77be:	89 81       	ldd	r24, Y+1	; 0x01
    77c0:	80 5c       	subi	r24, 0xC0	; 192
    77c2:	0e 94 7c 33 	call	0x66f8	; 0x66f8 <GLCD_sendcommand>
			GLCD_senddata(0);
    77c6:	80 e0       	ldi	r24, 0x00	; 0
    77c8:	0e 94 e9 35 	call	0x6bd2	; 0x6bd2 <GLCD_senddata>
		GLCD_select_page(3);
		if(Line>2&&Line<6 ){
			continue;
		}
		else{
		for (uint8 i = 0; i < GLCD_MAX_PAGE_PIXEL; i++) {
    77cc:	89 81       	ldd	r24, Y+1	; 0x01
    77ce:	8f 5f       	subi	r24, 0xFF	; 255
    77d0:	89 83       	std	Y+1, r24	; 0x01
    77d2:	89 81       	ldd	r24, Y+1	; 0x01
    77d4:	80 34       	cpi	r24, 0x40	; 64
    77d6:	98 f3       	brcs	.-26     	; 0x77be <GLCD_ClearDisplay+0x2a>
	GPIO_writePin(GLCD_RST_PORT_ID, GLCD_RST_PIN_ID, LOGIC_HIGH);

}

void GLCD_ClearDisplay(void) {
	for (uint8 Line = 0; Line < GLCD_MAX_LINES; Line++) {
    77d8:	8a 81       	ldd	r24, Y+2	; 0x02
    77da:	8f 5f       	subi	r24, 0xFF	; 255
    77dc:	8a 83       	std	Y+2, r24	; 0x02
    77de:	8a 81       	ldd	r24, Y+2	; 0x02
    77e0:	88 30       	cpi	r24, 0x08	; 8
    77e2:	f8 f2       	brcs	.-66     	; 0x77a2 <GLCD_ClearDisplay+0xe>
			GLCD_sendcommand(GLCD_SET_Y_ADDRESS_PREFIX + i);
			GLCD_senddata(0);
		}
	}
	}
	GLCD_Reset();
    77e4:	0e 94 ef 3a 	call	0x75de	; 0x75de <GLCD_Reset>
	GLCD_select_page(1);
    77e8:	81 e0       	ldi	r24, 0x01	; 1
    77ea:	0e 94 09 38 	call	0x7012	; 0x7012 <GLCD_select_page>
	gu8_Curr_Page = 0;
    77ee:	10 92 a9 15 	sts	0x15A9, r1
	GLCD_line(0);
    77f2:	80 e0       	ldi	r24, 0x00	; 0
    77f4:	0e 94 99 3a 	call	0x7532	; 0x7532 <GLCD_line>
}
    77f8:	0f 90       	pop	r0
    77fa:	0f 90       	pop	r0
    77fc:	cf 91       	pop	r28
    77fe:	df 91       	pop	r29
    7800:	08 95       	ret

00007802 <APP_edgeProcessing>:
Icu_ConfigType icu_config={F_CPU_CLOCK,RISING};



void APP_edgeProcessing(void)
{
    7802:	df 93       	push	r29
    7804:	cf 93       	push	r28
    7806:	cd b7       	in	r28, 0x3d	; 61
    7808:	de b7       	in	r29, 0x3e	; 62
	g_edgeCount++;
    780a:	80 91 b6 15 	lds	r24, 0x15B6
    780e:	8f 5f       	subi	r24, 0xFF	; 255
    7810:	80 93 b6 15 	sts	0x15B6, r24
	if(g_edgeCount == 1)
    7814:	80 91 b6 15 	lds	r24, 0x15B6
    7818:	81 30       	cpi	r24, 0x01	; 1
    781a:	31 f4       	brne	.+12     	; 0x7828 <APP_edgeProcessing+0x26>
	{
		/*
		 * Clear the timer counter register to start measurements from the
		 * first detected rising edge
		 */
		Icu_clearTimerValue();
    781c:	0e 94 55 33 	call	0x66aa	; 0x66aa <Icu_clearTimerValue>
		/* Detect falling edge */
		Icu_setEdgeDetectionType(FALLING);
    7820:	80 e0       	ldi	r24, 0x00	; 0
    7822:	0e 94 2b 33 	call	0x6656	; 0x6656 <Icu_setEdgeDetectionType>
    7826:	40 c0       	rjmp	.+128    	; 0x78a8 <APP_edgeProcessing+0xa6>
	}
	else if(g_edgeCount == 2)
    7828:	80 91 b6 15 	lds	r24, 0x15B6
    782c:	82 30       	cpi	r24, 0x02	; 2
    782e:	89 f4       	brne	.+34     	; 0x7852 <APP_edgeProcessing+0x50>
	{
		/* Store the High time value */
		g_timeHigh = Icu_getInputCaptureValue();
    7830:	0e 94 4a 33 	call	0x6694	; 0x6694 <Icu_getInputCaptureValue>
    7834:	cc 01       	movw	r24, r24
    7836:	a0 e0       	ldi	r26, 0x00	; 0
    7838:	b0 e0       	ldi	r27, 0x00	; 0
    783a:	80 93 b7 15 	sts	0x15B7, r24
    783e:	90 93 b8 15 	sts	0x15B8, r25
    7842:	a0 93 b9 15 	sts	0x15B9, r26
    7846:	b0 93 ba 15 	sts	0x15BA, r27
		/* Detect rising edge */
		Icu_setEdgeDetectionType(RISING);
    784a:	81 e0       	ldi	r24, 0x01	; 1
    784c:	0e 94 2b 33 	call	0x6656	; 0x6656 <Icu_setEdgeDetectionType>
    7850:	2b c0       	rjmp	.+86     	; 0x78a8 <APP_edgeProcessing+0xa6>
	}
	else if(g_edgeCount == 3)
    7852:	80 91 b6 15 	lds	r24, 0x15B6
    7856:	83 30       	cpi	r24, 0x03	; 3
    7858:	89 f4       	brne	.+34     	; 0x787c <APP_edgeProcessing+0x7a>
	{
		/* Store the Period time value */
		g_timePeriod = Icu_getInputCaptureValue();
    785a:	0e 94 4a 33 	call	0x6694	; 0x6694 <Icu_getInputCaptureValue>
    785e:	cc 01       	movw	r24, r24
    7860:	a0 e0       	ldi	r26, 0x00	; 0
    7862:	b0 e0       	ldi	r27, 0x00	; 0
    7864:	80 93 bb 15 	sts	0x15BB, r24
    7868:	90 93 bc 15 	sts	0x15BC, r25
    786c:	a0 93 bd 15 	sts	0x15BD, r26
    7870:	b0 93 be 15 	sts	0x15BE, r27
		/* Detect falling edge */
		Icu_setEdgeDetectionType(FALLING);
    7874:	80 e0       	ldi	r24, 0x00	; 0
    7876:	0e 94 2b 33 	call	0x6656	; 0x6656 <Icu_setEdgeDetectionType>
    787a:	16 c0       	rjmp	.+44     	; 0x78a8 <APP_edgeProcessing+0xa6>
	}
	else if(g_edgeCount == 4)
    787c:	80 91 b6 15 	lds	r24, 0x15B6
    7880:	84 30       	cpi	r24, 0x04	; 4
    7882:	91 f4       	brne	.+36     	; 0x78a8 <APP_edgeProcessing+0xa6>
	{
		/* Store the Period time value + High time value */
		g_timePeriodPlusHigh = Icu_getInputCaptureValue();
    7884:	0e 94 4a 33 	call	0x6694	; 0x6694 <Icu_getInputCaptureValue>
    7888:	cc 01       	movw	r24, r24
    788a:	a0 e0       	ldi	r26, 0x00	; 0
    788c:	b0 e0       	ldi	r27, 0x00	; 0
    788e:	80 93 bf 15 	sts	0x15BF, r24
    7892:	90 93 c0 15 	sts	0x15C0, r25
    7896:	a0 93 c1 15 	sts	0x15C1, r26
    789a:	b0 93 c2 15 	sts	0x15C2, r27
		/* Clear the timer counter register to start measurements again */
		Icu_clearTimerValue();
    789e:	0e 94 55 33 	call	0x66aa	; 0x66aa <Icu_clearTimerValue>
		/* Detect rising edge */
		Icu_setEdgeDetectionType(RISING);
    78a2:	81 e0       	ldi	r24, 0x01	; 1
    78a4:	0e 94 2b 33 	call	0x6656	; 0x6656 <Icu_setEdgeDetectionType>

	}
}
    78a8:	cf 91       	pop	r28
    78aa:	df 91       	pop	r29
    78ac:	08 95       	ret

000078ae <pwmdrawer_init>:

/*******************************************************************************
 *                      Functions Function                                  *
 *******************************************************************************/

void pwmdrawer_init(void){
    78ae:	df 93       	push	r29
    78b0:	cf 93       	push	r28
    78b2:	cd b7       	in	r28, 0x3d	; 61
    78b4:	de b7       	in	r29, 0x3e	; 62
	GLCD_init();
    78b6:	0e 94 24 35 	call	0x6a48	; 0x6a48 <GLCD_init>
	Icu_setCallBack(APP_edgeProcessing);
    78ba:	81 e0       	ldi	r24, 0x01	; 1
    78bc:	9c e3       	ldi	r25, 0x3C	; 60
    78be:	0e 94 19 33 	call	0x6632	; 0x6632 <Icu_setCallBack>
	Icu_init(&icu_config);
    78c2:	8b e2       	ldi	r24, 0x2B	; 43
    78c4:	95 e0       	ldi	r25, 0x05	; 5
    78c6:	0e 94 d0 32 	call	0x65a0	; 0x65a0 <Icu_init>
}
    78ca:	cf 91       	pop	r28
    78cc:	df 91       	pop	r29
    78ce:	08 95       	ret

000078d0 <pwmdrawer_measuresginal>:

void pwmdrawer_measuresginal(void){
    78d0:	af 92       	push	r10
    78d2:	bf 92       	push	r11
    78d4:	cf 92       	push	r12
    78d6:	df 92       	push	r13
    78d8:	ef 92       	push	r14
    78da:	ff 92       	push	r15
    78dc:	0f 93       	push	r16
    78de:	1f 93       	push	r17
    78e0:	df 93       	push	r29
    78e2:	cf 93       	push	r28
    78e4:	cd b7       	in	r28, 0x3d	; 61
    78e6:	de b7       	in	r29, 0x3e	; 62


	Icu_DeInit();
    78e8:	0e 94 60 33 	call	0x66c0	; 0x66c0 <Icu_DeInit>
	period = ((g_timePeriodPlusHigh - g_timeHigh) / 1000);
    78ec:	20 91 bf 15 	lds	r18, 0x15BF
    78f0:	30 91 c0 15 	lds	r19, 0x15C0
    78f4:	40 91 c1 15 	lds	r20, 0x15C1
    78f8:	50 91 c2 15 	lds	r21, 0x15C2
    78fc:	80 91 b7 15 	lds	r24, 0x15B7
    7900:	90 91 b8 15 	lds	r25, 0x15B8
    7904:	a0 91 b9 15 	lds	r26, 0x15B9
    7908:	b0 91 ba 15 	lds	r27, 0x15BA
    790c:	59 01       	movw	r10, r18
    790e:	6a 01       	movw	r12, r20
    7910:	a8 1a       	sub	r10, r24
    7912:	b9 0a       	sbc	r11, r25
    7914:	ca 0a       	sbc	r12, r26
    7916:	db 0a       	sbc	r13, r27
    7918:	d6 01       	movw	r26, r12
    791a:	c5 01       	movw	r24, r10
    791c:	28 ee       	ldi	r18, 0xE8	; 232
    791e:	33 e0       	ldi	r19, 0x03	; 3
    7920:	40 e0       	ldi	r20, 0x00	; 0
    7922:	50 e0       	ldi	r21, 0x00	; 0
    7924:	bc 01       	movw	r22, r24
    7926:	cd 01       	movw	r24, r26
    7928:	0e 94 be 3f 	call	0x7f7c	; 0x7f7c <__udivmodsi4>
    792c:	da 01       	movw	r26, r20
    792e:	c9 01       	movw	r24, r18
    7930:	80 93 b2 15 	sts	0x15B2, r24
    7934:	90 93 b3 15 	sts	0x15B3, r25
    7938:	a0 93 b4 15 	sts	0x15B4, r26
    793c:	b0 93 b5 15 	sts	0x15B5, r27
	frequency= _F_CPU/(g_timePeriodPlusHigh - g_timeHigh);
    7940:	20 91 bf 15 	lds	r18, 0x15BF
    7944:	30 91 c0 15 	lds	r19, 0x15C0
    7948:	40 91 c1 15 	lds	r20, 0x15C1
    794c:	50 91 c2 15 	lds	r21, 0x15C2
    7950:	80 91 b7 15 	lds	r24, 0x15B7
    7954:	90 91 b8 15 	lds	r25, 0x15B8
    7958:	a0 91 b9 15 	lds	r26, 0x15B9
    795c:	b0 91 ba 15 	lds	r27, 0x15BA
    7960:	28 1b       	sub	r18, r24
    7962:	39 0b       	sbc	r19, r25
    7964:	4a 0b       	sbc	r20, r26
    7966:	5b 0b       	sbc	r21, r27
    7968:	80 e4       	ldi	r24, 0x40	; 64
    796a:	92 e4       	ldi	r25, 0x42	; 66
    796c:	af e0       	ldi	r26, 0x0F	; 15
    796e:	b0 e0       	ldi	r27, 0x00	; 0
    7970:	bc 01       	movw	r22, r24
    7972:	cd 01       	movw	r24, r26
    7974:	0e 94 be 3f 	call	0x7f7c	; 0x7f7c <__udivmodsi4>
    7978:	da 01       	movw	r26, r20
    797a:	c9 01       	movw	r24, r18
    797c:	80 93 aa 15 	sts	0x15AA, r24
    7980:	90 93 ab 15 	sts	0x15AB, r25
    7984:	a0 93 ac 15 	sts	0x15AC, r26
    7988:	b0 93 ad 15 	sts	0x15AD, r27
	duty_cycle=((float)(g_timePeriodPlusHigh-g_timePeriod) / (g_timePeriodPlusHigh - g_timeHigh)) * 100;
    798c:	20 91 bf 15 	lds	r18, 0x15BF
    7990:	30 91 c0 15 	lds	r19, 0x15C0
    7994:	40 91 c1 15 	lds	r20, 0x15C1
    7998:	50 91 c2 15 	lds	r21, 0x15C2
    799c:	80 91 bb 15 	lds	r24, 0x15BB
    79a0:	90 91 bc 15 	lds	r25, 0x15BC
    79a4:	a0 91 bd 15 	lds	r26, 0x15BD
    79a8:	b0 91 be 15 	lds	r27, 0x15BE
    79ac:	69 01       	movw	r12, r18
    79ae:	7a 01       	movw	r14, r20
    79b0:	c8 1a       	sub	r12, r24
    79b2:	d9 0a       	sbc	r13, r25
    79b4:	ea 0a       	sbc	r14, r26
    79b6:	fb 0a       	sbc	r15, r27
    79b8:	d7 01       	movw	r26, r14
    79ba:	c6 01       	movw	r24, r12
    79bc:	bc 01       	movw	r22, r24
    79be:	cd 01       	movw	r24, r26
    79c0:	0e 94 ce 05 	call	0xb9c	; 0xb9c <__floatunsisf>
    79c4:	7b 01       	movw	r14, r22
    79c6:	8c 01       	movw	r16, r24
    79c8:	20 91 bf 15 	lds	r18, 0x15BF
    79cc:	30 91 c0 15 	lds	r19, 0x15C0
    79d0:	40 91 c1 15 	lds	r20, 0x15C1
    79d4:	50 91 c2 15 	lds	r21, 0x15C2
    79d8:	80 91 b7 15 	lds	r24, 0x15B7
    79dc:	90 91 b8 15 	lds	r25, 0x15B8
    79e0:	a0 91 b9 15 	lds	r26, 0x15B9
    79e4:	b0 91 ba 15 	lds	r27, 0x15BA
    79e8:	59 01       	movw	r10, r18
    79ea:	6a 01       	movw	r12, r20
    79ec:	a8 1a       	sub	r10, r24
    79ee:	b9 0a       	sbc	r11, r25
    79f0:	ca 0a       	sbc	r12, r26
    79f2:	db 0a       	sbc	r13, r27
    79f4:	d6 01       	movw	r26, r12
    79f6:	c5 01       	movw	r24, r10
    79f8:	bc 01       	movw	r22, r24
    79fa:	cd 01       	movw	r24, r26
    79fc:	0e 94 ce 05 	call	0xb9c	; 0xb9c <__floatunsisf>
    7a00:	9b 01       	movw	r18, r22
    7a02:	ac 01       	movw	r20, r24
    7a04:	c8 01       	movw	r24, r16
    7a06:	b7 01       	movw	r22, r14
    7a08:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <__divsf3>
    7a0c:	dc 01       	movw	r26, r24
    7a0e:	cb 01       	movw	r24, r22
    7a10:	bc 01       	movw	r22, r24
    7a12:	cd 01       	movw	r24, r26
    7a14:	20 e0       	ldi	r18, 0x00	; 0
    7a16:	30 e0       	ldi	r19, 0x00	; 0
    7a18:	48 ec       	ldi	r20, 0xC8	; 200
    7a1a:	52 e4       	ldi	r21, 0x42	; 66
    7a1c:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    7a20:	dc 01       	movw	r26, r24
    7a22:	cb 01       	movw	r24, r22
    7a24:	bc 01       	movw	r22, r24
    7a26:	cd 01       	movw	r24, r26
    7a28:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    7a2c:	dc 01       	movw	r26, r24
    7a2e:	cb 01       	movw	r24, r22
    7a30:	80 93 ae 15 	sts	0x15AE, r24
    7a34:	90 93 af 15 	sts	0x15AF, r25
    7a38:	a0 93 b0 15 	sts	0x15B0, r26
    7a3c:	b0 93 b1 15 	sts	0x15B1, r27


}
    7a40:	cf 91       	pop	r28
    7a42:	df 91       	pop	r29
    7a44:	1f 91       	pop	r17
    7a46:	0f 91       	pop	r16
    7a48:	ff 90       	pop	r15
    7a4a:	ef 90       	pop	r14
    7a4c:	df 90       	pop	r13
    7a4e:	cf 90       	pop	r12
    7a50:	bf 90       	pop	r11
    7a52:	af 90       	pop	r10
    7a54:	08 95       	ret

00007a56 <pwmdrawer_drawsignal>:


void pwmdrawer_drawsignal(void){
    7a56:	ef 92       	push	r14
    7a58:	ff 92       	push	r15
    7a5a:	0f 93       	push	r16
    7a5c:	1f 93       	push	r17
    7a5e:	df 93       	push	r29
    7a60:	cf 93       	push	r28
    7a62:	cd b7       	in	r28, 0x3d	; 61
    7a64:	de b7       	in	r29, 0x3e	; 62
    7a66:	62 97       	sbiw	r28, 0x12	; 18
    7a68:	0f b6       	in	r0, 0x3f	; 63
    7a6a:	f8 94       	cli
    7a6c:	de bf       	out	0x3e, r29	; 62
    7a6e:	0f be       	out	0x3f, r0	; 63
    7a70:	cd bf       	out	0x3d, r28	; 61
	GLCD_String(0, 1, "frequency=");
    7a72:	25 e0       	ldi	r18, 0x05	; 5
    7a74:	32 e0       	ldi	r19, 0x02	; 2
    7a76:	80 e0       	ldi	r24, 0x00	; 0
    7a78:	61 e0       	ldi	r22, 0x01	; 1
    7a7a:	a9 01       	movw	r20, r18
    7a7c:	0e 94 60 38 	call	0x70c0	; 0x70c0 <GLCD_String>
	GLCD_String(1, 1, "duty cycle=");
    7a80:	20 e1       	ldi	r18, 0x10	; 16
    7a82:	32 e0       	ldi	r19, 0x02	; 2
    7a84:	81 e0       	ldi	r24, 0x01	; 1
    7a86:	61 e0       	ldi	r22, 0x01	; 1
    7a88:	a9 01       	movw	r20, r18
    7a8a:	0e 94 60 38 	call	0x70c0	; 0x70c0 <GLCD_String>
	GLCD_number(0, 2, frequency);
    7a8e:	80 91 aa 15 	lds	r24, 0x15AA
    7a92:	90 91 ab 15 	lds	r25, 0x15AB
    7a96:	a0 91 ac 15 	lds	r26, 0x15AC
    7a9a:	b0 91 ad 15 	lds	r27, 0x15AD
    7a9e:	9c 01       	movw	r18, r24
    7aa0:	80 e0       	ldi	r24, 0x00	; 0
    7aa2:	62 e0       	ldi	r22, 0x02	; 2
    7aa4:	a9 01       	movw	r20, r18
    7aa6:	0e 94 c6 3a 	call	0x758c	; 0x758c <GLCD_number>
	GLCD_number(1, 2, duty_cycle);
    7aaa:	80 91 ae 15 	lds	r24, 0x15AE
    7aae:	90 91 af 15 	lds	r25, 0x15AF
    7ab2:	a0 91 b0 15 	lds	r26, 0x15B0
    7ab6:	b0 91 b1 15 	lds	r27, 0x15B1
    7aba:	9c 01       	movw	r18, r24
    7abc:	81 e0       	ldi	r24, 0x01	; 1
    7abe:	62 e0       	ldi	r22, 0x02	; 2
    7ac0:	a9 01       	movw	r20, r18
    7ac2:	0e 94 c6 3a 	call	0x758c	; 0x758c <GLCD_number>




	GLCD_line(6);
    7ac6:	86 e0       	ldi	r24, 0x06	; 6
    7ac8:	0e 94 99 3a 	call	0x7532	; 0x7532 <GLCD_line>

	uint8 pixel_width=0;
    7acc:	1a 8a       	std	Y+18, r1	; 0x12
	uint8 scale_ms=period/5;
    7ace:	80 91 b2 15 	lds	r24, 0x15B2
    7ad2:	90 91 b3 15 	lds	r25, 0x15B3
    7ad6:	a0 91 b4 15 	lds	r26, 0x15B4
    7ada:	b0 91 b5 15 	lds	r27, 0x15B5
    7ade:	25 e0       	ldi	r18, 0x05	; 5
    7ae0:	30 e0       	ldi	r19, 0x00	; 0
    7ae2:	40 e0       	ldi	r20, 0x00	; 0
    7ae4:	50 e0       	ldi	r21, 0x00	; 0
    7ae6:	bc 01       	movw	r22, r24
    7ae8:	cd 01       	movw	r24, r26
    7aea:	0e 94 be 3f 	call	0x7f7c	; 0x7f7c <__udivmodsi4>
    7aee:	da 01       	movw	r26, r20
    7af0:	c9 01       	movw	r24, r18
    7af2:	89 8b       	std	Y+17, r24	; 0x11
    7af4:	ba c0       	rjmp	.+372    	; 0x7c6a <pwmdrawer_drawsignal+0x214>


	 while(pixel_width<GLCD_MAX_LINE_PIXEL-8){
		 GLCD_DisplaySpecialPattern(PWM_DRAWER_GLCD_RISING_EDGE);
    7af6:	20 e4       	ldi	r18, 0x40	; 64
    7af8:	30 e4       	ldi	r19, 0x40	; 64
    7afa:	4e e7       	ldi	r20, 0x7E	; 126
    7afc:	52 e0       	ldi	r21, 0x02	; 2
    7afe:	62 e0       	ldi	r22, 0x02	; 2
    7b00:	70 e0       	ldi	r23, 0x00	; 0
    7b02:	80 e0       	ldi	r24, 0x00	; 0
    7b04:	90 e0       	ldi	r25, 0x00	; 0
    7b06:	0e 94 91 37 	call	0x6f22	; 0x6f22 <GLCD_DisplaySpecialPattern>
		 pixel_width+=5;
    7b0a:	8a 89       	ldd	r24, Y+18	; 0x12
    7b0c:	8b 5f       	subi	r24, 0xFB	; 251
    7b0e:	8a 8b       	std	Y+18, r24	; 0x12

		 for(uint8 i=0; i<(uint8)((float)(g_timeHigh/1000)/scale_ms);i++){
    7b10:	18 8a       	std	Y+16, r1	; 0x10
    7b12:	10 c0       	rjmp	.+32     	; 0x7b34 <pwmdrawer_drawsignal+0xde>
			 GLCD_DisplaySpecialPattern(PWM_DRAWER_GLCD_HIGH_LINE);
    7b14:	22 e0       	ldi	r18, 0x02	; 2
    7b16:	32 e0       	ldi	r19, 0x02	; 2
    7b18:	42 e0       	ldi	r20, 0x02	; 2
    7b1a:	52 e0       	ldi	r21, 0x02	; 2
    7b1c:	62 e0       	ldi	r22, 0x02	; 2
    7b1e:	70 e0       	ldi	r23, 0x00	; 0
    7b20:	80 e0       	ldi	r24, 0x00	; 0
    7b22:	90 e0       	ldi	r25, 0x00	; 0
    7b24:	0e 94 91 37 	call	0x6f22	; 0x6f22 <GLCD_DisplaySpecialPattern>
			 pixel_width+=5;
    7b28:	8a 89       	ldd	r24, Y+18	; 0x12
    7b2a:	8b 5f       	subi	r24, 0xFB	; 251
    7b2c:	8a 8b       	std	Y+18, r24	; 0x12

	 while(pixel_width<GLCD_MAX_LINE_PIXEL-8){
		 GLCD_DisplaySpecialPattern(PWM_DRAWER_GLCD_RISING_EDGE);
		 pixel_width+=5;

		 for(uint8 i=0; i<(uint8)((float)(g_timeHigh/1000)/scale_ms);i++){
    7b2e:	88 89       	ldd	r24, Y+16	; 0x10
    7b30:	8f 5f       	subi	r24, 0xFF	; 255
    7b32:	88 8b       	std	Y+16, r24	; 0x10
    7b34:	80 91 b7 15 	lds	r24, 0x15B7
    7b38:	90 91 b8 15 	lds	r25, 0x15B8
    7b3c:	a0 91 b9 15 	lds	r26, 0x15B9
    7b40:	b0 91 ba 15 	lds	r27, 0x15BA
    7b44:	28 ee       	ldi	r18, 0xE8	; 232
    7b46:	33 e0       	ldi	r19, 0x03	; 3
    7b48:	40 e0       	ldi	r20, 0x00	; 0
    7b4a:	50 e0       	ldi	r21, 0x00	; 0
    7b4c:	bc 01       	movw	r22, r24
    7b4e:	cd 01       	movw	r24, r26
    7b50:	0e 94 be 3f 	call	0x7f7c	; 0x7f7c <__udivmodsi4>
    7b54:	da 01       	movw	r26, r20
    7b56:	c9 01       	movw	r24, r18
    7b58:	bc 01       	movw	r22, r24
    7b5a:	cd 01       	movw	r24, r26
    7b5c:	0e 94 ce 05 	call	0xb9c	; 0xb9c <__floatunsisf>
    7b60:	7b 01       	movw	r14, r22
    7b62:	8c 01       	movw	r16, r24
    7b64:	89 89       	ldd	r24, Y+17	; 0x11
    7b66:	88 2f       	mov	r24, r24
    7b68:	90 e0       	ldi	r25, 0x00	; 0
    7b6a:	aa 27       	eor	r26, r26
    7b6c:	97 fd       	sbrc	r25, 7
    7b6e:	a0 95       	com	r26
    7b70:	ba 2f       	mov	r27, r26
    7b72:	bc 01       	movw	r22, r24
    7b74:	cd 01       	movw	r24, r26
    7b76:	0e 94 1c 05 	call	0xa38	; 0xa38 <__floatsisf>
    7b7a:	9b 01       	movw	r18, r22
    7b7c:	ac 01       	movw	r20, r24
    7b7e:	c8 01       	movw	r24, r16
    7b80:	b7 01       	movw	r22, r14
    7b82:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <__divsf3>
    7b86:	dc 01       	movw	r26, r24
    7b88:	cb 01       	movw	r24, r22
    7b8a:	bc 01       	movw	r22, r24
    7b8c:	cd 01       	movw	r24, r26
    7b8e:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    7b92:	dc 01       	movw	r26, r24
    7b94:	cb 01       	movw	r24, r22
    7b96:	98 2f       	mov	r25, r24
    7b98:	88 89       	ldd	r24, Y+16	; 0x10
    7b9a:	89 17       	cp	r24, r25
    7b9c:	08 f4       	brcc	.+2      	; 0x7ba0 <pwmdrawer_drawsignal+0x14a>
    7b9e:	ba cf       	rjmp	.-140    	; 0x7b14 <pwmdrawer_drawsignal+0xbe>
			 GLCD_DisplaySpecialPattern(PWM_DRAWER_GLCD_HIGH_LINE);
			 pixel_width+=5;
		 }
		 GLCD_DisplaySpecialPattern(PWM_DRAWER_GLCD_FALLING_EDGE);
    7ba0:	22 e0       	ldi	r18, 0x02	; 2
    7ba2:	32 e0       	ldi	r19, 0x02	; 2
    7ba4:	4e e7       	ldi	r20, 0x7E	; 126
    7ba6:	50 e4       	ldi	r21, 0x40	; 64
    7ba8:	60 e4       	ldi	r22, 0x40	; 64
    7baa:	70 e0       	ldi	r23, 0x00	; 0
    7bac:	80 e0       	ldi	r24, 0x00	; 0
    7bae:	90 e0       	ldi	r25, 0x00	; 0
    7bb0:	0e 94 91 37 	call	0x6f22	; 0x6f22 <GLCD_DisplaySpecialPattern>
				 pixel_width+=5;
    7bb4:	8a 89       	ldd	r24, Y+18	; 0x12
    7bb6:	8b 5f       	subi	r24, 0xFB	; 251
    7bb8:	8a 8b       	std	Y+18, r24	; 0x12
				 for(uint8 i=0; i<(uint8)((float)((g_timePeriod-g_timeHigh)/1000)/scale_ms);i++){
    7bba:	1f 86       	std	Y+15, r1	; 0x0f
    7bbc:	10 c0       	rjmp	.+32     	; 0x7bde <pwmdrawer_drawsignal+0x188>
					 GLCD_DisplaySpecialPattern(PWM_DRAWER_GLCD_LOW_LINE);
    7bbe:	20 e4       	ldi	r18, 0x40	; 64
    7bc0:	30 e4       	ldi	r19, 0x40	; 64
    7bc2:	40 e4       	ldi	r20, 0x40	; 64
    7bc4:	50 e4       	ldi	r21, 0x40	; 64
    7bc6:	60 e4       	ldi	r22, 0x40	; 64
    7bc8:	70 e0       	ldi	r23, 0x00	; 0
    7bca:	80 e0       	ldi	r24, 0x00	; 0
    7bcc:	90 e0       	ldi	r25, 0x00	; 0
    7bce:	0e 94 91 37 	call	0x6f22	; 0x6f22 <GLCD_DisplaySpecialPattern>
					 pixel_width+=5;
    7bd2:	8a 89       	ldd	r24, Y+18	; 0x12
    7bd4:	8b 5f       	subi	r24, 0xFB	; 251
    7bd6:	8a 8b       	std	Y+18, r24	; 0x12
			 GLCD_DisplaySpecialPattern(PWM_DRAWER_GLCD_HIGH_LINE);
			 pixel_width+=5;
		 }
		 GLCD_DisplaySpecialPattern(PWM_DRAWER_GLCD_FALLING_EDGE);
				 pixel_width+=5;
				 for(uint8 i=0; i<(uint8)((float)((g_timePeriod-g_timeHigh)/1000)/scale_ms);i++){
    7bd8:	8f 85       	ldd	r24, Y+15	; 0x0f
    7bda:	8f 5f       	subi	r24, 0xFF	; 255
    7bdc:	8f 87       	std	Y+15, r24	; 0x0f
    7bde:	20 91 bb 15 	lds	r18, 0x15BB
    7be2:	30 91 bc 15 	lds	r19, 0x15BC
    7be6:	40 91 bd 15 	lds	r20, 0x15BD
    7bea:	50 91 be 15 	lds	r21, 0x15BE
    7bee:	80 91 b7 15 	lds	r24, 0x15B7
    7bf2:	90 91 b8 15 	lds	r25, 0x15B8
    7bf6:	a0 91 b9 15 	lds	r26, 0x15B9
    7bfa:	b0 91 ba 15 	lds	r27, 0x15BA
    7bfe:	79 01       	movw	r14, r18
    7c00:	8a 01       	movw	r16, r20
    7c02:	e8 1a       	sub	r14, r24
    7c04:	f9 0a       	sbc	r15, r25
    7c06:	0a 0b       	sbc	r16, r26
    7c08:	1b 0b       	sbc	r17, r27
    7c0a:	d8 01       	movw	r26, r16
    7c0c:	c7 01       	movw	r24, r14
    7c0e:	28 ee       	ldi	r18, 0xE8	; 232
    7c10:	33 e0       	ldi	r19, 0x03	; 3
    7c12:	40 e0       	ldi	r20, 0x00	; 0
    7c14:	50 e0       	ldi	r21, 0x00	; 0
    7c16:	bc 01       	movw	r22, r24
    7c18:	cd 01       	movw	r24, r26
    7c1a:	0e 94 be 3f 	call	0x7f7c	; 0x7f7c <__udivmodsi4>
    7c1e:	da 01       	movw	r26, r20
    7c20:	c9 01       	movw	r24, r18
    7c22:	bc 01       	movw	r22, r24
    7c24:	cd 01       	movw	r24, r26
    7c26:	0e 94 ce 05 	call	0xb9c	; 0xb9c <__floatunsisf>
    7c2a:	7b 01       	movw	r14, r22
    7c2c:	8c 01       	movw	r16, r24
    7c2e:	89 89       	ldd	r24, Y+17	; 0x11
    7c30:	88 2f       	mov	r24, r24
    7c32:	90 e0       	ldi	r25, 0x00	; 0
    7c34:	aa 27       	eor	r26, r26
    7c36:	97 fd       	sbrc	r25, 7
    7c38:	a0 95       	com	r26
    7c3a:	ba 2f       	mov	r27, r26
    7c3c:	bc 01       	movw	r22, r24
    7c3e:	cd 01       	movw	r24, r26
    7c40:	0e 94 1c 05 	call	0xa38	; 0xa38 <__floatsisf>
    7c44:	9b 01       	movw	r18, r22
    7c46:	ac 01       	movw	r20, r24
    7c48:	c8 01       	movw	r24, r16
    7c4a:	b7 01       	movw	r22, r14
    7c4c:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <__divsf3>
    7c50:	dc 01       	movw	r26, r24
    7c52:	cb 01       	movw	r24, r22
    7c54:	bc 01       	movw	r22, r24
    7c56:	cd 01       	movw	r24, r26
    7c58:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    7c5c:	dc 01       	movw	r26, r24
    7c5e:	cb 01       	movw	r24, r22
    7c60:	98 2f       	mov	r25, r24
    7c62:	8f 85       	ldd	r24, Y+15	; 0x0f
    7c64:	89 17       	cp	r24, r25
    7c66:	08 f4       	brcc	.+2      	; 0x7c6a <pwmdrawer_drawsignal+0x214>
    7c68:	aa cf       	rjmp	.-172    	; 0x7bbe <pwmdrawer_drawsignal+0x168>

	uint8 pixel_width=0;
	uint8 scale_ms=period/5;


	 while(pixel_width<GLCD_MAX_LINE_PIXEL-8){
    7c6a:	8a 89       	ldd	r24, Y+18	; 0x12
    7c6c:	88 37       	cpi	r24, 0x78	; 120
    7c6e:	08 f4       	brcc	.+2      	; 0x7c72 <pwmdrawer_drawsignal+0x21c>
    7c70:	42 cf       	rjmp	.-380    	; 0x7af6 <pwmdrawer_drawsignal+0xa0>
    7c72:	80 e0       	ldi	r24, 0x00	; 0
    7c74:	90 e0       	ldi	r25, 0x00	; 0
    7c76:	aa e7       	ldi	r26, 0x7A	; 122
    7c78:	b4 e4       	ldi	r27, 0x44	; 68
    7c7a:	8b 87       	std	Y+11, r24	; 0x0b
    7c7c:	9c 87       	std	Y+12, r25	; 0x0c
    7c7e:	ad 87       	std	Y+13, r26	; 0x0d
    7c80:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7c82:	6b 85       	ldd	r22, Y+11	; 0x0b
    7c84:	7c 85       	ldd	r23, Y+12	; 0x0c
    7c86:	8d 85       	ldd	r24, Y+13	; 0x0d
    7c88:	9e 85       	ldd	r25, Y+14	; 0x0e
    7c8a:	20 e0       	ldi	r18, 0x00	; 0
    7c8c:	30 e0       	ldi	r19, 0x00	; 0
    7c8e:	4a e7       	ldi	r20, 0x7A	; 122
    7c90:	53 e4       	ldi	r21, 0x43	; 67
    7c92:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    7c96:	dc 01       	movw	r26, r24
    7c98:	cb 01       	movw	r24, r22
    7c9a:	8f 83       	std	Y+7, r24	; 0x07
    7c9c:	98 87       	std	Y+8, r25	; 0x08
    7c9e:	a9 87       	std	Y+9, r26	; 0x09
    7ca0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    7ca2:	6f 81       	ldd	r22, Y+7	; 0x07
    7ca4:	78 85       	ldd	r23, Y+8	; 0x08
    7ca6:	89 85       	ldd	r24, Y+9	; 0x09
    7ca8:	9a 85       	ldd	r25, Y+10	; 0x0a
    7caa:	20 e0       	ldi	r18, 0x00	; 0
    7cac:	30 e0       	ldi	r19, 0x00	; 0
    7cae:	40 e8       	ldi	r20, 0x80	; 128
    7cb0:	5f e3       	ldi	r21, 0x3F	; 63
    7cb2:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__ltsf2>
    7cb6:	88 23       	and	r24, r24
    7cb8:	2c f4       	brge	.+10     	; 0x7cc4 <pwmdrawer_drawsignal+0x26e>
		__ticks = 1;
    7cba:	81 e0       	ldi	r24, 0x01	; 1
    7cbc:	90 e0       	ldi	r25, 0x00	; 0
    7cbe:	9e 83       	std	Y+6, r25	; 0x06
    7cc0:	8d 83       	std	Y+5, r24	; 0x05
    7cc2:	3f c0       	rjmp	.+126    	; 0x7d42 <pwmdrawer_drawsignal+0x2ec>
	else if (__tmp > 65535)
    7cc4:	6f 81       	ldd	r22, Y+7	; 0x07
    7cc6:	78 85       	ldd	r23, Y+8	; 0x08
    7cc8:	89 85       	ldd	r24, Y+9	; 0x09
    7cca:	9a 85       	ldd	r25, Y+10	; 0x0a
    7ccc:	20 e0       	ldi	r18, 0x00	; 0
    7cce:	3f ef       	ldi	r19, 0xFF	; 255
    7cd0:	4f e7       	ldi	r20, 0x7F	; 127
    7cd2:	57 e4       	ldi	r21, 0x47	; 71
    7cd4:	0e 94 8c 04 	call	0x918	; 0x918 <__gtsf2>
    7cd8:	18 16       	cp	r1, r24
    7cda:	4c f5       	brge	.+82     	; 0x7d2e <pwmdrawer_drawsignal+0x2d8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7cdc:	6b 85       	ldd	r22, Y+11	; 0x0b
    7cde:	7c 85       	ldd	r23, Y+12	; 0x0c
    7ce0:	8d 85       	ldd	r24, Y+13	; 0x0d
    7ce2:	9e 85       	ldd	r25, Y+14	; 0x0e
    7ce4:	20 e0       	ldi	r18, 0x00	; 0
    7ce6:	30 e0       	ldi	r19, 0x00	; 0
    7ce8:	40 e2       	ldi	r20, 0x20	; 32
    7cea:	51 e4       	ldi	r21, 0x41	; 65
    7cec:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    7cf0:	dc 01       	movw	r26, r24
    7cf2:	cb 01       	movw	r24, r22
    7cf4:	bc 01       	movw	r22, r24
    7cf6:	cd 01       	movw	r24, r26
    7cf8:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    7cfc:	dc 01       	movw	r26, r24
    7cfe:	cb 01       	movw	r24, r22
    7d00:	9e 83       	std	Y+6, r25	; 0x06
    7d02:	8d 83       	std	Y+5, r24	; 0x05
    7d04:	0f c0       	rjmp	.+30     	; 0x7d24 <pwmdrawer_drawsignal+0x2ce>
    7d06:	89 e1       	ldi	r24, 0x19	; 25
    7d08:	90 e0       	ldi	r25, 0x00	; 0
    7d0a:	9c 83       	std	Y+4, r25	; 0x04
    7d0c:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    7d10:	9c 81       	ldd	r25, Y+4	; 0x04
    7d12:	01 97       	sbiw	r24, 0x01	; 1
    7d14:	f1 f7       	brne	.-4      	; 0x7d12 <pwmdrawer_drawsignal+0x2bc>
    7d16:	9c 83       	std	Y+4, r25	; 0x04
    7d18:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7d1a:	8d 81       	ldd	r24, Y+5	; 0x05
    7d1c:	9e 81       	ldd	r25, Y+6	; 0x06
    7d1e:	01 97       	sbiw	r24, 0x01	; 1
    7d20:	9e 83       	std	Y+6, r25	; 0x06
    7d22:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7d24:	8d 81       	ldd	r24, Y+5	; 0x05
    7d26:	9e 81       	ldd	r25, Y+6	; 0x06
    7d28:	00 97       	sbiw	r24, 0x00	; 0
    7d2a:	69 f7       	brne	.-38     	; 0x7d06 <pwmdrawer_drawsignal+0x2b0>
    7d2c:	14 c0       	rjmp	.+40     	; 0x7d56 <pwmdrawer_drawsignal+0x300>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7d2e:	6f 81       	ldd	r22, Y+7	; 0x07
    7d30:	78 85       	ldd	r23, Y+8	; 0x08
    7d32:	89 85       	ldd	r24, Y+9	; 0x09
    7d34:	9a 85       	ldd	r25, Y+10	; 0x0a
    7d36:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    7d3a:	dc 01       	movw	r26, r24
    7d3c:	cb 01       	movw	r24, r22
    7d3e:	9e 83       	std	Y+6, r25	; 0x06
    7d40:	8d 83       	std	Y+5, r24	; 0x05
    7d42:	8d 81       	ldd	r24, Y+5	; 0x05
    7d44:	9e 81       	ldd	r25, Y+6	; 0x06
    7d46:	9a 83       	std	Y+2, r25	; 0x02
    7d48:	89 83       	std	Y+1, r24	; 0x01
    7d4a:	89 81       	ldd	r24, Y+1	; 0x01
    7d4c:	9a 81       	ldd	r25, Y+2	; 0x02
    7d4e:	01 97       	sbiw	r24, 0x01	; 1
    7d50:	f1 f7       	brne	.-4      	; 0x7d4e <pwmdrawer_drawsignal+0x2f8>
    7d52:	9a 83       	std	Y+2, r25	; 0x02
    7d54:	89 83       	std	Y+1, r24	; 0x01
					 pixel_width+=5;
				 }
	 }
_delay_ms(1000);

	 GLCD_ClearDisplay();
    7d56:	0e 94 ca 3b 	call	0x7794	; 0x7794 <GLCD_ClearDisplay>
	 Icu_init(&icu_config);
    7d5a:	8b e2       	ldi	r24, 0x2B	; 43
    7d5c:	95 e0       	ldi	r25, 0x05	; 5
    7d5e:	0e 94 d0 32 	call	0x65a0	; 0x65a0 <Icu_init>


}
    7d62:	62 96       	adiw	r28, 0x12	; 18
    7d64:	0f b6       	in	r0, 0x3f	; 63
    7d66:	f8 94       	cli
    7d68:	de bf       	out	0x3e, r29	; 62
    7d6a:	0f be       	out	0x3f, r0	; 63
    7d6c:	cd bf       	out	0x3d, r28	; 61
    7d6e:	cf 91       	pop	r28
    7d70:	df 91       	pop	r29
    7d72:	1f 91       	pop	r17
    7d74:	0f 91       	pop	r16
    7d76:	ff 90       	pop	r15
    7d78:	ef 90       	pop	r14
    7d7a:	08 95       	ret

00007d7c <main>:
void vtask2(void *pvParameters);
xSemaphoreHandle xBinarySemaphore;



int main(void){
    7d7c:	ef 92       	push	r14
    7d7e:	ff 92       	push	r15
    7d80:	0f 93       	push	r16
    7d82:	df 93       	push	r29
    7d84:	cf 93       	push	r28
    7d86:	cd b7       	in	r28, 0x3d	; 61
    7d88:	de b7       	in	r29, 0x3e	; 62



prvSetupHardware();
    7d8a:	0e 94 ef 3e 	call	0x7dde	; 0x7dde <prvSetupHardware>

xTaskCreate(vtask1, "measure & draw signal", 256, NULL, 2, NULL);
    7d8e:	8f ef       	ldi	r24, 0xFF	; 255
    7d90:	9e e3       	ldi	r25, 0x3E	; 62
    7d92:	2c e1       	ldi	r18, 0x1C	; 28
    7d94:	32 e0       	ldi	r19, 0x02	; 2
    7d96:	b9 01       	movw	r22, r18
    7d98:	40 e0       	ldi	r20, 0x00	; 0
    7d9a:	51 e0       	ldi	r21, 0x01	; 1
    7d9c:	20 e0       	ldi	r18, 0x00	; 0
    7d9e:	30 e0       	ldi	r19, 0x00	; 0
    7da0:	02 e0       	ldi	r16, 0x02	; 2
    7da2:	ee 24       	eor	r14, r14
    7da4:	ff 24       	eor	r15, r15
    7da6:	0e 94 12 1a 	call	0x3424	; 0x3424 <xTaskCreate>
xTaskCreate(vtask2, "check condition", 256, NULL, 1, NULL);
    7daa:	8e e8       	ldi	r24, 0x8E	; 142
    7dac:	9f e3       	ldi	r25, 0x3F	; 63
    7dae:	22 e3       	ldi	r18, 0x32	; 50
    7db0:	32 e0       	ldi	r19, 0x02	; 2
    7db2:	b9 01       	movw	r22, r18
    7db4:	40 e0       	ldi	r20, 0x00	; 0
    7db6:	51 e0       	ldi	r21, 0x01	; 1
    7db8:	20 e0       	ldi	r18, 0x00	; 0
    7dba:	30 e0       	ldi	r19, 0x00	; 0
    7dbc:	01 e0       	ldi	r16, 0x01	; 1
    7dbe:	ee 24       	eor	r14, r14
    7dc0:	ff 24       	eor	r15, r15
    7dc2:	0e 94 12 1a 	call	0x3424	; 0x3424 <xTaskCreate>


 xBinarySemaphore=xSemaphoreCreateBinary();
    7dc6:	81 e0       	ldi	r24, 0x01	; 1
    7dc8:	60 e0       	ldi	r22, 0x00	; 0
    7dca:	43 e0       	ldi	r20, 0x03	; 3
    7dcc:	0e 94 ce 11 	call	0x239c	; 0x239c <xQueueGenericCreate>
    7dd0:	90 93 c4 15 	sts	0x15C4, r25
    7dd4:	80 93 c3 15 	sts	0x15C3, r24



vTaskStartScheduler();
    7dd8:	0e 94 49 1c 	call	0x3892	; 0x3892 <vTaskStartScheduler>
    7ddc:	ff cf       	rjmp	.-2      	; 0x7ddc <main+0x60>

00007dde <prvSetupHardware>:


}

static void prvSetupHardware( void )
{
    7dde:	df 93       	push	r29
    7de0:	cf 93       	push	r28
    7de2:	cd b7       	in	r28, 0x3d	; 61
    7de4:	de b7       	in	r29, 0x3e	; 62
	/* Place here any needed HW initialization such as GPIO, UART, etc.  */
	SREG |=(1<<7);
    7de6:	af e5       	ldi	r26, 0x5F	; 95
    7de8:	b0 e0       	ldi	r27, 0x00	; 0
    7dea:	ef e5       	ldi	r30, 0x5F	; 95
    7dec:	f0 e0       	ldi	r31, 0x00	; 0
    7dee:	80 81       	ld	r24, Z
    7df0:	80 68       	ori	r24, 0x80	; 128
    7df2:	8c 93       	st	X, r24
  pwmdrawer_init();
    7df4:	0e 94 57 3c 	call	0x78ae	; 0x78ae <pwmdrawer_init>
}
    7df8:	cf 91       	pop	r28
    7dfa:	df 91       	pop	r29
    7dfc:	08 95       	ret

00007dfe <vtask1>:

void vtask1(void *pvParameters){
    7dfe:	df 93       	push	r29
    7e00:	cf 93       	push	r28
    7e02:	cd b7       	in	r28, 0x3d	; 61
    7e04:	de b7       	in	r29, 0x3e	; 62
    7e06:	60 97       	sbiw	r28, 0x10	; 16
    7e08:	0f b6       	in	r0, 0x3f	; 63
    7e0a:	f8 94       	cli
    7e0c:	de bf       	out	0x3e, r29	; 62
    7e0e:	0f be       	out	0x3f, r0	; 63
    7e10:	cd bf       	out	0x3d, r28	; 61
    7e12:	98 8b       	std	Y+16, r25	; 0x10
    7e14:	8f 87       	std	Y+15, r24	; 0x0f


	for(;;){
	if (xSemaphoreTake(xBinarySemaphore, portMAX_DELAY) == pdTRUE){
    7e16:	80 91 c3 15 	lds	r24, 0x15C3
    7e1a:	90 91 c4 15 	lds	r25, 0x15C4
    7e1e:	4f ef       	ldi	r20, 0xFF	; 255
    7e20:	5f ef       	ldi	r21, 0xFF	; 255
    7e22:	6f ef       	ldi	r22, 0xFF	; 255
    7e24:	7f ef       	ldi	r23, 0xFF	; 255
    7e26:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <xQueueSemaphoreTake>
    7e2a:	81 30       	cpi	r24, 0x01	; 1
    7e2c:	a1 f7       	brne	.-24     	; 0x7e16 <vtask1+0x18>
		pwmdrawer_measuresginal();
    7e2e:	0e 94 68 3c 	call	0x78d0	; 0x78d0 <pwmdrawer_measuresginal>
		pwmdrawer_drawsignal();
    7e32:	0e 94 2b 3d 	call	0x7a56	; 0x7a56 <pwmdrawer_drawsignal>
    7e36:	80 e0       	ldi	r24, 0x00	; 0
    7e38:	90 e0       	ldi	r25, 0x00	; 0
    7e3a:	a0 e2       	ldi	r26, 0x20	; 32
    7e3c:	b1 e4       	ldi	r27, 0x41	; 65
    7e3e:	8b 87       	std	Y+11, r24	; 0x0b
    7e40:	9c 87       	std	Y+12, r25	; 0x0c
    7e42:	ad 87       	std	Y+13, r26	; 0x0d
    7e44:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7e46:	6b 85       	ldd	r22, Y+11	; 0x0b
    7e48:	7c 85       	ldd	r23, Y+12	; 0x0c
    7e4a:	8d 85       	ldd	r24, Y+13	; 0x0d
    7e4c:	9e 85       	ldd	r25, Y+14	; 0x0e
    7e4e:	20 e0       	ldi	r18, 0x00	; 0
    7e50:	30 e0       	ldi	r19, 0x00	; 0
    7e52:	4a e7       	ldi	r20, 0x7A	; 122
    7e54:	53 e4       	ldi	r21, 0x43	; 67
    7e56:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    7e5a:	dc 01       	movw	r26, r24
    7e5c:	cb 01       	movw	r24, r22
    7e5e:	8f 83       	std	Y+7, r24	; 0x07
    7e60:	98 87       	std	Y+8, r25	; 0x08
    7e62:	a9 87       	std	Y+9, r26	; 0x09
    7e64:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    7e66:	6f 81       	ldd	r22, Y+7	; 0x07
    7e68:	78 85       	ldd	r23, Y+8	; 0x08
    7e6a:	89 85       	ldd	r24, Y+9	; 0x09
    7e6c:	9a 85       	ldd	r25, Y+10	; 0x0a
    7e6e:	20 e0       	ldi	r18, 0x00	; 0
    7e70:	30 e0       	ldi	r19, 0x00	; 0
    7e72:	40 e8       	ldi	r20, 0x80	; 128
    7e74:	5f e3       	ldi	r21, 0x3F	; 63
    7e76:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__ltsf2>
    7e7a:	88 23       	and	r24, r24
    7e7c:	2c f4       	brge	.+10     	; 0x7e88 <vtask1+0x8a>
		__ticks = 1;
    7e7e:	81 e0       	ldi	r24, 0x01	; 1
    7e80:	90 e0       	ldi	r25, 0x00	; 0
    7e82:	9e 83       	std	Y+6, r25	; 0x06
    7e84:	8d 83       	std	Y+5, r24	; 0x05
    7e86:	3f c0       	rjmp	.+126    	; 0x7f06 <vtask1+0x108>
	else if (__tmp > 65535)
    7e88:	6f 81       	ldd	r22, Y+7	; 0x07
    7e8a:	78 85       	ldd	r23, Y+8	; 0x08
    7e8c:	89 85       	ldd	r24, Y+9	; 0x09
    7e8e:	9a 85       	ldd	r25, Y+10	; 0x0a
    7e90:	20 e0       	ldi	r18, 0x00	; 0
    7e92:	3f ef       	ldi	r19, 0xFF	; 255
    7e94:	4f e7       	ldi	r20, 0x7F	; 127
    7e96:	57 e4       	ldi	r21, 0x47	; 71
    7e98:	0e 94 8c 04 	call	0x918	; 0x918 <__gtsf2>
    7e9c:	18 16       	cp	r1, r24
    7e9e:	4c f5       	brge	.+82     	; 0x7ef2 <vtask1+0xf4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7ea0:	6b 85       	ldd	r22, Y+11	; 0x0b
    7ea2:	7c 85       	ldd	r23, Y+12	; 0x0c
    7ea4:	8d 85       	ldd	r24, Y+13	; 0x0d
    7ea6:	9e 85       	ldd	r25, Y+14	; 0x0e
    7ea8:	20 e0       	ldi	r18, 0x00	; 0
    7eaa:	30 e0       	ldi	r19, 0x00	; 0
    7eac:	40 e2       	ldi	r20, 0x20	; 32
    7eae:	51 e4       	ldi	r21, 0x41	; 65
    7eb0:	0e 94 e6 02 	call	0x5cc	; 0x5cc <__mulsf3>
    7eb4:	dc 01       	movw	r26, r24
    7eb6:	cb 01       	movw	r24, r22
    7eb8:	bc 01       	movw	r22, r24
    7eba:	cd 01       	movw	r24, r26
    7ebc:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    7ec0:	dc 01       	movw	r26, r24
    7ec2:	cb 01       	movw	r24, r22
    7ec4:	9e 83       	std	Y+6, r25	; 0x06
    7ec6:	8d 83       	std	Y+5, r24	; 0x05
    7ec8:	0f c0       	rjmp	.+30     	; 0x7ee8 <vtask1+0xea>
    7eca:	89 e1       	ldi	r24, 0x19	; 25
    7ecc:	90 e0       	ldi	r25, 0x00	; 0
    7ece:	9c 83       	std	Y+4, r25	; 0x04
    7ed0:	8b 83       	std	Y+3, r24	; 0x03
    7ed2:	8b 81       	ldd	r24, Y+3	; 0x03
    7ed4:	9c 81       	ldd	r25, Y+4	; 0x04
    7ed6:	01 97       	sbiw	r24, 0x01	; 1
    7ed8:	f1 f7       	brne	.-4      	; 0x7ed6 <vtask1+0xd8>
    7eda:	9c 83       	std	Y+4, r25	; 0x04
    7edc:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7ede:	8d 81       	ldd	r24, Y+5	; 0x05
    7ee0:	9e 81       	ldd	r25, Y+6	; 0x06
    7ee2:	01 97       	sbiw	r24, 0x01	; 1
    7ee4:	9e 83       	std	Y+6, r25	; 0x06
    7ee6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7ee8:	8d 81       	ldd	r24, Y+5	; 0x05
    7eea:	9e 81       	ldd	r25, Y+6	; 0x06
    7eec:	00 97       	sbiw	r24, 0x00	; 0
    7eee:	69 f7       	brne	.-38     	; 0x7eca <vtask1+0xcc>
    7ef0:	92 cf       	rjmp	.-220    	; 0x7e16 <vtask1+0x18>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7ef2:	6f 81       	ldd	r22, Y+7	; 0x07
    7ef4:	78 85       	ldd	r23, Y+8	; 0x08
    7ef6:	89 85       	ldd	r24, Y+9	; 0x09
    7ef8:	9a 85       	ldd	r25, Y+10	; 0x0a
    7efa:	0e 94 10 01 	call	0x220	; 0x220 <__fixunssfsi>
    7efe:	dc 01       	movw	r26, r24
    7f00:	cb 01       	movw	r24, r22
    7f02:	9e 83       	std	Y+6, r25	; 0x06
    7f04:	8d 83       	std	Y+5, r24	; 0x05
    7f06:	8d 81       	ldd	r24, Y+5	; 0x05
    7f08:	9e 81       	ldd	r25, Y+6	; 0x06
    7f0a:	9a 83       	std	Y+2, r25	; 0x02
    7f0c:	89 83       	std	Y+1, r24	; 0x01
    7f0e:	89 81       	ldd	r24, Y+1	; 0x01
    7f10:	9a 81       	ldd	r25, Y+2	; 0x02
    7f12:	01 97       	sbiw	r24, 0x01	; 1
    7f14:	f1 f7       	brne	.-4      	; 0x7f12 <vtask1+0x114>
    7f16:	9a 83       	std	Y+2, r25	; 0x02
    7f18:	89 83       	std	Y+1, r24	; 0x01
    7f1a:	7d cf       	rjmp	.-262    	; 0x7e16 <vtask1+0x18>

00007f1c <vtask2>:
	}


}

void vtask2(void *pvParameters){
    7f1c:	0f 93       	push	r16
    7f1e:	df 93       	push	r29
    7f20:	cf 93       	push	r28
    7f22:	00 d0       	rcall	.+0      	; 0x7f24 <vtask2+0x8>
    7f24:	cd b7       	in	r28, 0x3d	; 61
    7f26:	de b7       	in	r29, 0x3e	; 62
    7f28:	9a 83       	std	Y+2, r25	; 0x02
    7f2a:	89 83       	std	Y+1, r24	; 0x01
	for(;;){
		if(g_edgeCount==4){
    7f2c:	80 91 b6 15 	lds	r24, 0x15B6
    7f30:	84 30       	cpi	r24, 0x04	; 4
    7f32:	e1 f7       	brne	.-8      	; 0x7f2c <vtask2+0x10>
			xSemaphoreGive(xBinarySemaphore);
    7f34:	80 91 c3 15 	lds	r24, 0x15C3
    7f38:	90 91 c4 15 	lds	r25, 0x15C4
    7f3c:	60 e0       	ldi	r22, 0x00	; 0
    7f3e:	70 e0       	ldi	r23, 0x00	; 0
    7f40:	20 e0       	ldi	r18, 0x00	; 0
    7f42:	30 e0       	ldi	r19, 0x00	; 0
    7f44:	40 e0       	ldi	r20, 0x00	; 0
    7f46:	50 e0       	ldi	r21, 0x00	; 0
    7f48:	00 e0       	ldi	r16, 0x00	; 0
    7f4a:	0e 94 84 12 	call	0x2508	; 0x2508 <xQueueGenericSend>
			g_edgeCount=0;
    7f4e:	10 92 b6 15 	sts	0x15B6, r1
    7f52:	ec cf       	rjmp	.-40     	; 0x7f2c <vtask2+0x10>

00007f54 <__udivmodhi4>:
    7f54:	aa 1b       	sub	r26, r26
    7f56:	bb 1b       	sub	r27, r27
    7f58:	51 e1       	ldi	r21, 0x11	; 17
    7f5a:	07 c0       	rjmp	.+14     	; 0x7f6a <__udivmodhi4_ep>

00007f5c <__udivmodhi4_loop>:
    7f5c:	aa 1f       	adc	r26, r26
    7f5e:	bb 1f       	adc	r27, r27
    7f60:	a6 17       	cp	r26, r22
    7f62:	b7 07       	cpc	r27, r23
    7f64:	10 f0       	brcs	.+4      	; 0x7f6a <__udivmodhi4_ep>
    7f66:	a6 1b       	sub	r26, r22
    7f68:	b7 0b       	sbc	r27, r23

00007f6a <__udivmodhi4_ep>:
    7f6a:	88 1f       	adc	r24, r24
    7f6c:	99 1f       	adc	r25, r25
    7f6e:	5a 95       	dec	r21
    7f70:	a9 f7       	brne	.-22     	; 0x7f5c <__udivmodhi4_loop>
    7f72:	80 95       	com	r24
    7f74:	90 95       	com	r25
    7f76:	bc 01       	movw	r22, r24
    7f78:	cd 01       	movw	r24, r26
    7f7a:	08 95       	ret

00007f7c <__udivmodsi4>:
    7f7c:	a1 e2       	ldi	r26, 0x21	; 33
    7f7e:	1a 2e       	mov	r1, r26
    7f80:	aa 1b       	sub	r26, r26
    7f82:	bb 1b       	sub	r27, r27
    7f84:	fd 01       	movw	r30, r26
    7f86:	0d c0       	rjmp	.+26     	; 0x7fa2 <__udivmodsi4_ep>

00007f88 <__udivmodsi4_loop>:
    7f88:	aa 1f       	adc	r26, r26
    7f8a:	bb 1f       	adc	r27, r27
    7f8c:	ee 1f       	adc	r30, r30
    7f8e:	ff 1f       	adc	r31, r31
    7f90:	a2 17       	cp	r26, r18
    7f92:	b3 07       	cpc	r27, r19
    7f94:	e4 07       	cpc	r30, r20
    7f96:	f5 07       	cpc	r31, r21
    7f98:	20 f0       	brcs	.+8      	; 0x7fa2 <__udivmodsi4_ep>
    7f9a:	a2 1b       	sub	r26, r18
    7f9c:	b3 0b       	sbc	r27, r19
    7f9e:	e4 0b       	sbc	r30, r20
    7fa0:	f5 0b       	sbc	r31, r21

00007fa2 <__udivmodsi4_ep>:
    7fa2:	66 1f       	adc	r22, r22
    7fa4:	77 1f       	adc	r23, r23
    7fa6:	88 1f       	adc	r24, r24
    7fa8:	99 1f       	adc	r25, r25
    7faa:	1a 94       	dec	r1
    7fac:	69 f7       	brne	.-38     	; 0x7f88 <__udivmodsi4_loop>
    7fae:	60 95       	com	r22
    7fb0:	70 95       	com	r23
    7fb2:	80 95       	com	r24
    7fb4:	90 95       	com	r25
    7fb6:	9b 01       	movw	r18, r22
    7fb8:	ac 01       	movw	r20, r24
    7fba:	bd 01       	movw	r22, r26
    7fbc:	cf 01       	movw	r24, r30
    7fbe:	08 95       	ret

00007fc0 <__prologue_saves__>:
    7fc0:	2f 92       	push	r2
    7fc2:	3f 92       	push	r3
    7fc4:	4f 92       	push	r4
    7fc6:	5f 92       	push	r5
    7fc8:	6f 92       	push	r6
    7fca:	7f 92       	push	r7
    7fcc:	8f 92       	push	r8
    7fce:	9f 92       	push	r9
    7fd0:	af 92       	push	r10
    7fd2:	bf 92       	push	r11
    7fd4:	cf 92       	push	r12
    7fd6:	df 92       	push	r13
    7fd8:	ef 92       	push	r14
    7fda:	ff 92       	push	r15
    7fdc:	0f 93       	push	r16
    7fde:	1f 93       	push	r17
    7fe0:	cf 93       	push	r28
    7fe2:	df 93       	push	r29
    7fe4:	cd b7       	in	r28, 0x3d	; 61
    7fe6:	de b7       	in	r29, 0x3e	; 62
    7fe8:	ca 1b       	sub	r28, r26
    7fea:	db 0b       	sbc	r29, r27
    7fec:	0f b6       	in	r0, 0x3f	; 63
    7fee:	f8 94       	cli
    7ff0:	de bf       	out	0x3e, r29	; 62
    7ff2:	0f be       	out	0x3f, r0	; 63
    7ff4:	cd bf       	out	0x3d, r28	; 61
    7ff6:	09 94       	ijmp

00007ff8 <__epilogue_restores__>:
    7ff8:	2a 88       	ldd	r2, Y+18	; 0x12
    7ffa:	39 88       	ldd	r3, Y+17	; 0x11
    7ffc:	48 88       	ldd	r4, Y+16	; 0x10
    7ffe:	5f 84       	ldd	r5, Y+15	; 0x0f
    8000:	6e 84       	ldd	r6, Y+14	; 0x0e
    8002:	7d 84       	ldd	r7, Y+13	; 0x0d
    8004:	8c 84       	ldd	r8, Y+12	; 0x0c
    8006:	9b 84       	ldd	r9, Y+11	; 0x0b
    8008:	aa 84       	ldd	r10, Y+10	; 0x0a
    800a:	b9 84       	ldd	r11, Y+9	; 0x09
    800c:	c8 84       	ldd	r12, Y+8	; 0x08
    800e:	df 80       	ldd	r13, Y+7	; 0x07
    8010:	ee 80       	ldd	r14, Y+6	; 0x06
    8012:	fd 80       	ldd	r15, Y+5	; 0x05
    8014:	0c 81       	ldd	r16, Y+4	; 0x04
    8016:	1b 81       	ldd	r17, Y+3	; 0x03
    8018:	aa 81       	ldd	r26, Y+2	; 0x02
    801a:	b9 81       	ldd	r27, Y+1	; 0x01
    801c:	ce 0f       	add	r28, r30
    801e:	d1 1d       	adc	r29, r1
    8020:	0f b6       	in	r0, 0x3f	; 63
    8022:	f8 94       	cli
    8024:	de bf       	out	0x3e, r29	; 62
    8026:	0f be       	out	0x3f, r0	; 63
    8028:	cd bf       	out	0x3d, r28	; 61
    802a:	ed 01       	movw	r28, r26
    802c:	08 95       	ret

0000802e <memcpy>:
    802e:	fb 01       	movw	r30, r22
    8030:	dc 01       	movw	r26, r24
    8032:	02 c0       	rjmp	.+4      	; 0x8038 <memcpy+0xa>
    8034:	01 90       	ld	r0, Z+
    8036:	0d 92       	st	X+, r0
    8038:	41 50       	subi	r20, 0x01	; 1
    803a:	50 40       	sbci	r21, 0x00	; 0
    803c:	d8 f7       	brcc	.-10     	; 0x8034 <memcpy+0x6>
    803e:	08 95       	ret

00008040 <memset>:
    8040:	dc 01       	movw	r26, r24
    8042:	01 c0       	rjmp	.+2      	; 0x8046 <memset+0x6>
    8044:	6d 93       	st	X+, r22
    8046:	41 50       	subi	r20, 0x01	; 1
    8048:	50 40       	sbci	r21, 0x00	; 0
    804a:	e0 f7       	brcc	.-8      	; 0x8044 <memset+0x4>
    804c:	08 95       	ret

0000804e <itoa>:
    804e:	fb 01       	movw	r30, r22
    8050:	9f 01       	movw	r18, r30
    8052:	e8 94       	clt
    8054:	42 30       	cpi	r20, 0x02	; 2
    8056:	c4 f0       	brlt	.+48     	; 0x8088 <itoa+0x3a>
    8058:	45 32       	cpi	r20, 0x25	; 37
    805a:	b4 f4       	brge	.+44     	; 0x8088 <itoa+0x3a>
    805c:	4a 30       	cpi	r20, 0x0A	; 10
    805e:	29 f4       	brne	.+10     	; 0x806a <itoa+0x1c>
    8060:	97 fb       	bst	r25, 7
    8062:	1e f4       	brtc	.+6      	; 0x806a <itoa+0x1c>
    8064:	90 95       	com	r25
    8066:	81 95       	neg	r24
    8068:	9f 4f       	sbci	r25, 0xFF	; 255
    806a:	64 2f       	mov	r22, r20
    806c:	77 27       	eor	r23, r23
    806e:	0e 94 aa 3f 	call	0x7f54	; 0x7f54 <__udivmodhi4>
    8072:	80 5d       	subi	r24, 0xD0	; 208
    8074:	8a 33       	cpi	r24, 0x3A	; 58
    8076:	0c f0       	brlt	.+2      	; 0x807a <itoa+0x2c>
    8078:	89 5d       	subi	r24, 0xD9	; 217
    807a:	81 93       	st	Z+, r24
    807c:	cb 01       	movw	r24, r22
    807e:	00 97       	sbiw	r24, 0x00	; 0
    8080:	a1 f7       	brne	.-24     	; 0x806a <itoa+0x1c>
    8082:	16 f4       	brtc	.+4      	; 0x8088 <itoa+0x3a>
    8084:	5d e2       	ldi	r21, 0x2D	; 45
    8086:	51 93       	st	Z+, r21
    8088:	10 82       	st	Z, r1
    808a:	c9 01       	movw	r24, r18
    808c:	0c 94 48 40 	jmp	0x8090	; 0x8090 <strrev>

00008090 <strrev>:
    8090:	dc 01       	movw	r26, r24
    8092:	fc 01       	movw	r30, r24
    8094:	67 2f       	mov	r22, r23
    8096:	71 91       	ld	r23, Z+
    8098:	77 23       	and	r23, r23
    809a:	e1 f7       	brne	.-8      	; 0x8094 <strrev+0x4>
    809c:	32 97       	sbiw	r30, 0x02	; 2
    809e:	04 c0       	rjmp	.+8      	; 0x80a8 <strrev+0x18>
    80a0:	7c 91       	ld	r23, X
    80a2:	6d 93       	st	X+, r22
    80a4:	70 83       	st	Z, r23
    80a6:	62 91       	ld	r22, -Z
    80a8:	ae 17       	cp	r26, r30
    80aa:	bf 07       	cpc	r27, r31
    80ac:	c8 f3       	brcs	.-14     	; 0x80a0 <strrev+0x10>
    80ae:	08 95       	ret

000080b0 <_exit>:
    80b0:	f8 94       	cli

000080b2 <__stop_program>:
    80b2:	ff cf       	rjmp	.-2      	; 0x80b2 <__stop_program>
